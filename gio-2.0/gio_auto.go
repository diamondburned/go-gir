package gio

/*
#cgo pkg-config: gio-2.0 gio-unix-2.0
#include <gio/gdesktopappinfo.h>
#include <gio/gfiledescriptorbased.h>
#include <gio/gio.h>
#include <gio/gunixconnection.h>
#include <gio/gunixcredentialsmessage.h>
#include <gio/gunixfdlist.h>
#include <gio/gunixfdmessage.h>
#include <gio/gunixinputstream.h>
#include <gio/gunixmounts.h>
#include <gio/gunixoutputstream.h>
#include <gio/gunixsocketaddress.h>
extern void myAsyncReadyCallback(GObject* source_object, GAsyncResult* res, gpointer user_data);
static void* getPointer_myAsyncReadyCallback() {
return (void*)(myAsyncReadyCallback);
}
extern void myBusAcquiredCallback(GDBusConnection* connection, gchar* name, gpointer user_data);
static void* getPointer_myBusAcquiredCallback() {
return (void*)(myBusAcquiredCallback);
}
extern void myBusNameAcquiredCallback(GDBusConnection* connection, gchar* name, gpointer user_data);
static void* getPointer_myBusNameAcquiredCallback() {
return (void*)(myBusNameAcquiredCallback);
}
extern void myBusNameAppearedCallback(GDBusConnection* connection, gchar* name, gchar* name_owner, gpointer user_data);
static void* getPointer_myBusNameAppearedCallback() {
return (void*)(myBusNameAppearedCallback);
}
extern void myBusNameLostCallback(GDBusConnection* connection, gchar* name, gpointer user_data);
static void* getPointer_myBusNameLostCallback() {
return (void*)(myBusNameLostCallback);
}
extern void myBusNameVanishedCallback(GDBusConnection* connection, gchar* name, gpointer user_data);
static void* getPointer_myBusNameVanishedCallback() {
return (void*)(myBusNameVanishedCallback);
}
extern void myCancellableSourceFunc(GCancellable* cancellable, gpointer user_data);
static void* getPointer_myCancellableSourceFunc() {
return (void*)(myCancellableSourceFunc);
}
extern void myDBusInterfaceGetPropertyFunc(GDBusConnection* connection, gchar* sender, gchar* object_path, gchar* interface_name, gchar* property_name, GError** error, gpointer user_data);
static void* getPointer_myDBusInterfaceGetPropertyFunc() {
return (void*)(myDBusInterfaceGetPropertyFunc);
}
extern void myDBusInterfaceMethodCallFunc(GDBusConnection* connection, gchar* sender, gchar* object_path, gchar* interface_name, gchar* method_name, GVariant* parameters, GDBusMethodInvocation* invocation, gpointer user_data);
static void* getPointer_myDBusInterfaceMethodCallFunc() {
return (void*)(myDBusInterfaceMethodCallFunc);
}
extern void myDBusInterfaceSetPropertyFunc(GDBusConnection* connection, gchar* sender, gchar* object_path, gchar* interface_name, gchar* property_name, GVariant* value, GError** error, gpointer user_data);
static void* getPointer_myDBusInterfaceSetPropertyFunc() {
return (void*)(myDBusInterfaceSetPropertyFunc);
}
extern void myDBusMessageFilterFunction(GDBusConnection* connection, GDBusMessage* message, gboolean incoming, gpointer user_data);
static void* getPointer_myDBusMessageFilterFunction() {
return (void*)(myDBusMessageFilterFunction);
}
extern void myDBusProxyTypeFunc(GDBusObjectManagerClient* manager, gchar* object_path, gchar* interface_name, gpointer user_data);
static void* getPointer_myDBusProxyTypeFunc() {
return (void*)(myDBusProxyTypeFunc);
}
extern void myDBusSignalCallback(GDBusConnection* connection, gchar* sender_name, gchar* object_path, gchar* interface_name, gchar* signal_name, GVariant* parameters, gpointer user_data);
static void* getPointer_myDBusSignalCallback() {
return (void*)(myDBusSignalCallback);
}
extern void myDBusSubtreeDispatchFunc(GDBusConnection* connection, gchar* sender, gchar* object_path, gchar* interface_name, gchar* node, gpointer out_user_data, gpointer user_data);
static void* getPointer_myDBusSubtreeDispatchFunc() {
return (void*)(myDBusSubtreeDispatchFunc);
}
extern void myDBusSubtreeIntrospectFunc(GDBusConnection* connection, gchar* sender, gchar* object_path, gchar* node, gpointer user_data);
static void* getPointer_myDBusSubtreeIntrospectFunc() {
return (void*)(myDBusSubtreeIntrospectFunc);
}
extern void myDatagramBasedSourceFunc(GDatagramBased* datagram_based, GIOCondition condition, gpointer user_data);
static void* getPointer_myDatagramBasedSourceFunc() {
return (void*)(myDatagramBasedSourceFunc);
}
extern void myDesktopAppLaunchCallback(GDesktopAppInfo* appinfo, gint32 pid, gpointer user_data);
static void* getPointer_myDesktopAppLaunchCallback() {
return (void*)(myDesktopAppLaunchCallback);
}
extern void myFileMeasureProgressCallback(gboolean reporting, guint64 current_size, guint64 num_dirs, guint64 num_files, gpointer user_data);
static void* getPointer_myFileMeasureProgressCallback() {
return (void*)(myFileMeasureProgressCallback);
}
extern void myFileProgressCallback(gint64 current_num_bytes, gint64 total_num_bytes, gpointer user_data);
static void* getPointer_myFileProgressCallback() {
return (void*)(myFileProgressCallback);
}
extern void myIOSchedulerJobFunc(GIOSchedulerJob* job, GCancellable* cancellable, gpointer user_data);
static void* getPointer_myIOSchedulerJobFunc() {
return (void*)(myIOSchedulerJobFunc);
}
extern void myPollableSourceFunc(GObject* pollable_stream, gpointer user_data);
static void* getPointer_myPollableSourceFunc() {
return (void*)(myPollableSourceFunc);
}
extern void mySettingsBindGetMapping(GValue* value, GVariant* variant, gpointer user_data);
static void* getPointer_mySettingsBindGetMapping() {
return (void*)(mySettingsBindGetMapping);
}
extern void mySettingsBindSetMapping(GValue* value, GVariantType* expected_type, gpointer user_data);
static void* getPointer_mySettingsBindSetMapping() {
return (void*)(mySettingsBindSetMapping);
}
extern void mySettingsGetMapping(GVariant* value, gpointer user_data);
static void* getPointer_mySettingsGetMapping() {
return (void*)(mySettingsGetMapping);
}
extern void mySocketSourceFunc(GSocket* socket, GIOCondition condition, gpointer user_data);
static void* getPointer_mySocketSourceFunc() {
return (void*)(mySocketSourceFunc);
}
extern void myVfsFileLookupFunc(GVfs* vfs, gchar* identifier, gpointer user_data);
static void* getPointer_myVfsFileLookupFunc() {
return (void*)(myVfsFileLookupFunc);
}
*/
import "C"
import "github.com/electricface/go-gir/glib-2.0"
import "github.com/electricface/go-gir/gobject-2.0"
import "github.com/electricface/go-gir3/gi"
import "log"
import "unsafe"

var _I = gi.NewInvokerCache("Gio")
var _ unsafe.Pointer
var _ *log.Logger

func init() {
	repo := gi.DefaultRepository()
	_, err := repo.Require("Gio", "2.0", gi.REPOSITORY_LOAD_FLAG_LAZY)
	if err != nil {
		panic(err)
	}
}

// Interface Action
type Action struct {
	ActionIfc
	P unsafe.Pointer
}
type ActionIfc struct{}
type IAction interface{ P_Action() unsafe.Pointer }

func (v Action) P_Action() unsafe.Pointer { return v.P }
func ActionGetType() gi.GType {
	ret := _I.GetGType(0, "Action")
	return ret
}

// g_action_name_is_valid
// container is not nil, container is Action
// is method
// arg0Type tag: utf8, isPtr: true
func ActionNameIsValid1(action_name string) (result bool) {
	iv, err := _I.Get(0, "Action", "name_is_valid")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_action_name := gi.CString(action_name)
	arg_action_name := gi.NewStringArgument(c_action_name)
	args := []gi.Argument{arg_action_name}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_action_name)
	result = ret.Bool()
	return
}

// g_action_parse_detailed_name
// container is not nil, container is Action
// is method
// arg0Type tag: utf8, isPtr: true
func ActionParseDetailedName1(detailed_name string) (result bool, action_name string, target_value glib.Variant, err error) {
	iv, err := _I.Get(1, "Action", "parse_detailed_name")
	if err != nil {
		return
	}
	var outArgs [3]gi.Argument
	c_detailed_name := gi.CString(detailed_name)
	arg_detailed_name := gi.NewStringArgument(c_detailed_name)
	arg_action_name := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	arg_target_value := gi.NewPointerArgument(unsafe.Pointer(&outArgs[1]))
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[2]))
	args := []gi.Argument{arg_detailed_name, arg_action_name, arg_target_value, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	gi.Free(c_detailed_name)
	err = gi.ToError(outArgs[2].Pointer())
	action_name = outArgs[0].String().Take()
	target_value.P = outArgs[1].Pointer()
	result = ret.Bool()
	return
}

// g_action_print_detailed_name
// container is not nil, container is Action
// is method
// arg0Type tag: utf8, isPtr: true
func ActionPrintDetailedName1(action_name string, target_value glib.Variant) (result string) {
	iv, err := _I.Get(2, "Action", "print_detailed_name")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_action_name := gi.CString(action_name)
	arg_action_name := gi.NewStringArgument(c_action_name)
	arg_target_value := gi.NewPointerArgument(target_value.P)
	args := []gi.Argument{arg_action_name, arg_target_value}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_action_name)
	result = ret.String().Take()
	return
}

// g_action_activate
// container is not nil, container is Action
// is method
func (v *ActionIfc) Activate(parameter glib.Variant) {
	iv, err := _I.Get(3, "Action", "activate")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_parameter := gi.NewPointerArgument(parameter.P)
	args := []gi.Argument{arg_v, arg_parameter}
	iv.Call(args, nil, nil)
}

// g_action_change_state
// container is not nil, container is Action
// is method
func (v *ActionIfc) ChangeState(value glib.Variant) {
	iv, err := _I.Get(4, "Action", "change_state")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_value := gi.NewPointerArgument(value.P)
	args := []gi.Argument{arg_v, arg_value}
	iv.Call(args, nil, nil)
}

// g_action_get_enabled
// container is not nil, container is Action
// is method
func (v *ActionIfc) GetEnabled() (result bool) {
	iv, err := _I.Get(5, "Action", "get_enabled")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_action_get_name
// container is not nil, container is Action
// is method
func (v *ActionIfc) GetName() (result string) {
	iv, err := _I.Get(6, "Action", "get_name")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Take()
	return
}

// g_action_get_parameter_type
// container is not nil, container is Action
// is method
func (v *ActionIfc) GetParameterType() (result glib.VariantType) {
	iv, err := _I.Get(7, "Action", "get_parameter_type")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_action_get_state
// container is not nil, container is Action
// is method
func (v *ActionIfc) GetState() (result glib.Variant) {
	iv, err := _I.Get(8, "Action", "get_state")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_action_get_state_hint
// container is not nil, container is Action
// is method
func (v *ActionIfc) GetStateHint() (result glib.Variant) {
	iv, err := _I.Get(9, "Action", "get_state_hint")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_action_get_state_type
// container is not nil, container is Action
// is method
func (v *ActionIfc) GetStateType() (result glib.VariantType) {
	iv, err := _I.Get(10, "Action", "get_state_type")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// Struct ActionEntry
type ActionEntry struct {
	P unsafe.Pointer
}

const SizeOfStructActionEntry = 64

func ActionEntryGetType() gi.GType {
	ret := _I.GetGType(1, "ActionEntry")
	return ret
}

// Interface ActionGroup
type ActionGroup struct {
	ActionGroupIfc
	P unsafe.Pointer
}
type ActionGroupIfc struct{}
type IActionGroup interface{ P_ActionGroup() unsafe.Pointer }

func (v ActionGroup) P_ActionGroup() unsafe.Pointer { return v.P }
func ActionGroupGetType() gi.GType {
	ret := _I.GetGType(2, "ActionGroup")
	return ret
}

// g_action_group_action_added
// container is not nil, container is ActionGroup
// is method
func (v *ActionGroupIfc) ActionAdded(action_name string) {
	iv, err := _I.Get(11, "ActionGroup", "action_added")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_action_name := gi.CString(action_name)
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_action_name := gi.NewStringArgument(c_action_name)
	args := []gi.Argument{arg_v, arg_action_name}
	iv.Call(args, nil, nil)
	gi.Free(c_action_name)
}

// g_action_group_action_enabled_changed
// container is not nil, container is ActionGroup
// is method
func (v *ActionGroupIfc) ActionEnabledChanged(action_name string, enabled bool) {
	iv, err := _I.Get(12, "ActionGroup", "action_enabled_changed")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_action_name := gi.CString(action_name)
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_action_name := gi.NewStringArgument(c_action_name)
	arg_enabled := gi.NewBoolArgument(enabled)
	args := []gi.Argument{arg_v, arg_action_name, arg_enabled}
	iv.Call(args, nil, nil)
	gi.Free(c_action_name)
}

// g_action_group_action_removed
// container is not nil, container is ActionGroup
// is method
func (v *ActionGroupIfc) ActionRemoved(action_name string) {
	iv, err := _I.Get(13, "ActionGroup", "action_removed")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_action_name := gi.CString(action_name)
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_action_name := gi.NewStringArgument(c_action_name)
	args := []gi.Argument{arg_v, arg_action_name}
	iv.Call(args, nil, nil)
	gi.Free(c_action_name)
}

// g_action_group_action_state_changed
// container is not nil, container is ActionGroup
// is method
func (v *ActionGroupIfc) ActionStateChanged(action_name string, state glib.Variant) {
	iv, err := _I.Get(14, "ActionGroup", "action_state_changed")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_action_name := gi.CString(action_name)
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_action_name := gi.NewStringArgument(c_action_name)
	arg_state := gi.NewPointerArgument(state.P)
	args := []gi.Argument{arg_v, arg_action_name, arg_state}
	iv.Call(args, nil, nil)
	gi.Free(c_action_name)
}

// g_action_group_activate_action
// container is not nil, container is ActionGroup
// is method
func (v *ActionGroupIfc) ActivateAction(action_name string, parameter glib.Variant) {
	iv, err := _I.Get(15, "ActionGroup", "activate_action")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_action_name := gi.CString(action_name)
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_action_name := gi.NewStringArgument(c_action_name)
	arg_parameter := gi.NewPointerArgument(parameter.P)
	args := []gi.Argument{arg_v, arg_action_name, arg_parameter}
	iv.Call(args, nil, nil)
	gi.Free(c_action_name)
}

// g_action_group_change_action_state
// container is not nil, container is ActionGroup
// is method
func (v *ActionGroupIfc) ChangeActionState(action_name string, value glib.Variant) {
	iv, err := _I.Get(16, "ActionGroup", "change_action_state")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_action_name := gi.CString(action_name)
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_action_name := gi.NewStringArgument(c_action_name)
	arg_value := gi.NewPointerArgument(value.P)
	args := []gi.Argument{arg_v, arg_action_name, arg_value}
	iv.Call(args, nil, nil)
	gi.Free(c_action_name)
}

// g_action_group_get_action_enabled
// container is not nil, container is ActionGroup
// is method
func (v *ActionGroupIfc) GetActionEnabled(action_name string) (result bool) {
	iv, err := _I.Get(17, "ActionGroup", "get_action_enabled")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_action_name := gi.CString(action_name)
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_action_name := gi.NewStringArgument(c_action_name)
	args := []gi.Argument{arg_v, arg_action_name}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_action_name)
	result = ret.Bool()
	return
}

// g_action_group_get_action_parameter_type
// container is not nil, container is ActionGroup
// is method
func (v *ActionGroupIfc) GetActionParameterType(action_name string) (result glib.VariantType) {
	iv, err := _I.Get(18, "ActionGroup", "get_action_parameter_type")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_action_name := gi.CString(action_name)
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_action_name := gi.NewStringArgument(c_action_name)
	args := []gi.Argument{arg_v, arg_action_name}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_action_name)
	result.P = ret.Pointer()
	return
}

// g_action_group_get_action_state
// container is not nil, container is ActionGroup
// is method
func (v *ActionGroupIfc) GetActionState(action_name string) (result glib.Variant) {
	iv, err := _I.Get(19, "ActionGroup", "get_action_state")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_action_name := gi.CString(action_name)
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_action_name := gi.NewStringArgument(c_action_name)
	args := []gi.Argument{arg_v, arg_action_name}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_action_name)
	result.P = ret.Pointer()
	return
}

// g_action_group_get_action_state_hint
// container is not nil, container is ActionGroup
// is method
func (v *ActionGroupIfc) GetActionStateHint(action_name string) (result glib.Variant) {
	iv, err := _I.Get(20, "ActionGroup", "get_action_state_hint")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_action_name := gi.CString(action_name)
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_action_name := gi.NewStringArgument(c_action_name)
	args := []gi.Argument{arg_v, arg_action_name}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_action_name)
	result.P = ret.Pointer()
	return
}

// g_action_group_get_action_state_type
// container is not nil, container is ActionGroup
// is method
func (v *ActionGroupIfc) GetActionStateType(action_name string) (result glib.VariantType) {
	iv, err := _I.Get(21, "ActionGroup", "get_action_state_type")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_action_name := gi.CString(action_name)
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_action_name := gi.NewStringArgument(c_action_name)
	args := []gi.Argument{arg_v, arg_action_name}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_action_name)
	result.P = ret.Pointer()
	return
}

// g_action_group_has_action
// container is not nil, container is ActionGroup
// is method
func (v *ActionGroupIfc) HasAction(action_name string) (result bool) {
	iv, err := _I.Get(22, "ActionGroup", "has_action")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_action_name := gi.CString(action_name)
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_action_name := gi.NewStringArgument(c_action_name)
	args := []gi.Argument{arg_v, arg_action_name}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_action_name)
	result = ret.Bool()
	return
}

// g_action_group_list_actions
// container is not nil, container is ActionGroup
// is method
func (v *ActionGroupIfc) ListActions() (result gi.CStrArray) {
	iv, err := _I.Get(23, "ActionGroup", "list_actions")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = gi.CStrArray{P: ret.Pointer(), Len: -1}
	result.SetLenZT()
	return
}

// g_action_group_query_action
// container is not nil, container is ActionGroup
// is method
func (v *ActionGroupIfc) QueryAction(action_name string) (result bool, enabled bool, parameter_type glib.VariantType, state_type glib.VariantType, state_hint glib.Variant, state glib.Variant) {
	iv, err := _I.Get(24, "ActionGroup", "query_action")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var outArgs [5]gi.Argument
	c_action_name := gi.CString(action_name)
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_action_name := gi.NewStringArgument(c_action_name)
	arg_enabled := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	arg_parameter_type := gi.NewPointerArgument(unsafe.Pointer(&outArgs[1]))
	arg_state_type := gi.NewPointerArgument(unsafe.Pointer(&outArgs[2]))
	arg_state_hint := gi.NewPointerArgument(unsafe.Pointer(&outArgs[3]))
	arg_state := gi.NewPointerArgument(unsafe.Pointer(&outArgs[4]))
	args := []gi.Argument{arg_v, arg_action_name, arg_enabled, arg_parameter_type, arg_state_type, arg_state_hint, arg_state}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	gi.Free(c_action_name)
	enabled = outArgs[0].Bool()
	parameter_type.P = outArgs[1].Pointer()
	state_type.P = outArgs[2].Pointer()
	state_hint.P = outArgs[3].Pointer()
	state.P = outArgs[4].Pointer()
	result = ret.Bool()
	return
}

// ignore GType struct ActionGroupInterface
// ignore GType struct ActionInterface
// Interface ActionMap
type ActionMap struct {
	ActionMapIfc
	P unsafe.Pointer
}
type ActionMapIfc struct{}
type IActionMap interface{ P_ActionMap() unsafe.Pointer }

func (v ActionMap) P_ActionMap() unsafe.Pointer { return v.P }
func ActionMapGetType() gi.GType {
	ret := _I.GetGType(3, "ActionMap")
	return ret
}

// g_action_map_add_action
// container is not nil, container is ActionMap
// is method
func (v *ActionMapIfc) AddAction(action IAction) {
	iv, err := _I.Get(25, "ActionMap", "add_action")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if action != nil {
		tmp = action.P_Action()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_action := gi.NewPointerArgument(tmp)
	args := []gi.Argument{arg_v, arg_action}
	iv.Call(args, nil, nil)
}

// g_action_map_add_action_entries
// container is not nil, container is ActionMap
// is method
// arg 0 entries lenArgIdx 1
func (v *ActionMapIfc) AddActionEntries(entries unsafe.Pointer, n_entries int32, user_data unsafe.Pointer) {
	iv, err := _I.Get(26, "ActionMap", "add_action_entries")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_entries := gi.NewPointerArgument(entries)
	arg_n_entries := gi.NewInt32Argument(n_entries)
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_v, arg_entries, arg_n_entries, arg_user_data}
	iv.Call(args, nil, nil)
}

// g_action_map_lookup_action
// container is not nil, container is ActionMap
// is method
func (v *ActionMapIfc) LookupAction(action_name string) (result Action) {
	iv, err := _I.Get(27, "ActionMap", "lookup_action")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_action_name := gi.CString(action_name)
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_action_name := gi.NewStringArgument(c_action_name)
	args := []gi.Argument{arg_v, arg_action_name}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_action_name)
	result.P = ret.Pointer()
	return
}

// g_action_map_remove_action
// container is not nil, container is ActionMap
// is method
func (v *ActionMapIfc) RemoveAction(action_name string) {
	iv, err := _I.Get(28, "ActionMap", "remove_action")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_action_name := gi.CString(action_name)
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_action_name := gi.NewStringArgument(c_action_name)
	args := []gi.Argument{arg_v, arg_action_name}
	iv.Call(args, nil, nil)
	gi.Free(c_action_name)
}

// ignore GType struct ActionMapInterface
// Interface AppInfo
type AppInfo struct {
	AppInfoIfc
	P unsafe.Pointer
}
type AppInfoIfc struct{}
type IAppInfo interface{ P_AppInfo() unsafe.Pointer }

func (v AppInfo) P_AppInfo() unsafe.Pointer { return v.P }
func AppInfoGetType() gi.GType {
	ret := _I.GetGType(4, "AppInfo")
	return ret
}

// g_app_info_create_from_commandline
// container is not nil, container is AppInfo
// is method
// arg0Type tag: filename, isPtr: true
func AppInfoCreateFromCommandline1(commandline string, application_name string, flags AppInfoCreateFlags) (result AppInfo, err error) {
	iv, err := _I.Get(29, "AppInfo", "create_from_commandline")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	c_commandline := gi.CString(commandline)
	c_application_name := gi.CString(application_name)
	arg_commandline := gi.NewStringArgument(c_commandline)
	arg_application_name := gi.NewStringArgument(c_application_name)
	arg_flags := gi.NewIntArgument(int(flags))
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_commandline, arg_application_name, arg_flags, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	gi.Free(c_commandline)
	gi.Free(c_application_name)
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// g_app_info_get_all_for_type
// container is not nil, container is AppInfo
// is method
// arg0Type tag: utf8, isPtr: true
func AppInfoGetAllForType1(content_type string) (result glib.List) {
	iv, err := _I.Get(31, "AppInfo", "get_all_for_type")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_content_type := gi.CString(content_type)
	arg_content_type := gi.NewStringArgument(c_content_type)
	args := []gi.Argument{arg_content_type}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_content_type)
	result.P = ret.Pointer()
	return
}

// g_app_info_get_default_for_type
// container is not nil, container is AppInfo
// is method
// arg0Type tag: utf8, isPtr: true
func AppInfoGetDefaultForType1(content_type string, must_support_uris bool) (result AppInfo) {
	iv, err := _I.Get(32, "AppInfo", "get_default_for_type")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_content_type := gi.CString(content_type)
	arg_content_type := gi.NewStringArgument(c_content_type)
	arg_must_support_uris := gi.NewBoolArgument(must_support_uris)
	args := []gi.Argument{arg_content_type, arg_must_support_uris}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_content_type)
	result.P = ret.Pointer()
	return
}

// g_app_info_get_default_for_uri_scheme
// container is not nil, container is AppInfo
// is method
// arg0Type tag: utf8, isPtr: true
func AppInfoGetDefaultForUriScheme1(uri_scheme string) (result AppInfo) {
	iv, err := _I.Get(33, "AppInfo", "get_default_for_uri_scheme")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_uri_scheme := gi.CString(uri_scheme)
	arg_uri_scheme := gi.NewStringArgument(c_uri_scheme)
	args := []gi.Argument{arg_uri_scheme}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_uri_scheme)
	result.P = ret.Pointer()
	return
}

// g_app_info_get_fallback_for_type
// container is not nil, container is AppInfo
// is method
// arg0Type tag: utf8, isPtr: true
func AppInfoGetFallbackForType1(content_type string) (result glib.List) {
	iv, err := _I.Get(34, "AppInfo", "get_fallback_for_type")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_content_type := gi.CString(content_type)
	arg_content_type := gi.NewStringArgument(c_content_type)
	args := []gi.Argument{arg_content_type}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_content_type)
	result.P = ret.Pointer()
	return
}

// g_app_info_get_recommended_for_type
// container is not nil, container is AppInfo
// is method
// arg0Type tag: utf8, isPtr: true
func AppInfoGetRecommendedForType1(content_type string) (result glib.List) {
	iv, err := _I.Get(35, "AppInfo", "get_recommended_for_type")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_content_type := gi.CString(content_type)
	arg_content_type := gi.NewStringArgument(c_content_type)
	args := []gi.Argument{arg_content_type}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_content_type)
	result.P = ret.Pointer()
	return
}

// g_app_info_launch_default_for_uri
// container is not nil, container is AppInfo
// is method
// arg0Type tag: utf8, isPtr: true
func AppInfoLaunchDefaultForUri1(uri string, context IAppLaunchContext) (result bool, err error) {
	iv, err := _I.Get(36, "AppInfo", "launch_default_for_uri")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	c_uri := gi.CString(uri)
	var tmp unsafe.Pointer
	if context != nil {
		tmp = context.P_AppLaunchContext()
	}
	arg_uri := gi.NewStringArgument(c_uri)
	arg_context := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_uri, arg_context, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	gi.Free(c_uri)
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Bool()
	return
}

// g_app_info_launch_default_for_uri_async
// container is not nil, container is AppInfo
// is method
// arg0Type tag: utf8, isPtr: true
func AppInfoLaunchDefaultForUriAsync1(uri string, context IAppLaunchContext, cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(37, "AppInfo", "launch_default_for_uri_async")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_uri := gi.CString(uri)
	var tmp unsafe.Pointer
	if context != nil {
		tmp = context.P_AppLaunchContext()
	}
	var tmp1 unsafe.Pointer
	if cancellable != nil {
		tmp1 = cancellable.P_Cancellable()
	}
	arg_uri := gi.NewStringArgument(c_uri)
	arg_context := gi.NewPointerArgument(tmp)
	arg_cancellable := gi.NewPointerArgument(tmp1)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_uri, arg_context, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
	gi.Free(c_uri)
}

// g_app_info_launch_default_for_uri_finish
// container is not nil, container is AppInfo
// is method
// arg0Type tag: interface, isPtr: true
func AppInfoLaunchDefaultForUriFinish1(result IAsyncResult) (result1 bool, err error) {
	iv, err := _I.Get(38, "AppInfo", "launch_default_for_uri_finish")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if result != nil {
		tmp = result.P_AsyncResult()
	}
	arg_result := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_result, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result1 = ret.Bool()
	return
}

// g_app_info_reset_type_associations
// container is not nil, container is AppInfo
// is method
// arg0Type tag: utf8, isPtr: true
func AppInfoResetTypeAssociations1(content_type string) {
	iv, err := _I.Get(39, "AppInfo", "reset_type_associations")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_content_type := gi.CString(content_type)
	arg_content_type := gi.NewStringArgument(c_content_type)
	args := []gi.Argument{arg_content_type}
	iv.Call(args, nil, nil)
	gi.Free(c_content_type)
}

// g_app_info_add_supports_type
// container is not nil, container is AppInfo
// is method
func (v *AppInfoIfc) AddSupportsType(content_type string) (result bool, err error) {
	iv, err := _I.Get(40, "AppInfo", "add_supports_type")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	c_content_type := gi.CString(content_type)
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_content_type := gi.NewStringArgument(c_content_type)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_content_type, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	gi.Free(c_content_type)
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Bool()
	return
}

// g_app_info_can_delete
// container is not nil, container is AppInfo
// is method
func (v *AppInfoIfc) CanDelete() (result bool) {
	iv, err := _I.Get(41, "AppInfo", "can_delete")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_app_info_can_remove_supports_type
// container is not nil, container is AppInfo
// is method
func (v *AppInfoIfc) CanRemoveSupportsType() (result bool) {
	iv, err := _I.Get(42, "AppInfo", "can_remove_supports_type")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_app_info_delete
// container is not nil, container is AppInfo
// is method
func (v *AppInfoIfc) Delete() (result bool) {
	iv, err := _I.Get(43, "AppInfo", "delete")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_app_info_dup
// container is not nil, container is AppInfo
// is method
func (v *AppInfoIfc) Dup() (result AppInfo) {
	iv, err := _I.Get(44, "AppInfo", "dup")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_app_info_equal
// container is not nil, container is AppInfo
// is method
func (v *AppInfoIfc) Equal(appinfo2 IAppInfo) (result bool) {
	iv, err := _I.Get(45, "AppInfo", "equal")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if appinfo2 != nil {
		tmp = appinfo2.P_AppInfo()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_appinfo2 := gi.NewPointerArgument(tmp)
	args := []gi.Argument{arg_v, arg_appinfo2}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_app_info_get_commandline
// container is not nil, container is AppInfo
// is method
func (v *AppInfoIfc) GetCommandline() (result string) {
	iv, err := _I.Get(46, "AppInfo", "get_commandline")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Take()
	return
}

// g_app_info_get_description
// container is not nil, container is AppInfo
// is method
func (v *AppInfoIfc) GetDescription() (result string) {
	iv, err := _I.Get(47, "AppInfo", "get_description")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Take()
	return
}

// g_app_info_get_display_name
// container is not nil, container is AppInfo
// is method
func (v *AppInfoIfc) GetDisplayName() (result string) {
	iv, err := _I.Get(48, "AppInfo", "get_display_name")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Take()
	return
}

// g_app_info_get_executable
// container is not nil, container is AppInfo
// is method
func (v *AppInfoIfc) GetExecutable() (result string) {
	iv, err := _I.Get(49, "AppInfo", "get_executable")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Take()
	return
}

// g_app_info_get_icon
// container is not nil, container is AppInfo
// is method
func (v *AppInfoIfc) GetIcon() (result Icon) {
	iv, err := _I.Get(50, "AppInfo", "get_icon")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_app_info_get_id
// container is not nil, container is AppInfo
// is method
func (v *AppInfoIfc) GetId() (result string) {
	iv, err := _I.Get(51, "AppInfo", "get_id")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Take()
	return
}

// g_app_info_get_name
// container is not nil, container is AppInfo
// is method
func (v *AppInfoIfc) GetName() (result string) {
	iv, err := _I.Get(52, "AppInfo", "get_name")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Take()
	return
}

// g_app_info_get_supported_types
// container is not nil, container is AppInfo
// is method
func (v *AppInfoIfc) GetSupportedTypes() (result gi.CStrArray) {
	iv, err := _I.Get(53, "AppInfo", "get_supported_types")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = gi.CStrArray{P: ret.Pointer(), Len: -1}
	result.SetLenZT()
	return
}

// g_app_info_launch
// container is not nil, container is AppInfo
// is method
func (v *AppInfoIfc) Launch(files glib.List, context IAppLaunchContext) (result bool, err error) {
	iv, err := _I.Get(54, "AppInfo", "launch")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if context != nil {
		tmp = context.P_AppLaunchContext()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_files := gi.NewPointerArgument(files.P)
	arg_context := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_files, arg_context, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Bool()
	return
}

// g_app_info_launch_uris
// container is not nil, container is AppInfo
// is method
func (v *AppInfoIfc) LaunchUris(uris glib.List, context IAppLaunchContext) (result bool, err error) {
	iv, err := _I.Get(55, "AppInfo", "launch_uris")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if context != nil {
		tmp = context.P_AppLaunchContext()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_uris := gi.NewPointerArgument(uris.P)
	arg_context := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_uris, arg_context, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Bool()
	return
}

// g_app_info_remove_supports_type
// container is not nil, container is AppInfo
// is method
func (v *AppInfoIfc) RemoveSupportsType(content_type string) (result bool, err error) {
	iv, err := _I.Get(56, "AppInfo", "remove_supports_type")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	c_content_type := gi.CString(content_type)
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_content_type := gi.NewStringArgument(c_content_type)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_content_type, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	gi.Free(c_content_type)
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Bool()
	return
}

// g_app_info_set_as_default_for_extension
// container is not nil, container is AppInfo
// is method
func (v *AppInfoIfc) SetAsDefaultForExtension(extension string) (result bool, err error) {
	iv, err := _I.Get(57, "AppInfo", "set_as_default_for_extension")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	c_extension := gi.CString(extension)
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_extension := gi.NewStringArgument(c_extension)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_extension, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	gi.Free(c_extension)
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Bool()
	return
}

// g_app_info_set_as_default_for_type
// container is not nil, container is AppInfo
// is method
func (v *AppInfoIfc) SetAsDefaultForType(content_type string) (result bool, err error) {
	iv, err := _I.Get(58, "AppInfo", "set_as_default_for_type")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	c_content_type := gi.CString(content_type)
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_content_type := gi.NewStringArgument(c_content_type)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_content_type, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	gi.Free(c_content_type)
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Bool()
	return
}

// g_app_info_set_as_last_used_for_type
// container is not nil, container is AppInfo
// is method
func (v *AppInfoIfc) SetAsLastUsedForType(content_type string) (result bool, err error) {
	iv, err := _I.Get(59, "AppInfo", "set_as_last_used_for_type")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	c_content_type := gi.CString(content_type)
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_content_type := gi.NewStringArgument(c_content_type)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_content_type, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	gi.Free(c_content_type)
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Bool()
	return
}

// g_app_info_should_show
// container is not nil, container is AppInfo
// is method
func (v *AppInfoIfc) ShouldShow() (result bool) {
	iv, err := _I.Get(60, "AppInfo", "should_show")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_app_info_supports_files
// container is not nil, container is AppInfo
// is method
func (v *AppInfoIfc) SupportsFiles() (result bool) {
	iv, err := _I.Get(61, "AppInfo", "supports_files")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_app_info_supports_uris
// container is not nil, container is AppInfo
// is method
func (v *AppInfoIfc) SupportsUris() (result bool) {
	iv, err := _I.Get(62, "AppInfo", "supports_uris")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// Flags AppInfoCreateFlags
type AppInfoCreateFlags int

const (
	AppInfoCreateFlagsNone                        AppInfoCreateFlags = 0
	AppInfoCreateFlagsNeedsTerminal               AppInfoCreateFlags = 1
	AppInfoCreateFlagsSupportsUris                AppInfoCreateFlags = 2
	AppInfoCreateFlagsSupportsStartupNotification AppInfoCreateFlags = 4
)

func AppInfoCreateFlagsGetType() gi.GType {
	ret := _I.GetGType(5, "AppInfoCreateFlags")
	return ret
}

// ignore GType struct AppInfoIface
// Object AppInfoMonitor
type AppInfoMonitor struct {
	gobject.Object
}

func WrapAppInfoMonitor(p unsafe.Pointer) (r AppInfoMonitor) { r.P = p; return }

type IAppInfoMonitor interface{ P_AppInfoMonitor() unsafe.Pointer }

func (v AppInfoMonitor) P_AppInfoMonitor() unsafe.Pointer { return v.P }
func AppInfoMonitorGetType() gi.GType {
	ret := _I.GetGType(6, "AppInfoMonitor")
	return ret
}

// Object AppLaunchContext
type AppLaunchContext struct {
	gobject.Object
}

func WrapAppLaunchContext(p unsafe.Pointer) (r AppLaunchContext) { r.P = p; return }

type IAppLaunchContext interface{ P_AppLaunchContext() unsafe.Pointer }

func (v AppLaunchContext) P_AppLaunchContext() unsafe.Pointer { return v.P }
func AppLaunchContextGetType() gi.GType {
	ret := _I.GetGType(7, "AppLaunchContext")
	return ret
}

// g_app_launch_context_new
// container is not nil, container is AppLaunchContext
// is constructor
func NewAppLaunchContext() (result AppLaunchContext) {
	iv, err := _I.Get(64, "AppLaunchContext", "new")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var ret gi.Argument
	iv.Call(nil, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_app_launch_context_get_display
// container is not nil, container is AppLaunchContext
// is method
func (v AppLaunchContext) GetDisplay(info IAppInfo, files glib.List) (result string) {
	iv, err := _I.Get(65, "AppLaunchContext", "get_display")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if info != nil {
		tmp = info.P_AppInfo()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_info := gi.NewPointerArgument(tmp)
	arg_files := gi.NewPointerArgument(files.P)
	args := []gi.Argument{arg_v, arg_info, arg_files}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Take()
	return
}

// g_app_launch_context_get_environment
// container is not nil, container is AppLaunchContext
// is method
func (v AppLaunchContext) GetEnvironment() (result gi.CStrArray) {
	iv, err := _I.Get(66, "AppLaunchContext", "get_environment")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = gi.CStrArray{P: ret.Pointer(), Len: -1}
	result.SetLenZT()
	return
}

// g_app_launch_context_get_startup_notify_id
// container is not nil, container is AppLaunchContext
// is method
func (v AppLaunchContext) GetStartupNotifyId(info IAppInfo, files glib.List) (result string) {
	iv, err := _I.Get(67, "AppLaunchContext", "get_startup_notify_id")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if info != nil {
		tmp = info.P_AppInfo()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_info := gi.NewPointerArgument(tmp)
	arg_files := gi.NewPointerArgument(files.P)
	args := []gi.Argument{arg_v, arg_info, arg_files}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Take()
	return
}

// g_app_launch_context_launch_failed
// container is not nil, container is AppLaunchContext
// is method
func (v AppLaunchContext) LaunchFailed(startup_notify_id string) {
	iv, err := _I.Get(68, "AppLaunchContext", "launch_failed")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_startup_notify_id := gi.CString(startup_notify_id)
	arg_v := gi.NewPointerArgument(v.P)
	arg_startup_notify_id := gi.NewStringArgument(c_startup_notify_id)
	args := []gi.Argument{arg_v, arg_startup_notify_id}
	iv.Call(args, nil, nil)
	gi.Free(c_startup_notify_id)
}

// g_app_launch_context_setenv
// container is not nil, container is AppLaunchContext
// is method
func (v AppLaunchContext) Setenv(variable string, value string) {
	iv, err := _I.Get(69, "AppLaunchContext", "setenv")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_variable := gi.CString(variable)
	c_value := gi.CString(value)
	arg_v := gi.NewPointerArgument(v.P)
	arg_variable := gi.NewStringArgument(c_variable)
	arg_value := gi.NewStringArgument(c_value)
	args := []gi.Argument{arg_v, arg_variable, arg_value}
	iv.Call(args, nil, nil)
	gi.Free(c_variable)
	gi.Free(c_value)
}

// g_app_launch_context_unsetenv
// container is not nil, container is AppLaunchContext
// is method
func (v AppLaunchContext) Unsetenv(variable string) {
	iv, err := _I.Get(70, "AppLaunchContext", "unsetenv")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_variable := gi.CString(variable)
	arg_v := gi.NewPointerArgument(v.P)
	arg_variable := gi.NewStringArgument(c_variable)
	args := []gi.Argument{arg_v, arg_variable}
	iv.Call(args, nil, nil)
	gi.Free(c_variable)
}

// ignore GType struct AppLaunchContextClass
// Struct AppLaunchContextPrivate
type AppLaunchContextPrivate struct {
	P unsafe.Pointer
}

func AppLaunchContextPrivateGetType() gi.GType {
	ret := _I.GetGType(8, "AppLaunchContextPrivate")
	return ret
}

// Object Application
type Application struct {
	ActionGroupIfc
	ActionMapIfc
	gobject.Object
}

func WrapApplication(p unsafe.Pointer) (r Application) { r.P = p; return }

type IApplication interface{ P_Application() unsafe.Pointer }

func (v Application) P_Application() unsafe.Pointer { return v.P }
func (v Application) P_ActionGroup() unsafe.Pointer { return v.P }
func (v Application) P_ActionMap() unsafe.Pointer   { return v.P }
func ApplicationGetType() gi.GType {
	ret := _I.GetGType(9, "Application")
	return ret
}

// g_application_new
// container is not nil, container is Application
// is constructor
func NewApplication(application_id string, flags ApplicationFlags) (result Application) {
	iv, err := _I.Get(71, "Application", "new")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_application_id := gi.CString(application_id)
	arg_application_id := gi.NewStringArgument(c_application_id)
	arg_flags := gi.NewIntArgument(int(flags))
	args := []gi.Argument{arg_application_id, arg_flags}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_application_id)
	result.P = ret.Pointer()
	return
}

// g_application_id_is_valid
// container is not nil, container is Application
// is method
// arg0Type tag: utf8, isPtr: true
func ApplicationIdIsValid1(application_id string) (result bool) {
	iv, err := _I.Get(73, "Application", "id_is_valid")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_application_id := gi.CString(application_id)
	arg_application_id := gi.NewStringArgument(c_application_id)
	args := []gi.Argument{arg_application_id}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_application_id)
	result = ret.Bool()
	return
}

// g_application_activate
// container is not nil, container is Application
// is method
func (v Application) Activate() {
	iv, err := _I.Get(74, "Application", "activate")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	iv.Call(args, nil, nil)
}

// g_application_add_main_option
// container is not nil, container is Application
// is method
func (v Application) AddMainOption(long_name string, short_name int8, flags glib.OptionFlags, arg glib.OptionArgEnum, description string, arg_description string) {
	iv, err := _I.Get(75, "Application", "add_main_option")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_long_name := gi.CString(long_name)
	c_description := gi.CString(description)
	c_arg_description := gi.CString(arg_description)
	arg_v := gi.NewPointerArgument(v.P)
	arg_long_name := gi.NewStringArgument(c_long_name)
	arg_short_name := gi.NewInt8Argument(short_name)
	arg_flags := gi.NewIntArgument(int(flags))
	arg_arg := gi.NewIntArgument(int(arg))
	arg_description1 := gi.NewStringArgument(c_description)
	arg_arg_description := gi.NewStringArgument(c_arg_description)
	args := []gi.Argument{arg_v, arg_long_name, arg_short_name, arg_flags, arg_arg, arg_description1, arg_arg_description}
	iv.Call(args, nil, nil)
	gi.Free(c_long_name)
	gi.Free(c_description)
	gi.Free(c_arg_description)
}

// g_application_add_main_option_entries
// container is not nil, container is Application
// is method
func (v Application) AddMainOptionEntries(entries unsafe.Pointer) {
	iv, err := _I.Get(76, "Application", "add_main_option_entries")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_entries := gi.NewPointerArgument(entries)
	args := []gi.Argument{arg_v, arg_entries}
	iv.Call(args, nil, nil)
}

// g_application_add_option_group
// container is not nil, container is Application
// is method
func (v Application) AddOptionGroup(group glib.OptionGroup) {
	iv, err := _I.Get(77, "Application", "add_option_group")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_group := gi.NewPointerArgument(group.P)
	args := []gi.Argument{arg_v, arg_group}
	iv.Call(args, nil, nil)
}

// g_application_bind_busy_property
// container is not nil, container is Application
// is method
func (v Application) BindBusyProperty(object gobject.IObject, property string) {
	iv, err := _I.Get(78, "Application", "bind_busy_property")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if object != nil {
		tmp = object.P_Object()
	}
	c_property := gi.CString(property)
	arg_v := gi.NewPointerArgument(v.P)
	arg_object := gi.NewPointerArgument(tmp)
	arg_property := gi.NewStringArgument(c_property)
	args := []gi.Argument{arg_v, arg_object, arg_property}
	iv.Call(args, nil, nil)
	gi.Free(c_property)
}

// g_application_get_application_id
// container is not nil, container is Application
// is method
func (v Application) GetApplicationId() (result string) {
	iv, err := _I.Get(79, "Application", "get_application_id")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Take()
	return
}

// g_application_get_dbus_connection
// container is not nil, container is Application
// is method
func (v Application) GetDbusConnection() (result DBusConnection) {
	iv, err := _I.Get(80, "Application", "get_dbus_connection")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_application_get_dbus_object_path
// container is not nil, container is Application
// is method
func (v Application) GetDbusObjectPath() (result string) {
	iv, err := _I.Get(81, "Application", "get_dbus_object_path")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Take()
	return
}

// g_application_get_flags
// container is not nil, container is Application
// is method
func (v Application) GetFlags() (result ApplicationFlags) {
	iv, err := _I.Get(82, "Application", "get_flags")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ApplicationFlags(ret.Int())
	return
}

// g_application_get_inactivity_timeout
// container is not nil, container is Application
// is method
func (v Application) GetInactivityTimeout() (result uint32) {
	iv, err := _I.Get(83, "Application", "get_inactivity_timeout")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Uint32()
	return
}

// g_application_get_is_busy
// container is not nil, container is Application
// is method
func (v Application) GetIsBusy() (result bool) {
	iv, err := _I.Get(84, "Application", "get_is_busy")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_application_get_is_registered
// container is not nil, container is Application
// is method
func (v Application) GetIsRegistered() (result bool) {
	iv, err := _I.Get(85, "Application", "get_is_registered")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_application_get_is_remote
// container is not nil, container is Application
// is method
func (v Application) GetIsRemote() (result bool) {
	iv, err := _I.Get(86, "Application", "get_is_remote")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_application_get_resource_base_path
// container is not nil, container is Application
// is method
func (v Application) GetResourceBasePath() (result string) {
	iv, err := _I.Get(87, "Application", "get_resource_base_path")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Take()
	return
}

// g_application_hold
// container is not nil, container is Application
// is method
func (v Application) Hold() {
	iv, err := _I.Get(88, "Application", "hold")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	iv.Call(args, nil, nil)
}

// g_application_mark_busy
// container is not nil, container is Application
// is method
func (v Application) MarkBusy() {
	iv, err := _I.Get(89, "Application", "mark_busy")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	iv.Call(args, nil, nil)
}

// g_application_open
// container is not nil, container is Application
// is method
// arg 0 files lenArgIdx 1
func (v Application) Open(files gi.PointerArray, n_files int32, hint string) {
	iv, err := _I.Get(90, "Application", "open")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_hint := gi.CString(hint)
	arg_v := gi.NewPointerArgument(v.P)
	arg_files := gi.NewPointerArgument(files.P)
	arg_n_files := gi.NewInt32Argument(n_files)
	arg_hint := gi.NewStringArgument(c_hint)
	args := []gi.Argument{arg_v, arg_files, arg_n_files, arg_hint}
	iv.Call(args, nil, nil)
	gi.Free(c_hint)
}

// g_application_quit
// container is not nil, container is Application
// is method
func (v Application) Quit() {
	iv, err := _I.Get(91, "Application", "quit")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	iv.Call(args, nil, nil)
}

// g_application_register
// container is not nil, container is Application
// is method
func (v Application) Register(cancellable ICancellable) (result bool, err error) {
	iv, err := _I.Get(92, "Application", "register")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Bool()
	return
}

// g_application_release
// container is not nil, container is Application
// is method
func (v Application) Release() {
	iv, err := _I.Get(93, "Application", "release")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	iv.Call(args, nil, nil)
}

// g_application_run
// container is not nil, container is Application
// is method
// arg 1 argv lenArgIdx 0
func (v Application) Run(argc int32, argv gi.CStrArray) (result int32) {
	iv, err := _I.Get(94, "Application", "run")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_argc := gi.NewInt32Argument(argc)
	arg_argv := gi.NewPointerArgument(argv.P)
	args := []gi.Argument{arg_v, arg_argc, arg_argv}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Int32()
	return
}

// g_application_send_notification
// container is not nil, container is Application
// is method
func (v Application) SendNotification(id string, notification INotification) {
	iv, err := _I.Get(95, "Application", "send_notification")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_id := gi.CString(id)
	var tmp unsafe.Pointer
	if notification != nil {
		tmp = notification.P_Notification()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_id := gi.NewStringArgument(c_id)
	arg_notification := gi.NewPointerArgument(tmp)
	args := []gi.Argument{arg_v, arg_id, arg_notification}
	iv.Call(args, nil, nil)
	gi.Free(c_id)
}

// g_application_set_action_group
// container is not nil, container is Application
// is method
func (v Application) SetActionGroup(action_group IActionGroup) {
	iv, err := _I.Get(96, "Application", "set_action_group")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if action_group != nil {
		tmp = action_group.P_ActionGroup()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_action_group := gi.NewPointerArgument(tmp)
	args := []gi.Argument{arg_v, arg_action_group}
	iv.Call(args, nil, nil)
}

// g_application_set_application_id
// container is not nil, container is Application
// is method
func (v Application) SetApplicationId(application_id string) {
	iv, err := _I.Get(97, "Application", "set_application_id")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_application_id := gi.CString(application_id)
	arg_v := gi.NewPointerArgument(v.P)
	arg_application_id := gi.NewStringArgument(c_application_id)
	args := []gi.Argument{arg_v, arg_application_id}
	iv.Call(args, nil, nil)
	gi.Free(c_application_id)
}

// g_application_set_default
// container is not nil, container is Application
// is method
func (v Application) SetDefault() {
	iv, err := _I.Get(98, "Application", "set_default")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	iv.Call(args, nil, nil)
}

// g_application_set_flags
// container is not nil, container is Application
// is method
func (v Application) SetFlags(flags ApplicationFlags) {
	iv, err := _I.Get(99, "Application", "set_flags")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_flags := gi.NewIntArgument(int(flags))
	args := []gi.Argument{arg_v, arg_flags}
	iv.Call(args, nil, nil)
}

// g_application_set_inactivity_timeout
// container is not nil, container is Application
// is method
func (v Application) SetInactivityTimeout(inactivity_timeout uint32) {
	iv, err := _I.Get(100, "Application", "set_inactivity_timeout")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_inactivity_timeout := gi.NewUint32Argument(inactivity_timeout)
	args := []gi.Argument{arg_v, arg_inactivity_timeout}
	iv.Call(args, nil, nil)
}

// g_application_set_option_context_description
// container is not nil, container is Application
// is method
func (v Application) SetOptionContextDescription(description string) {
	iv, err := _I.Get(101, "Application", "set_option_context_description")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_description := gi.CString(description)
	arg_v := gi.NewPointerArgument(v.P)
	arg_description := gi.NewStringArgument(c_description)
	args := []gi.Argument{arg_v, arg_description}
	iv.Call(args, nil, nil)
	gi.Free(c_description)
}

// g_application_set_option_context_parameter_string
// container is not nil, container is Application
// is method
func (v Application) SetOptionContextParameterString(parameter_string string) {
	iv, err := _I.Get(102, "Application", "set_option_context_parameter_string")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_parameter_string := gi.CString(parameter_string)
	arg_v := gi.NewPointerArgument(v.P)
	arg_parameter_string := gi.NewStringArgument(c_parameter_string)
	args := []gi.Argument{arg_v, arg_parameter_string}
	iv.Call(args, nil, nil)
	gi.Free(c_parameter_string)
}

// g_application_set_option_context_summary
// container is not nil, container is Application
// is method
func (v Application) SetOptionContextSummary(summary string) {
	iv, err := _I.Get(103, "Application", "set_option_context_summary")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_summary := gi.CString(summary)
	arg_v := gi.NewPointerArgument(v.P)
	arg_summary := gi.NewStringArgument(c_summary)
	args := []gi.Argument{arg_v, arg_summary}
	iv.Call(args, nil, nil)
	gi.Free(c_summary)
}

// g_application_set_resource_base_path
// container is not nil, container is Application
// is method
func (v Application) SetResourceBasePath(resource_path string) {
	iv, err := _I.Get(104, "Application", "set_resource_base_path")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_resource_path := gi.CString(resource_path)
	arg_v := gi.NewPointerArgument(v.P)
	arg_resource_path := gi.NewStringArgument(c_resource_path)
	args := []gi.Argument{arg_v, arg_resource_path}
	iv.Call(args, nil, nil)
	gi.Free(c_resource_path)
}

// g_application_unbind_busy_property
// container is not nil, container is Application
// is method
func (v Application) UnbindBusyProperty(object gobject.IObject, property string) {
	iv, err := _I.Get(105, "Application", "unbind_busy_property")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if object != nil {
		tmp = object.P_Object()
	}
	c_property := gi.CString(property)
	arg_v := gi.NewPointerArgument(v.P)
	arg_object := gi.NewPointerArgument(tmp)
	arg_property := gi.NewStringArgument(c_property)
	args := []gi.Argument{arg_v, arg_object, arg_property}
	iv.Call(args, nil, nil)
	gi.Free(c_property)
}

// g_application_unmark_busy
// container is not nil, container is Application
// is method
func (v Application) UnmarkBusy() {
	iv, err := _I.Get(106, "Application", "unmark_busy")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	iv.Call(args, nil, nil)
}

// g_application_withdraw_notification
// container is not nil, container is Application
// is method
func (v Application) WithdrawNotification(id string) {
	iv, err := _I.Get(107, "Application", "withdraw_notification")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_id := gi.CString(id)
	arg_v := gi.NewPointerArgument(v.P)
	arg_id := gi.NewStringArgument(c_id)
	args := []gi.Argument{arg_v, arg_id}
	iv.Call(args, nil, nil)
	gi.Free(c_id)
}

// ignore GType struct ApplicationClass
// Object ApplicationCommandLine
type ApplicationCommandLine struct {
	gobject.Object
}

func WrapApplicationCommandLine(p unsafe.Pointer) (r ApplicationCommandLine) { r.P = p; return }

type IApplicationCommandLine interface{ P_ApplicationCommandLine() unsafe.Pointer }

func (v ApplicationCommandLine) P_ApplicationCommandLine() unsafe.Pointer { return v.P }
func ApplicationCommandLineGetType() gi.GType {
	ret := _I.GetGType(10, "ApplicationCommandLine")
	return ret
}

// g_application_command_line_create_file_for_arg
// container is not nil, container is ApplicationCommandLine
// is method
func (v ApplicationCommandLine) CreateFileForArg(arg string) (result File) {
	iv, err := _I.Get(108, "ApplicationCommandLine", "create_file_for_arg")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_arg := gi.CString(arg)
	arg_v := gi.NewPointerArgument(v.P)
	arg_arg := gi.NewStringArgument(c_arg)
	args := []gi.Argument{arg_v, arg_arg}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_arg)
	result.P = ret.Pointer()
	return
}

// g_application_command_line_get_arguments
// container is not nil, container is ApplicationCommandLine
// is method
// ret lenArgIdx 0
func (v ApplicationCommandLine) GetArguments() (result gi.CStrArray) {
	iv, err := _I.Get(109, "ApplicationCommandLine", "get_arguments")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var outArgs [1]gi.Argument
	arg_v := gi.NewPointerArgument(v.P)
	arg_argc := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_argc}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	var argc int32
	_ = argc
	argc = outArgs[0].Int32()
	result = gi.CStrArray{P: ret.Pointer(), Len: int(argc)}
	return
}

// g_application_command_line_get_cwd
// container is not nil, container is ApplicationCommandLine
// is method
func (v ApplicationCommandLine) GetCwd() (result string) {
	iv, err := _I.Get(110, "ApplicationCommandLine", "get_cwd")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Take()
	return
}

// g_application_command_line_get_environ
// container is not nil, container is ApplicationCommandLine
// is method
func (v ApplicationCommandLine) GetEnviron() (result gi.CStrArray) {
	iv, err := _I.Get(111, "ApplicationCommandLine", "get_environ")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = gi.CStrArray{P: ret.Pointer(), Len: -1}
	result.SetLenZT()
	return
}

// g_application_command_line_get_exit_status
// container is not nil, container is ApplicationCommandLine
// is method
func (v ApplicationCommandLine) GetExitStatus() (result int32) {
	iv, err := _I.Get(112, "ApplicationCommandLine", "get_exit_status")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Int32()
	return
}

// g_application_command_line_get_is_remote
// container is not nil, container is ApplicationCommandLine
// is method
func (v ApplicationCommandLine) GetIsRemote() (result bool) {
	iv, err := _I.Get(113, "ApplicationCommandLine", "get_is_remote")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_application_command_line_get_options_dict
// container is not nil, container is ApplicationCommandLine
// is method
func (v ApplicationCommandLine) GetOptionsDict() (result glib.VariantDict) {
	iv, err := _I.Get(114, "ApplicationCommandLine", "get_options_dict")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_application_command_line_get_platform_data
// container is not nil, container is ApplicationCommandLine
// is method
func (v ApplicationCommandLine) GetPlatformData() (result glib.Variant) {
	iv, err := _I.Get(115, "ApplicationCommandLine", "get_platform_data")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_application_command_line_get_stdin
// container is not nil, container is ApplicationCommandLine
// is method
func (v ApplicationCommandLine) GetStdin() (result InputStream) {
	iv, err := _I.Get(116, "ApplicationCommandLine", "get_stdin")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_application_command_line_getenv
// container is not nil, container is ApplicationCommandLine
// is method
func (v ApplicationCommandLine) Getenv(name string) (result string) {
	iv, err := _I.Get(117, "ApplicationCommandLine", "getenv")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_name := gi.CString(name)
	arg_v := gi.NewPointerArgument(v.P)
	arg_name := gi.NewStringArgument(c_name)
	args := []gi.Argument{arg_v, arg_name}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_name)
	result = ret.String().Take()
	return
}

// g_application_command_line_set_exit_status
// container is not nil, container is ApplicationCommandLine
// is method
func (v ApplicationCommandLine) SetExitStatus(exit_status int32) {
	iv, err := _I.Get(118, "ApplicationCommandLine", "set_exit_status")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_exit_status := gi.NewInt32Argument(exit_status)
	args := []gi.Argument{arg_v, arg_exit_status}
	iv.Call(args, nil, nil)
}

// ignore GType struct ApplicationCommandLineClass
// Struct ApplicationCommandLinePrivate
type ApplicationCommandLinePrivate struct {
	P unsafe.Pointer
}

func ApplicationCommandLinePrivateGetType() gi.GType {
	ret := _I.GetGType(11, "ApplicationCommandLinePrivate")
	return ret
}

// Flags ApplicationFlags
type ApplicationFlags int

const (
	ApplicationFlagsFlagsNone          ApplicationFlags = 0
	ApplicationFlagsIsService          ApplicationFlags = 1
	ApplicationFlagsIsLauncher         ApplicationFlags = 2
	ApplicationFlagsHandlesOpen        ApplicationFlags = 4
	ApplicationFlagsHandlesCommandLine ApplicationFlags = 8
	ApplicationFlagsSendEnvironment    ApplicationFlags = 16
	ApplicationFlagsNonUnique          ApplicationFlags = 32
	ApplicationFlagsCanOverrideAppId   ApplicationFlags = 64
)

func ApplicationFlagsGetType() gi.GType {
	ret := _I.GetGType(12, "ApplicationFlags")
	return ret
}

// Struct ApplicationPrivate
type ApplicationPrivate struct {
	P unsafe.Pointer
}

func ApplicationPrivateGetType() gi.GType {
	ret := _I.GetGType(13, "ApplicationPrivate")
	return ret
}

// Flags AskPasswordFlags
type AskPasswordFlags int

const (
	AskPasswordFlagsNeedPassword       AskPasswordFlags = 1
	AskPasswordFlagsNeedUsername       AskPasswordFlags = 2
	AskPasswordFlagsNeedDomain         AskPasswordFlags = 4
	AskPasswordFlagsSavingSupported    AskPasswordFlags = 8
	AskPasswordFlagsAnonymousSupported AskPasswordFlags = 16
	AskPasswordFlagsTcrypt             AskPasswordFlags = 32
)

func AskPasswordFlagsGetType() gi.GType {
	ret := _I.GetGType(14, "AskPasswordFlags")
	return ret
}

// Interface AsyncInitable
type AsyncInitable struct {
	AsyncInitableIfc
	P unsafe.Pointer
}
type AsyncInitableIfc struct{}
type IAsyncInitable interface{ P_AsyncInitable() unsafe.Pointer }

func (v AsyncInitable) P_AsyncInitable() unsafe.Pointer { return v.P }
func AsyncInitableGetType() gi.GType {
	ret := _I.GetGType(15, "AsyncInitable")
	return ret
}

// g_async_initable_newv_async
// container is not nil, container is AsyncInitable
// is method
// arg0Type tag: GType, isPtr: false
func AsyncInitableNewvAsync1(object_type gi.GType, n_parameters uint32, parameters gobject.Parameter, io_priority int32, cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(119, "AsyncInitable", "newv_async")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_object_type := gi.NewUintArgument(uint(object_type))
	arg_n_parameters := gi.NewUint32Argument(n_parameters)
	arg_parameters := gi.NewPointerArgument(parameters.P)
	arg_io_priority := gi.NewInt32Argument(io_priority)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_object_type, arg_n_parameters, arg_parameters, arg_io_priority, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
}

// g_async_initable_init_async
// container is not nil, container is AsyncInitable
// is method
func (v *AsyncInitableIfc) InitAsync(io_priority int32, cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(120, "AsyncInitable", "init_async")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_io_priority := gi.NewInt32Argument(io_priority)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_v, arg_io_priority, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
}

// g_async_initable_init_finish
// container is not nil, container is AsyncInitable
// is method
func (v *AsyncInitableIfc) InitFinish(res IAsyncResult) (result bool, err error) {
	iv, err := _I.Get(121, "AsyncInitable", "init_finish")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if res != nil {
		tmp = res.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_res := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_res, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Bool()
	return
}

// g_async_initable_new_finish
// container is not nil, container is AsyncInitable
// is method
func (v *AsyncInitableIfc) NewFinish(res IAsyncResult) (result gobject.Object, err error) {
	iv, err := _I.Get(122, "AsyncInitable", "new_finish")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if res != nil {
		tmp = res.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_res := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_res, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// ignore GType struct AsyncInitableIface
type AsyncReadyCallbackStruct struct {
	F_source_object gobject.Object
	F_res           AsyncResult
}

//export myAsyncReadyCallback
func myAsyncReadyCallback(source_object *C.GObject, res *C.GAsyncResult, user_data C.gpointer) {
	fn := gi.GetFunc(uint(uintptr(user_data)))
	args := AsyncReadyCallbackStruct{
		F_source_object: gobject.WrapObject(unsafe.Pointer(source_object)),
		F_res:           AsyncResult{P: unsafe.Pointer(res)},
	}
	fn(args)
}

// Interface AsyncResult
type AsyncResult struct {
	AsyncResultIfc
	P unsafe.Pointer
}
type AsyncResultIfc struct{}
type IAsyncResult interface{ P_AsyncResult() unsafe.Pointer }

func (v AsyncResult) P_AsyncResult() unsafe.Pointer { return v.P }
func AsyncResultGetType() gi.GType {
	ret := _I.GetGType(16, "AsyncResult")
	return ret
}

// g_async_result_get_source_object
// container is not nil, container is AsyncResult
// is method
func (v *AsyncResultIfc) GetSourceObject() (result gobject.Object) {
	iv, err := _I.Get(123, "AsyncResult", "get_source_object")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_async_result_get_user_data
// container is not nil, container is AsyncResult
// is method
func (v *AsyncResultIfc) GetUserData() (result unsafe.Pointer) {
	iv, err := _I.Get(124, "AsyncResult", "get_user_data")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Pointer()
	return
}

// g_async_result_is_tagged
// container is not nil, container is AsyncResult
// is method
func (v *AsyncResultIfc) IsTagged(source_tag unsafe.Pointer) (result bool) {
	iv, err := _I.Get(125, "AsyncResult", "is_tagged")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_source_tag := gi.NewPointerArgument(source_tag)
	args := []gi.Argument{arg_v, arg_source_tag}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_async_result_legacy_propagate_error
// container is not nil, container is AsyncResult
// is method
func (v *AsyncResultIfc) LegacyPropagateError() (result bool, err error) {
	iv, err := _I.Get(126, "AsyncResult", "legacy_propagate_error")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Bool()
	return
}

// ignore GType struct AsyncResultIface
// Object BufferedInputStream
type BufferedInputStream struct {
	SeekableIfc
	FilterInputStream
}

func WrapBufferedInputStream(p unsafe.Pointer) (r BufferedInputStream) { r.P = p; return }

type IBufferedInputStream interface{ P_BufferedInputStream() unsafe.Pointer }

func (v BufferedInputStream) P_BufferedInputStream() unsafe.Pointer { return v.P }
func (v BufferedInputStream) P_Seekable() unsafe.Pointer            { return v.P }
func BufferedInputStreamGetType() gi.GType {
	ret := _I.GetGType(17, "BufferedInputStream")
	return ret
}

// g_buffered_input_stream_new
// container is not nil, container is BufferedInputStream
// is constructor
func NewBufferedInputStream(base_stream IInputStream) (result BufferedInputStream) {
	iv, err := _I.Get(127, "BufferedInputStream", "new")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if base_stream != nil {
		tmp = base_stream.P_InputStream()
	}
	arg_base_stream := gi.NewPointerArgument(tmp)
	args := []gi.Argument{arg_base_stream}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_buffered_input_stream_new_sized
// container is not nil, container is BufferedInputStream
// is constructor
func NewBufferedInputStreamSized(base_stream IInputStream, size uint64) (result BufferedInputStream) {
	iv, err := _I.Get(128, "BufferedInputStream", "new_sized")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if base_stream != nil {
		tmp = base_stream.P_InputStream()
	}
	arg_base_stream := gi.NewPointerArgument(tmp)
	arg_size := gi.NewUint64Argument(size)
	args := []gi.Argument{arg_base_stream, arg_size}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_buffered_input_stream_fill
// container is not nil, container is BufferedInputStream
// is method
func (v BufferedInputStream) Fill(count int64, cancellable ICancellable) (result int64, err error) {
	iv, err := _I.Get(129, "BufferedInputStream", "fill")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_count := gi.NewInt64Argument(count)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_count, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Int64()
	return
}

// g_buffered_input_stream_fill_async
// container is not nil, container is BufferedInputStream
// is method
func (v BufferedInputStream) FillAsync(count int64, io_priority int32, cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(130, "BufferedInputStream", "fill_async")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_count := gi.NewInt64Argument(count)
	arg_io_priority := gi.NewInt32Argument(io_priority)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_v, arg_count, arg_io_priority, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
}

// g_buffered_input_stream_fill_finish
// container is not nil, container is BufferedInputStream
// is method
func (v BufferedInputStream) FillFinish(result IAsyncResult) (result1 int64, err error) {
	iv, err := _I.Get(131, "BufferedInputStream", "fill_finish")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if result != nil {
		tmp = result.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_result := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_result, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result1 = ret.Int64()
	return
}

// g_buffered_input_stream_get_available
// container is not nil, container is BufferedInputStream
// is method
func (v BufferedInputStream) GetAvailable() (result uint64) {
	iv, err := _I.Get(132, "BufferedInputStream", "get_available")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Uint64()
	return
}

// g_buffered_input_stream_get_buffer_size
// container is not nil, container is BufferedInputStream
// is method
func (v BufferedInputStream) GetBufferSize() (result uint64) {
	iv, err := _I.Get(133, "BufferedInputStream", "get_buffer_size")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Uint64()
	return
}

// g_buffered_input_stream_peek
// container is not nil, container is BufferedInputStream
// is method
// arg 0 buffer lenArgIdx 2
func (v BufferedInputStream) Peek(buffer gi.Uint8Array, offset uint64, count uint64) (result uint64) {
	iv, err := _I.Get(134, "BufferedInputStream", "peek")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_buffer := gi.NewPointerArgument(buffer.P)
	arg_offset := gi.NewUint64Argument(offset)
	arg_count := gi.NewUint64Argument(count)
	args := []gi.Argument{arg_v, arg_buffer, arg_offset, arg_count}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Uint64()
	return
}

// g_buffered_input_stream_peek_buffer
// container is not nil, container is BufferedInputStream
// is method
// ret lenArgIdx 0
func (v BufferedInputStream) PeekBuffer() (result gi.Uint8Array) {
	iv, err := _I.Get(135, "BufferedInputStream", "peek_buffer")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var outArgs [1]gi.Argument
	arg_v := gi.NewPointerArgument(v.P)
	arg_count := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_count}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	var count uint64
	_ = count
	count = outArgs[0].Uint64()
	result = gi.Uint8Array{P: ret.Pointer(), Len: int(count)}
	return
}

// g_buffered_input_stream_read_byte
// container is not nil, container is BufferedInputStream
// is method
func (v BufferedInputStream) ReadByte(cancellable ICancellable) (result int32, err error) {
	iv, err := _I.Get(136, "BufferedInputStream", "read_byte")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Int32()
	return
}

// g_buffered_input_stream_set_buffer_size
// container is not nil, container is BufferedInputStream
// is method
func (v BufferedInputStream) SetBufferSize(size uint64) {
	iv, err := _I.Get(137, "BufferedInputStream", "set_buffer_size")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_size := gi.NewUint64Argument(size)
	args := []gi.Argument{arg_v, arg_size}
	iv.Call(args, nil, nil)
}

// ignore GType struct BufferedInputStreamClass
// Struct BufferedInputStreamPrivate
type BufferedInputStreamPrivate struct {
	P unsafe.Pointer
}

func BufferedInputStreamPrivateGetType() gi.GType {
	ret := _I.GetGType(18, "BufferedInputStreamPrivate")
	return ret
}

// Object BufferedOutputStream
type BufferedOutputStream struct {
	SeekableIfc
	FilterOutputStream
}

func WrapBufferedOutputStream(p unsafe.Pointer) (r BufferedOutputStream) { r.P = p; return }

type IBufferedOutputStream interface{ P_BufferedOutputStream() unsafe.Pointer }

func (v BufferedOutputStream) P_BufferedOutputStream() unsafe.Pointer { return v.P }
func (v BufferedOutputStream) P_Seekable() unsafe.Pointer             { return v.P }
func BufferedOutputStreamGetType() gi.GType {
	ret := _I.GetGType(19, "BufferedOutputStream")
	return ret
}

// g_buffered_output_stream_new
// container is not nil, container is BufferedOutputStream
// is constructor
func NewBufferedOutputStream(base_stream IOutputStream) (result BufferedOutputStream) {
	iv, err := _I.Get(138, "BufferedOutputStream", "new")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if base_stream != nil {
		tmp = base_stream.P_OutputStream()
	}
	arg_base_stream := gi.NewPointerArgument(tmp)
	args := []gi.Argument{arg_base_stream}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_buffered_output_stream_new_sized
// container is not nil, container is BufferedOutputStream
// is constructor
func NewBufferedOutputStreamSized(base_stream IOutputStream, size uint64) (result BufferedOutputStream) {
	iv, err := _I.Get(139, "BufferedOutputStream", "new_sized")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if base_stream != nil {
		tmp = base_stream.P_OutputStream()
	}
	arg_base_stream := gi.NewPointerArgument(tmp)
	arg_size := gi.NewUint64Argument(size)
	args := []gi.Argument{arg_base_stream, arg_size}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_buffered_output_stream_get_auto_grow
// container is not nil, container is BufferedOutputStream
// is method
func (v BufferedOutputStream) GetAutoGrow() (result bool) {
	iv, err := _I.Get(140, "BufferedOutputStream", "get_auto_grow")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_buffered_output_stream_get_buffer_size
// container is not nil, container is BufferedOutputStream
// is method
func (v BufferedOutputStream) GetBufferSize() (result uint64) {
	iv, err := _I.Get(141, "BufferedOutputStream", "get_buffer_size")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Uint64()
	return
}

// g_buffered_output_stream_set_auto_grow
// container is not nil, container is BufferedOutputStream
// is method
func (v BufferedOutputStream) SetAutoGrow(auto_grow bool) {
	iv, err := _I.Get(142, "BufferedOutputStream", "set_auto_grow")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_auto_grow := gi.NewBoolArgument(auto_grow)
	args := []gi.Argument{arg_v, arg_auto_grow}
	iv.Call(args, nil, nil)
}

// g_buffered_output_stream_set_buffer_size
// container is not nil, container is BufferedOutputStream
// is method
func (v BufferedOutputStream) SetBufferSize(size uint64) {
	iv, err := _I.Get(143, "BufferedOutputStream", "set_buffer_size")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_size := gi.NewUint64Argument(size)
	args := []gi.Argument{arg_v, arg_size}
	iv.Call(args, nil, nil)
}

// ignore GType struct BufferedOutputStreamClass
// Struct BufferedOutputStreamPrivate
type BufferedOutputStreamPrivate struct {
	P unsafe.Pointer
}

func BufferedOutputStreamPrivateGetType() gi.GType {
	ret := _I.GetGType(20, "BufferedOutputStreamPrivate")
	return ret
}

type BusAcquiredCallbackStruct struct {
	F_connection DBusConnection
	F_name       string
}

//export myBusAcquiredCallback
func myBusAcquiredCallback(connection *C.GDBusConnection, name *C.gchar, user_data C.gpointer) {
	fn := gi.GetFunc(uint(uintptr(user_data)))
	args := BusAcquiredCallbackStruct{
		F_connection: WrapDBusConnection(unsafe.Pointer(connection)),
		F_name:       gi.GoString(unsafe.Pointer(name)),
	}
	fn(args)
}

type BusNameAcquiredCallbackStruct struct {
	F_connection DBusConnection
	F_name       string
}

//export myBusNameAcquiredCallback
func myBusNameAcquiredCallback(connection *C.GDBusConnection, name *C.gchar, user_data C.gpointer) {
	fn := gi.GetFunc(uint(uintptr(user_data)))
	args := BusNameAcquiredCallbackStruct{
		F_connection: WrapDBusConnection(unsafe.Pointer(connection)),
		F_name:       gi.GoString(unsafe.Pointer(name)),
	}
	fn(args)
}

type BusNameAppearedCallbackStruct struct {
	F_connection DBusConnection
	F_name       string
	F_name_owner string
}

//export myBusNameAppearedCallback
func myBusNameAppearedCallback(connection *C.GDBusConnection, name *C.gchar, name_owner *C.gchar, user_data C.gpointer) {
	fn := gi.GetFunc(uint(uintptr(user_data)))
	args := BusNameAppearedCallbackStruct{
		F_connection: WrapDBusConnection(unsafe.Pointer(connection)),
		F_name:       gi.GoString(unsafe.Pointer(name)),
		F_name_owner: gi.GoString(unsafe.Pointer(name_owner)),
	}
	fn(args)
}

type BusNameLostCallbackStruct struct {
	F_connection DBusConnection
	F_name       string
}

//export myBusNameLostCallback
func myBusNameLostCallback(connection *C.GDBusConnection, name *C.gchar, user_data C.gpointer) {
	fn := gi.GetFunc(uint(uintptr(user_data)))
	args := BusNameLostCallbackStruct{
		F_connection: WrapDBusConnection(unsafe.Pointer(connection)),
		F_name:       gi.GoString(unsafe.Pointer(name)),
	}
	fn(args)
}

// Flags BusNameOwnerFlags
type BusNameOwnerFlags int

const (
	BusNameOwnerFlagsNone             BusNameOwnerFlags = 0
	BusNameOwnerFlagsAllowReplacement BusNameOwnerFlags = 1
	BusNameOwnerFlagsReplace          BusNameOwnerFlags = 2
	BusNameOwnerFlagsDoNotQueue       BusNameOwnerFlags = 4
)

func BusNameOwnerFlagsGetType() gi.GType {
	ret := _I.GetGType(21, "BusNameOwnerFlags")
	return ret
}

type BusNameVanishedCallbackStruct struct {
	F_connection DBusConnection
	F_name       string
}

//export myBusNameVanishedCallback
func myBusNameVanishedCallback(connection *C.GDBusConnection, name *C.gchar, user_data C.gpointer) {
	fn := gi.GetFunc(uint(uintptr(user_data)))
	args := BusNameVanishedCallbackStruct{
		F_connection: WrapDBusConnection(unsafe.Pointer(connection)),
		F_name:       gi.GoString(unsafe.Pointer(name)),
	}
	fn(args)
}

// Flags BusNameWatcherFlags
type BusNameWatcherFlags int

const (
	BusNameWatcherFlagsNone      BusNameWatcherFlags = 0
	BusNameWatcherFlagsAutoStart BusNameWatcherFlags = 1
)

func BusNameWatcherFlagsGetType() gi.GType {
	ret := _I.GetGType(22, "BusNameWatcherFlags")
	return ret
}

// Enum BusType
type BusTypeEnum int

const (
	BusTypeStarter BusTypeEnum = -1
	BusTypeNone    BusTypeEnum = 0
	BusTypeSystem  BusTypeEnum = 1
	BusTypeSession BusTypeEnum = 2
)

func BusTypeGetType() gi.GType {
	ret := _I.GetGType(23, "BusType")
	return ret
}

// Object BytesIcon
type BytesIcon struct {
	IconIfc
	LoadableIconIfc
	gobject.Object
}

func WrapBytesIcon(p unsafe.Pointer) (r BytesIcon) { r.P = p; return }

type IBytesIcon interface{ P_BytesIcon() unsafe.Pointer }

func (v BytesIcon) P_BytesIcon() unsafe.Pointer    { return v.P }
func (v BytesIcon) P_Icon() unsafe.Pointer         { return v.P }
func (v BytesIcon) P_LoadableIcon() unsafe.Pointer { return v.P }
func BytesIconGetType() gi.GType {
	ret := _I.GetGType(24, "BytesIcon")
	return ret
}

// g_bytes_icon_new
// container is not nil, container is BytesIcon
// is constructor
func NewBytesIcon(bytes glib.Bytes) (result BytesIcon) {
	iv, err := _I.Get(144, "BytesIcon", "new")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_bytes := gi.NewPointerArgument(bytes.P)
	args := []gi.Argument{arg_bytes}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_bytes_icon_get_bytes
// container is not nil, container is BytesIcon
// is method
func (v BytesIcon) GetBytes() (result glib.Bytes) {
	iv, err := _I.Get(145, "BytesIcon", "get_bytes")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// Object Cancellable
type Cancellable struct {
	gobject.Object
}

func WrapCancellable(p unsafe.Pointer) (r Cancellable) { r.P = p; return }

type ICancellable interface{ P_Cancellable() unsafe.Pointer }

func (v Cancellable) P_Cancellable() unsafe.Pointer { return v.P }
func CancellableGetType() gi.GType {
	ret := _I.GetGType(25, "Cancellable")
	return ret
}

// g_cancellable_new
// container is not nil, container is Cancellable
// is constructor
func NewCancellable() (result Cancellable) {
	iv, err := _I.Get(146, "Cancellable", "new")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var ret gi.Argument
	iv.Call(nil, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_cancellable_cancel
// container is not nil, container is Cancellable
// is method
func (v Cancellable) Cancel() {
	iv, err := _I.Get(148, "Cancellable", "cancel")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	iv.Call(args, nil, nil)
}

// g_cancellable_connect
// container is not nil, container is Cancellable
// is method
func (v Cancellable) Connect(callback int /*TODO_TYPE isPtr: false, tag: interface*/, data unsafe.Pointer, data_destroy_func int /*TODO_TYPE isPtr: false, tag: interface*/) (result uint64) {
	iv, err := _I.Get(149, "Cancellable", "connect")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_data := gi.NewPointerArgument(data)
	arg_data_destroy_func := gi.NewIntArgument(data_destroy_func) /*TODO*/
	args := []gi.Argument{arg_v, arg_callback, arg_data, arg_data_destroy_func}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Uint64()
	return
}

// g_cancellable_disconnect
// container is not nil, container is Cancellable
// is method
func (v Cancellable) Disconnect(handler_id uint64) {
	iv, err := _I.Get(150, "Cancellable", "disconnect")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_handler_id := gi.NewUint64Argument(handler_id)
	args := []gi.Argument{arg_v, arg_handler_id}
	iv.Call(args, nil, nil)
}

// g_cancellable_get_fd
// container is not nil, container is Cancellable
// is method
func (v Cancellable) GetFd() (result int32) {
	iv, err := _I.Get(151, "Cancellable", "get_fd")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Int32()
	return
}

// g_cancellable_is_cancelled
// container is not nil, container is Cancellable
// is method
func (v Cancellable) IsCancelled() (result bool) {
	iv, err := _I.Get(152, "Cancellable", "is_cancelled")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_cancellable_make_pollfd
// container is not nil, container is Cancellable
// is method
func (v Cancellable) MakePollfd(pollfd glib.PollFD) (result bool) {
	iv, err := _I.Get(153, "Cancellable", "make_pollfd")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_pollfd := gi.NewPointerArgument(pollfd.P)
	args := []gi.Argument{arg_v, arg_pollfd}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_cancellable_pop_current
// container is not nil, container is Cancellable
// is method
func (v Cancellable) PopCurrent() {
	iv, err := _I.Get(154, "Cancellable", "pop_current")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	iv.Call(args, nil, nil)
}

// g_cancellable_push_current
// container is not nil, container is Cancellable
// is method
func (v Cancellable) PushCurrent() {
	iv, err := _I.Get(155, "Cancellable", "push_current")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	iv.Call(args, nil, nil)
}

// g_cancellable_release_fd
// container is not nil, container is Cancellable
// is method
func (v Cancellable) ReleaseFd() {
	iv, err := _I.Get(156, "Cancellable", "release_fd")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	iv.Call(args, nil, nil)
}

// g_cancellable_reset
// container is not nil, container is Cancellable
// is method
func (v Cancellable) Reset() {
	iv, err := _I.Get(157, "Cancellable", "reset")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	iv.Call(args, nil, nil)
}

// g_cancellable_set_error_if_cancelled
// container is not nil, container is Cancellable
// is method
func (v Cancellable) SetErrorIfCancelled() (result bool, err error) {
	iv, err := _I.Get(158, "Cancellable", "set_error_if_cancelled")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	arg_v := gi.NewPointerArgument(v.P)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Bool()
	return
}

// ignore GType struct CancellableClass
// Struct CancellablePrivate
type CancellablePrivate struct {
	P unsafe.Pointer
}

func CancellablePrivateGetType() gi.GType {
	ret := _I.GetGType(26, "CancellablePrivate")
	return ret
}

type CancellableSourceFuncStruct struct {
	F_cancellable Cancellable
}

//export myCancellableSourceFunc
func myCancellableSourceFunc(cancellable *C.GCancellable, user_data C.gpointer) {
	fn := gi.GetFunc(uint(uintptr(user_data)))
	args := CancellableSourceFuncStruct{
		F_cancellable: WrapCancellable(unsafe.Pointer(cancellable)),
	}
	fn(args)
}

// Object CharsetConverter
type CharsetConverter struct {
	ConverterIfc
	InitableIfc
	gobject.Object
}

func WrapCharsetConverter(p unsafe.Pointer) (r CharsetConverter) { r.P = p; return }

type ICharsetConverter interface{ P_CharsetConverter() unsafe.Pointer }

func (v CharsetConverter) P_CharsetConverter() unsafe.Pointer { return v.P }
func (v CharsetConverter) P_Converter() unsafe.Pointer        { return v.P }
func (v CharsetConverter) P_Initable() unsafe.Pointer         { return v.P }
func CharsetConverterGetType() gi.GType {
	ret := _I.GetGType(27, "CharsetConverter")
	return ret
}

// g_charset_converter_new
// container is not nil, container is CharsetConverter
// is constructor
func NewCharsetConverter(to_charset string, from_charset string) (result CharsetConverter, err error) {
	iv, err := _I.Get(159, "CharsetConverter", "new")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	c_to_charset := gi.CString(to_charset)
	c_from_charset := gi.CString(from_charset)
	arg_to_charset := gi.NewStringArgument(c_to_charset)
	arg_from_charset := gi.NewStringArgument(c_from_charset)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_to_charset, arg_from_charset, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	gi.Free(c_to_charset)
	gi.Free(c_from_charset)
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// g_charset_converter_get_num_fallbacks
// container is not nil, container is CharsetConverter
// is method
func (v CharsetConverter) GetNumFallbacks() (result uint32) {
	iv, err := _I.Get(160, "CharsetConverter", "get_num_fallbacks")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Uint32()
	return
}

// g_charset_converter_get_use_fallback
// container is not nil, container is CharsetConverter
// is method
func (v CharsetConverter) GetUseFallback() (result bool) {
	iv, err := _I.Get(161, "CharsetConverter", "get_use_fallback")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_charset_converter_set_use_fallback
// container is not nil, container is CharsetConverter
// is method
func (v CharsetConverter) SetUseFallback(use_fallback bool) {
	iv, err := _I.Get(162, "CharsetConverter", "set_use_fallback")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_use_fallback := gi.NewBoolArgument(use_fallback)
	args := []gi.Argument{arg_v, arg_use_fallback}
	iv.Call(args, nil, nil)
}

// ignore GType struct CharsetConverterClass
// Interface Converter
type Converter struct {
	ConverterIfc
	P unsafe.Pointer
}
type ConverterIfc struct{}
type IConverter interface{ P_Converter() unsafe.Pointer }

func (v Converter) P_Converter() unsafe.Pointer { return v.P }
func ConverterGetType() gi.GType {
	ret := _I.GetGType(28, "Converter")
	return ret
}

// g_converter_convert
// container is not nil, container is Converter
// is method
// arg 0 inbuf lenArgIdx 1
// arg 2 outbuf lenArgIdx 3
func (v *ConverterIfc) Convert(inbuf gi.Uint8Array, inbuf_size uint64, outbuf gi.Uint8Array, outbuf_size uint64, flags ConverterFlags) (result ConverterResultEnum, bytes_read uint64, bytes_written uint64, err error) {
	iv, err := _I.Get(163, "Converter", "convert")
	if err != nil {
		return
	}
	var outArgs [3]gi.Argument
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_inbuf := gi.NewPointerArgument(inbuf.P)
	arg_inbuf_size := gi.NewUint64Argument(inbuf_size)
	arg_outbuf := gi.NewPointerArgument(outbuf.P)
	arg_outbuf_size := gi.NewUint64Argument(outbuf_size)
	arg_flags := gi.NewIntArgument(int(flags))
	arg_bytes_read := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	arg_bytes_written := gi.NewPointerArgument(unsafe.Pointer(&outArgs[1]))
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[2]))
	args := []gi.Argument{arg_v, arg_inbuf, arg_inbuf_size, arg_outbuf, arg_outbuf_size, arg_flags, arg_bytes_read, arg_bytes_written, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[2].Pointer())
	bytes_read = outArgs[0].Uint64()
	bytes_written = outArgs[1].Uint64()
	result = ConverterResultEnum(ret.Int())
	return
}

// g_converter_reset
// container is not nil, container is Converter
// is method
func (v *ConverterIfc) Reset() {
	iv, err := _I.Get(164, "Converter", "reset")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	iv.Call(args, nil, nil)
}

// Flags ConverterFlags
type ConverterFlags int

const (
	ConverterFlagsNone       ConverterFlags = 0
	ConverterFlagsInputAtEnd ConverterFlags = 1
	ConverterFlagsFlush      ConverterFlags = 2
)

func ConverterFlagsGetType() gi.GType {
	ret := _I.GetGType(29, "ConverterFlags")
	return ret
}

// ignore GType struct ConverterIface
// Object ConverterInputStream
type ConverterInputStream struct {
	PollableInputStreamIfc
	FilterInputStream
}

func WrapConverterInputStream(p unsafe.Pointer) (r ConverterInputStream) { r.P = p; return }

type IConverterInputStream interface{ P_ConverterInputStream() unsafe.Pointer }

func (v ConverterInputStream) P_ConverterInputStream() unsafe.Pointer { return v.P }
func (v ConverterInputStream) P_PollableInputStream() unsafe.Pointer  { return v.P }
func ConverterInputStreamGetType() gi.GType {
	ret := _I.GetGType(30, "ConverterInputStream")
	return ret
}

// g_converter_input_stream_new
// container is not nil, container is ConverterInputStream
// is constructor
func NewConverterInputStream(base_stream IInputStream, converter IConverter) (result ConverterInputStream) {
	iv, err := _I.Get(165, "ConverterInputStream", "new")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if base_stream != nil {
		tmp = base_stream.P_InputStream()
	}
	var tmp1 unsafe.Pointer
	if converter != nil {
		tmp1 = converter.P_Converter()
	}
	arg_base_stream := gi.NewPointerArgument(tmp)
	arg_converter := gi.NewPointerArgument(tmp1)
	args := []gi.Argument{arg_base_stream, arg_converter}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_converter_input_stream_get_converter
// container is not nil, container is ConverterInputStream
// is method
func (v ConverterInputStream) GetConverter() (result Converter) {
	iv, err := _I.Get(166, "ConverterInputStream", "get_converter")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// ignore GType struct ConverterInputStreamClass
// Struct ConverterInputStreamPrivate
type ConverterInputStreamPrivate struct {
	P unsafe.Pointer
}

func ConverterInputStreamPrivateGetType() gi.GType {
	ret := _I.GetGType(31, "ConverterInputStreamPrivate")
	return ret
}

// Object ConverterOutputStream
type ConverterOutputStream struct {
	PollableOutputStreamIfc
	FilterOutputStream
}

func WrapConverterOutputStream(p unsafe.Pointer) (r ConverterOutputStream) { r.P = p; return }

type IConverterOutputStream interface{ P_ConverterOutputStream() unsafe.Pointer }

func (v ConverterOutputStream) P_ConverterOutputStream() unsafe.Pointer { return v.P }
func (v ConverterOutputStream) P_PollableOutputStream() unsafe.Pointer  { return v.P }
func ConverterOutputStreamGetType() gi.GType {
	ret := _I.GetGType(32, "ConverterOutputStream")
	return ret
}

// g_converter_output_stream_new
// container is not nil, container is ConverterOutputStream
// is constructor
func NewConverterOutputStream(base_stream IOutputStream, converter IConverter) (result ConverterOutputStream) {
	iv, err := _I.Get(167, "ConverterOutputStream", "new")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if base_stream != nil {
		tmp = base_stream.P_OutputStream()
	}
	var tmp1 unsafe.Pointer
	if converter != nil {
		tmp1 = converter.P_Converter()
	}
	arg_base_stream := gi.NewPointerArgument(tmp)
	arg_converter := gi.NewPointerArgument(tmp1)
	args := []gi.Argument{arg_base_stream, arg_converter}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_converter_output_stream_get_converter
// container is not nil, container is ConverterOutputStream
// is method
func (v ConverterOutputStream) GetConverter() (result Converter) {
	iv, err := _I.Get(168, "ConverterOutputStream", "get_converter")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// ignore GType struct ConverterOutputStreamClass
// Struct ConverterOutputStreamPrivate
type ConverterOutputStreamPrivate struct {
	P unsafe.Pointer
}

func ConverterOutputStreamPrivateGetType() gi.GType {
	ret := _I.GetGType(33, "ConverterOutputStreamPrivate")
	return ret
}

// Enum ConverterResult
type ConverterResultEnum int

const (
	ConverterResultError     ConverterResultEnum = 0
	ConverterResultConverted ConverterResultEnum = 1
	ConverterResultFinished  ConverterResultEnum = 2
	ConverterResultFlushed   ConverterResultEnum = 3
)

func ConverterResultGetType() gi.GType {
	ret := _I.GetGType(34, "ConverterResult")
	return ret
}

// Object Credentials
type Credentials struct {
	gobject.Object
}

func WrapCredentials(p unsafe.Pointer) (r Credentials) { r.P = p; return }

type ICredentials interface{ P_Credentials() unsafe.Pointer }

func (v Credentials) P_Credentials() unsafe.Pointer { return v.P }
func CredentialsGetType() gi.GType {
	ret := _I.GetGType(35, "Credentials")
	return ret
}

// g_credentials_new
// container is not nil, container is Credentials
// is constructor
func NewCredentials() (result Credentials) {
	iv, err := _I.Get(169, "Credentials", "new")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var ret gi.Argument
	iv.Call(nil, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_credentials_get_unix_pid
// container is not nil, container is Credentials
// is method
func (v Credentials) GetUnixPid() (result int32, err error) {
	iv, err := _I.Get(170, "Credentials", "get_unix_pid")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	arg_v := gi.NewPointerArgument(v.P)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Int32()
	return
}

// g_credentials_get_unix_user
// container is not nil, container is Credentials
// is method
func (v Credentials) GetUnixUser() (result uint32, err error) {
	iv, err := _I.Get(171, "Credentials", "get_unix_user")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	arg_v := gi.NewPointerArgument(v.P)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Uint32()
	return
}

// g_credentials_is_same_user
// container is not nil, container is Credentials
// is method
func (v Credentials) IsSameUser(other_credentials ICredentials) (result bool, err error) {
	iv, err := _I.Get(172, "Credentials", "is_same_user")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if other_credentials != nil {
		tmp = other_credentials.P_Credentials()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_other_credentials := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_other_credentials, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Bool()
	return
}

// g_credentials_set_native
// container is not nil, container is Credentials
// is method
func (v Credentials) SetNative(native_type CredentialsTypeEnum, native unsafe.Pointer) {
	iv, err := _I.Get(173, "Credentials", "set_native")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_native_type := gi.NewIntArgument(int(native_type))
	arg_native := gi.NewPointerArgument(native)
	args := []gi.Argument{arg_v, arg_native_type, arg_native}
	iv.Call(args, nil, nil)
}

// g_credentials_set_unix_user
// container is not nil, container is Credentials
// is method
func (v Credentials) SetUnixUser(uid uint32) (result bool, err error) {
	iv, err := _I.Get(174, "Credentials", "set_unix_user")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	arg_v := gi.NewPointerArgument(v.P)
	arg_uid := gi.NewUint32Argument(uid)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_uid, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Bool()
	return
}

// g_credentials_to_string
// container is not nil, container is Credentials
// is method
func (v Credentials) ToString() (result string) {
	iv, err := _I.Get(175, "Credentials", "to_string")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Take()
	return
}

// ignore GType struct CredentialsClass
// Enum CredentialsType
type CredentialsTypeEnum int

const (
	CredentialsTypeInvalid             CredentialsTypeEnum = 0
	CredentialsTypeLinuxUcred          CredentialsTypeEnum = 1
	CredentialsTypeFreebsdCmsgcred     CredentialsTypeEnum = 2
	CredentialsTypeOpenbsdSockpeercred CredentialsTypeEnum = 3
	CredentialsTypeSolarisUcred        CredentialsTypeEnum = 4
	CredentialsTypeNetbsdUnpcbid       CredentialsTypeEnum = 5
)

func CredentialsTypeGetType() gi.GType {
	ret := _I.GetGType(36, "CredentialsType")
	return ret
}

// Object DBusActionGroup
type DBusActionGroup struct {
	ActionGroupIfc
	RemoteActionGroupIfc
	gobject.Object
}

func WrapDBusActionGroup(p unsafe.Pointer) (r DBusActionGroup) { r.P = p; return }

type IDBusActionGroup interface{ P_DBusActionGroup() unsafe.Pointer }

func (v DBusActionGroup) P_DBusActionGroup() unsafe.Pointer   { return v.P }
func (v DBusActionGroup) P_ActionGroup() unsafe.Pointer       { return v.P }
func (v DBusActionGroup) P_RemoteActionGroup() unsafe.Pointer { return v.P }
func DBusActionGroupGetType() gi.GType {
	ret := _I.GetGType(37, "DBusActionGroup")
	return ret
}

// g_dbus_action_group_get
// container is not nil, container is DBusActionGroup
// is method
// arg0Type tag: interface, isPtr: true
func DBusActionGroupGet1(connection IDBusConnection, bus_name string, object_path string) (result DBusActionGroup) {
	iv, err := _I.Get(176, "DBusActionGroup", "get")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if connection != nil {
		tmp = connection.P_DBusConnection()
	}
	c_bus_name := gi.CString(bus_name)
	c_object_path := gi.CString(object_path)
	arg_connection := gi.NewPointerArgument(tmp)
	arg_bus_name := gi.NewStringArgument(c_bus_name)
	arg_object_path := gi.NewStringArgument(c_object_path)
	args := []gi.Argument{arg_connection, arg_bus_name, arg_object_path}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_bus_name)
	gi.Free(c_object_path)
	result.P = ret.Pointer()
	return
}

// Struct DBusAnnotationInfo
type DBusAnnotationInfo struct {
	P unsafe.Pointer
}

const SizeOfStructDBusAnnotationInfo = 32

func DBusAnnotationInfoGetType() gi.GType {
	ret := _I.GetGType(38, "DBusAnnotationInfo")
	return ret
}

// g_dbus_annotation_info_ref
// container is not nil, container is DBusAnnotationInfo
// is method
func (v DBusAnnotationInfo) Ref() (result DBusAnnotationInfo) {
	iv, err := _I.Get(177, "DBusAnnotationInfo", "ref")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_dbus_annotation_info_unref
// container is not nil, container is DBusAnnotationInfo
// is method
func (v DBusAnnotationInfo) Unref() {
	iv, err := _I.Get(178, "DBusAnnotationInfo", "unref")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	iv.Call(args, nil, nil)
}

// g_dbus_annotation_info_lookup
// container is not nil, container is DBusAnnotationInfo
// is method
// arg0Type tag: array, isPtr: true
func DBusAnnotationInfoLookup1(annotations gi.PointerArray, name string) (result string) {
	iv, err := _I.Get(179, "DBusAnnotationInfo", "lookup")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_name := gi.CString(name)
	arg_annotations := gi.NewPointerArgument(annotations.P)
	arg_name := gi.NewStringArgument(c_name)
	args := []gi.Argument{arg_annotations, arg_name}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_name)
	result = ret.String().Take()
	return
}

// Struct DBusArgInfo
type DBusArgInfo struct {
	P unsafe.Pointer
}

const SizeOfStructDBusArgInfo = 32

func DBusArgInfoGetType() gi.GType {
	ret := _I.GetGType(39, "DBusArgInfo")
	return ret
}

// g_dbus_arg_info_ref
// container is not nil, container is DBusArgInfo
// is method
func (v DBusArgInfo) Ref() (result DBusArgInfo) {
	iv, err := _I.Get(180, "DBusArgInfo", "ref")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_dbus_arg_info_unref
// container is not nil, container is DBusArgInfo
// is method
func (v DBusArgInfo) Unref() {
	iv, err := _I.Get(181, "DBusArgInfo", "unref")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	iv.Call(args, nil, nil)
}

// Object DBusAuthObserver
type DBusAuthObserver struct {
	gobject.Object
}

func WrapDBusAuthObserver(p unsafe.Pointer) (r DBusAuthObserver) { r.P = p; return }

type IDBusAuthObserver interface{ P_DBusAuthObserver() unsafe.Pointer }

func (v DBusAuthObserver) P_DBusAuthObserver() unsafe.Pointer { return v.P }
func DBusAuthObserverGetType() gi.GType {
	ret := _I.GetGType(40, "DBusAuthObserver")
	return ret
}

// g_dbus_auth_observer_new
// container is not nil, container is DBusAuthObserver
// is constructor
func NewDBusAuthObserver() (result DBusAuthObserver) {
	iv, err := _I.Get(182, "DBusAuthObserver", "new")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var ret gi.Argument
	iv.Call(nil, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_dbus_auth_observer_allow_mechanism
// container is not nil, container is DBusAuthObserver
// is method
func (v DBusAuthObserver) AllowMechanism(mechanism string) (result bool) {
	iv, err := _I.Get(183, "DBusAuthObserver", "allow_mechanism")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_mechanism := gi.CString(mechanism)
	arg_v := gi.NewPointerArgument(v.P)
	arg_mechanism := gi.NewStringArgument(c_mechanism)
	args := []gi.Argument{arg_v, arg_mechanism}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_mechanism)
	result = ret.Bool()
	return
}

// g_dbus_auth_observer_authorize_authenticated_peer
// container is not nil, container is DBusAuthObserver
// is method
func (v DBusAuthObserver) AuthorizeAuthenticatedPeer(stream IIOStream, credentials ICredentials) (result bool) {
	iv, err := _I.Get(184, "DBusAuthObserver", "authorize_authenticated_peer")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if stream != nil {
		tmp = stream.P_IOStream()
	}
	var tmp1 unsafe.Pointer
	if credentials != nil {
		tmp1 = credentials.P_Credentials()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_stream := gi.NewPointerArgument(tmp)
	arg_credentials := gi.NewPointerArgument(tmp1)
	args := []gi.Argument{arg_v, arg_stream, arg_credentials}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// Flags DBusCallFlags
type DBusCallFlags int

const (
	DBusCallFlagsNone                          DBusCallFlags = 0
	DBusCallFlagsNoAutoStart                   DBusCallFlags = 1
	DBusCallFlagsAllowInteractiveAuthorization DBusCallFlags = 2
)

func DBusCallFlagsGetType() gi.GType {
	ret := _I.GetGType(41, "DBusCallFlags")
	return ret
}

// Flags DBusCapabilityFlags
type DBusCapabilityFlags int

const (
	DBusCapabilityFlagsNone          DBusCapabilityFlags = 0
	DBusCapabilityFlagsUnixFdPassing DBusCapabilityFlags = 1
)

func DBusCapabilityFlagsGetType() gi.GType {
	ret := _I.GetGType(42, "DBusCapabilityFlags")
	return ret
}

// Object DBusConnection
type DBusConnection struct {
	AsyncInitableIfc
	InitableIfc
	gobject.Object
}

func WrapDBusConnection(p unsafe.Pointer) (r DBusConnection) { r.P = p; return }

type IDBusConnection interface{ P_DBusConnection() unsafe.Pointer }

func (v DBusConnection) P_DBusConnection() unsafe.Pointer { return v.P }
func (v DBusConnection) P_AsyncInitable() unsafe.Pointer  { return v.P }
func (v DBusConnection) P_Initable() unsafe.Pointer       { return v.P }
func DBusConnectionGetType() gi.GType {
	ret := _I.GetGType(43, "DBusConnection")
	return ret
}

// g_dbus_connection_new_finish
// container is not nil, container is DBusConnection
// is constructor
func NewDBusConnectionFinish(res IAsyncResult) (result DBusConnection, err error) {
	iv, err := _I.Get(185, "DBusConnection", "new_finish")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if res != nil {
		tmp = res.P_AsyncResult()
	}
	arg_res := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_res, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// g_dbus_connection_new_for_address_finish
// container is not nil, container is DBusConnection
// is constructor
func NewDBusConnectionForAddressFinish(res IAsyncResult) (result DBusConnection, err error) {
	iv, err := _I.Get(186, "DBusConnection", "new_for_address_finish")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if res != nil {
		tmp = res.P_AsyncResult()
	}
	arg_res := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_res, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// g_dbus_connection_new_for_address_sync
// container is not nil, container is DBusConnection
// is constructor
func NewDBusConnectionForAddressSync(address string, flags DBusConnectionFlags, observer IDBusAuthObserver, cancellable ICancellable) (result DBusConnection, err error) {
	iv, err := _I.Get(187, "DBusConnection", "new_for_address_sync")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	c_address := gi.CString(address)
	var tmp unsafe.Pointer
	if observer != nil {
		tmp = observer.P_DBusAuthObserver()
	}
	var tmp1 unsafe.Pointer
	if cancellable != nil {
		tmp1 = cancellable.P_Cancellable()
	}
	arg_address := gi.NewStringArgument(c_address)
	arg_flags := gi.NewIntArgument(int(flags))
	arg_observer := gi.NewPointerArgument(tmp)
	arg_cancellable := gi.NewPointerArgument(tmp1)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_address, arg_flags, arg_observer, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	gi.Free(c_address)
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// g_dbus_connection_new_sync
// container is not nil, container is DBusConnection
// is constructor
func NewDBusConnectionSync(stream IIOStream, guid string, flags DBusConnectionFlags, observer IDBusAuthObserver, cancellable ICancellable) (result DBusConnection, err error) {
	iv, err := _I.Get(188, "DBusConnection", "new_sync")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if stream != nil {
		tmp = stream.P_IOStream()
	}
	c_guid := gi.CString(guid)
	var tmp1 unsafe.Pointer
	if observer != nil {
		tmp1 = observer.P_DBusAuthObserver()
	}
	var tmp2 unsafe.Pointer
	if cancellable != nil {
		tmp2 = cancellable.P_Cancellable()
	}
	arg_stream := gi.NewPointerArgument(tmp)
	arg_guid := gi.NewStringArgument(c_guid)
	arg_flags := gi.NewIntArgument(int(flags))
	arg_observer := gi.NewPointerArgument(tmp1)
	arg_cancellable := gi.NewPointerArgument(tmp2)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_stream, arg_guid, arg_flags, arg_observer, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	gi.Free(c_guid)
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// g_dbus_connection_new
// container is not nil, container is DBusConnection
// is method
// arg0Type tag: interface, isPtr: true
func DBusConnectionNew1(stream IIOStream, guid string, flags DBusConnectionFlags, observer IDBusAuthObserver, cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(189, "DBusConnection", "new")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if stream != nil {
		tmp = stream.P_IOStream()
	}
	c_guid := gi.CString(guid)
	var tmp1 unsafe.Pointer
	if observer != nil {
		tmp1 = observer.P_DBusAuthObserver()
	}
	var tmp2 unsafe.Pointer
	if cancellable != nil {
		tmp2 = cancellable.P_Cancellable()
	}
	arg_stream := gi.NewPointerArgument(tmp)
	arg_guid := gi.NewStringArgument(c_guid)
	arg_flags := gi.NewIntArgument(int(flags))
	arg_observer := gi.NewPointerArgument(tmp1)
	arg_cancellable := gi.NewPointerArgument(tmp2)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_stream, arg_guid, arg_flags, arg_observer, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
	gi.Free(c_guid)
}

// g_dbus_connection_new_for_address
// container is not nil, container is DBusConnection
// is method
// arg0Type tag: utf8, isPtr: true
func DBusConnectionNewForAddress1(address string, flags DBusConnectionFlags, observer IDBusAuthObserver, cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(190, "DBusConnection", "new_for_address")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_address := gi.CString(address)
	var tmp unsafe.Pointer
	if observer != nil {
		tmp = observer.P_DBusAuthObserver()
	}
	var tmp1 unsafe.Pointer
	if cancellable != nil {
		tmp1 = cancellable.P_Cancellable()
	}
	arg_address := gi.NewStringArgument(c_address)
	arg_flags := gi.NewIntArgument(int(flags))
	arg_observer := gi.NewPointerArgument(tmp)
	arg_cancellable := gi.NewPointerArgument(tmp1)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_address, arg_flags, arg_observer, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
	gi.Free(c_address)
}

// g_dbus_connection_add_filter
// container is not nil, container is DBusConnection
// is method
func (v DBusConnection) AddFilter(filter_function int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer, user_data_free_func int /*TODO_TYPE isPtr: false, tag: interface*/) (result uint32) {
	iv, err := _I.Get(191, "DBusConnection", "add_filter")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_filter_function := gi.NewIntArgument(filter_function) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	arg_user_data_free_func := gi.NewIntArgument(user_data_free_func) /*TODO*/
	args := []gi.Argument{arg_v, arg_filter_function, arg_user_data, arg_user_data_free_func}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Uint32()
	return
}

// g_dbus_connection_call
// container is not nil, container is DBusConnection
// is method
func (v DBusConnection) Call(bus_name string, object_path string, interface_name string, method_name string, parameters glib.Variant, reply_type glib.VariantType, flags DBusCallFlags, timeout_msec int32, cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(192, "DBusConnection", "call")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_bus_name := gi.CString(bus_name)
	c_object_path := gi.CString(object_path)
	c_interface_name := gi.CString(interface_name)
	c_method_name := gi.CString(method_name)
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_bus_name := gi.NewStringArgument(c_bus_name)
	arg_object_path := gi.NewStringArgument(c_object_path)
	arg_interface_name := gi.NewStringArgument(c_interface_name)
	arg_method_name := gi.NewStringArgument(c_method_name)
	arg_parameters := gi.NewPointerArgument(parameters.P)
	arg_reply_type := gi.NewPointerArgument(reply_type.P)
	arg_flags := gi.NewIntArgument(int(flags))
	arg_timeout_msec := gi.NewInt32Argument(timeout_msec)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_v, arg_bus_name, arg_object_path, arg_interface_name, arg_method_name, arg_parameters, arg_reply_type, arg_flags, arg_timeout_msec, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
	gi.Free(c_bus_name)
	gi.Free(c_object_path)
	gi.Free(c_interface_name)
	gi.Free(c_method_name)
}

// g_dbus_connection_call_finish
// container is not nil, container is DBusConnection
// is method
func (v DBusConnection) CallFinish(res IAsyncResult) (result glib.Variant, err error) {
	iv, err := _I.Get(193, "DBusConnection", "call_finish")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if res != nil {
		tmp = res.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_res := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_res, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// g_dbus_connection_call_sync
// container is not nil, container is DBusConnection
// is method
func (v DBusConnection) CallSync(bus_name string, object_path string, interface_name string, method_name string, parameters glib.Variant, reply_type glib.VariantType, flags DBusCallFlags, timeout_msec int32, cancellable ICancellable) (result glib.Variant, err error) {
	iv, err := _I.Get(194, "DBusConnection", "call_sync")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	c_bus_name := gi.CString(bus_name)
	c_object_path := gi.CString(object_path)
	c_interface_name := gi.CString(interface_name)
	c_method_name := gi.CString(method_name)
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_bus_name := gi.NewStringArgument(c_bus_name)
	arg_object_path := gi.NewStringArgument(c_object_path)
	arg_interface_name := gi.NewStringArgument(c_interface_name)
	arg_method_name := gi.NewStringArgument(c_method_name)
	arg_parameters := gi.NewPointerArgument(parameters.P)
	arg_reply_type := gi.NewPointerArgument(reply_type.P)
	arg_flags := gi.NewIntArgument(int(flags))
	arg_timeout_msec := gi.NewInt32Argument(timeout_msec)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_bus_name, arg_object_path, arg_interface_name, arg_method_name, arg_parameters, arg_reply_type, arg_flags, arg_timeout_msec, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	gi.Free(c_bus_name)
	gi.Free(c_object_path)
	gi.Free(c_interface_name)
	gi.Free(c_method_name)
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// g_dbus_connection_call_with_unix_fd_list
// container is not nil, container is DBusConnection
// is method
func (v DBusConnection) CallWithUnixFdList(bus_name string, object_path string, interface_name string, method_name string, parameters glib.Variant, reply_type glib.VariantType, flags DBusCallFlags, timeout_msec int32, fd_list IUnixFDList, cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(195, "DBusConnection", "call_with_unix_fd_list")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_bus_name := gi.CString(bus_name)
	c_object_path := gi.CString(object_path)
	c_interface_name := gi.CString(interface_name)
	c_method_name := gi.CString(method_name)
	var tmp unsafe.Pointer
	if fd_list != nil {
		tmp = fd_list.P_UnixFDList()
	}
	var tmp1 unsafe.Pointer
	if cancellable != nil {
		tmp1 = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_bus_name := gi.NewStringArgument(c_bus_name)
	arg_object_path := gi.NewStringArgument(c_object_path)
	arg_interface_name := gi.NewStringArgument(c_interface_name)
	arg_method_name := gi.NewStringArgument(c_method_name)
	arg_parameters := gi.NewPointerArgument(parameters.P)
	arg_reply_type := gi.NewPointerArgument(reply_type.P)
	arg_flags := gi.NewIntArgument(int(flags))
	arg_timeout_msec := gi.NewInt32Argument(timeout_msec)
	arg_fd_list := gi.NewPointerArgument(tmp)
	arg_cancellable := gi.NewPointerArgument(tmp1)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_v, arg_bus_name, arg_object_path, arg_interface_name, arg_method_name, arg_parameters, arg_reply_type, arg_flags, arg_timeout_msec, arg_fd_list, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
	gi.Free(c_bus_name)
	gi.Free(c_object_path)
	gi.Free(c_interface_name)
	gi.Free(c_method_name)
}

// g_dbus_connection_call_with_unix_fd_list_finish
// container is not nil, container is DBusConnection
// is method
func (v DBusConnection) CallWithUnixFdListFinish(res IAsyncResult) (result glib.Variant, out_fd_list UnixFDList, err error) {
	iv, err := _I.Get(196, "DBusConnection", "call_with_unix_fd_list_finish")
	if err != nil {
		return
	}
	var outArgs [2]gi.Argument
	var tmp unsafe.Pointer
	if res != nil {
		tmp = res.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_out_fd_list := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	arg_res := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[1]))
	args := []gi.Argument{arg_v, arg_out_fd_list, arg_res, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[1].Pointer())
	out_fd_list.P = outArgs[0].Pointer()
	result.P = ret.Pointer()
	return
}

// g_dbus_connection_call_with_unix_fd_list_sync
// container is not nil, container is DBusConnection
// is method
func (v DBusConnection) CallWithUnixFdListSync(bus_name string, object_path string, interface_name string, method_name string, parameters glib.Variant, reply_type glib.VariantType, flags DBusCallFlags, timeout_msec int32, fd_list IUnixFDList, cancellable ICancellable) (result glib.Variant, out_fd_list UnixFDList, err error) {
	iv, err := _I.Get(197, "DBusConnection", "call_with_unix_fd_list_sync")
	if err != nil {
		return
	}
	var outArgs [2]gi.Argument
	c_bus_name := gi.CString(bus_name)
	c_object_path := gi.CString(object_path)
	c_interface_name := gi.CString(interface_name)
	c_method_name := gi.CString(method_name)
	var tmp unsafe.Pointer
	if fd_list != nil {
		tmp = fd_list.P_UnixFDList()
	}
	var tmp1 unsafe.Pointer
	if cancellable != nil {
		tmp1 = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_bus_name := gi.NewStringArgument(c_bus_name)
	arg_object_path := gi.NewStringArgument(c_object_path)
	arg_interface_name := gi.NewStringArgument(c_interface_name)
	arg_method_name := gi.NewStringArgument(c_method_name)
	arg_parameters := gi.NewPointerArgument(parameters.P)
	arg_reply_type := gi.NewPointerArgument(reply_type.P)
	arg_flags := gi.NewIntArgument(int(flags))
	arg_timeout_msec := gi.NewInt32Argument(timeout_msec)
	arg_fd_list := gi.NewPointerArgument(tmp)
	arg_out_fd_list := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	arg_cancellable := gi.NewPointerArgument(tmp1)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[1]))
	args := []gi.Argument{arg_v, arg_bus_name, arg_object_path, arg_interface_name, arg_method_name, arg_parameters, arg_reply_type, arg_flags, arg_timeout_msec, arg_fd_list, arg_out_fd_list, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	gi.Free(c_bus_name)
	gi.Free(c_object_path)
	gi.Free(c_interface_name)
	gi.Free(c_method_name)
	err = gi.ToError(outArgs[1].Pointer())
	out_fd_list.P = outArgs[0].Pointer()
	result.P = ret.Pointer()
	return
}

// g_dbus_connection_close
// container is not nil, container is DBusConnection
// is method
func (v DBusConnection) Close(cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(198, "DBusConnection", "close")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_v, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
}

// g_dbus_connection_close_finish
// container is not nil, container is DBusConnection
// is method
func (v DBusConnection) CloseFinish(res IAsyncResult) (result bool, err error) {
	iv, err := _I.Get(199, "DBusConnection", "close_finish")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if res != nil {
		tmp = res.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_res := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_res, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Bool()
	return
}

// g_dbus_connection_close_sync
// container is not nil, container is DBusConnection
// is method
func (v DBusConnection) CloseSync(cancellable ICancellable) (result bool, err error) {
	iv, err := _I.Get(200, "DBusConnection", "close_sync")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Bool()
	return
}

// g_dbus_connection_emit_signal
// container is not nil, container is DBusConnection
// is method
func (v DBusConnection) EmitSignal(destination_bus_name string, object_path string, interface_name string, signal_name string, parameters glib.Variant) (result bool, err error) {
	iv, err := _I.Get(201, "DBusConnection", "emit_signal")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	c_destination_bus_name := gi.CString(destination_bus_name)
	c_object_path := gi.CString(object_path)
	c_interface_name := gi.CString(interface_name)
	c_signal_name := gi.CString(signal_name)
	arg_v := gi.NewPointerArgument(v.P)
	arg_destination_bus_name := gi.NewStringArgument(c_destination_bus_name)
	arg_object_path := gi.NewStringArgument(c_object_path)
	arg_interface_name := gi.NewStringArgument(c_interface_name)
	arg_signal_name := gi.NewStringArgument(c_signal_name)
	arg_parameters := gi.NewPointerArgument(parameters.P)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_destination_bus_name, arg_object_path, arg_interface_name, arg_signal_name, arg_parameters, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	gi.Free(c_destination_bus_name)
	gi.Free(c_object_path)
	gi.Free(c_interface_name)
	gi.Free(c_signal_name)
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Bool()
	return
}

// g_dbus_connection_export_action_group
// container is not nil, container is DBusConnection
// is method
func (v DBusConnection) ExportActionGroup(object_path string, action_group IActionGroup) (result uint32, err error) {
	iv, err := _I.Get(202, "DBusConnection", "export_action_group")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	c_object_path := gi.CString(object_path)
	var tmp unsafe.Pointer
	if action_group != nil {
		tmp = action_group.P_ActionGroup()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_object_path := gi.NewStringArgument(c_object_path)
	arg_action_group := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_object_path, arg_action_group, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	gi.Free(c_object_path)
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Uint32()
	return
}

// g_dbus_connection_export_menu_model
// container is not nil, container is DBusConnection
// is method
func (v DBusConnection) ExportMenuModel(object_path string, menu IMenuModel) (result uint32, err error) {
	iv, err := _I.Get(203, "DBusConnection", "export_menu_model")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	c_object_path := gi.CString(object_path)
	var tmp unsafe.Pointer
	if menu != nil {
		tmp = menu.P_MenuModel()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_object_path := gi.NewStringArgument(c_object_path)
	arg_menu := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_object_path, arg_menu, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	gi.Free(c_object_path)
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Uint32()
	return
}

// g_dbus_connection_flush
// container is not nil, container is DBusConnection
// is method
func (v DBusConnection) Flush(cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(204, "DBusConnection", "flush")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_v, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
}

// g_dbus_connection_flush_finish
// container is not nil, container is DBusConnection
// is method
func (v DBusConnection) FlushFinish(res IAsyncResult) (result bool, err error) {
	iv, err := _I.Get(205, "DBusConnection", "flush_finish")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if res != nil {
		tmp = res.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_res := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_res, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Bool()
	return
}

// g_dbus_connection_flush_sync
// container is not nil, container is DBusConnection
// is method
func (v DBusConnection) FlushSync(cancellable ICancellable) (result bool, err error) {
	iv, err := _I.Get(206, "DBusConnection", "flush_sync")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Bool()
	return
}

// g_dbus_connection_get_capabilities
// container is not nil, container is DBusConnection
// is method
func (v DBusConnection) GetCapabilities() (result DBusCapabilityFlags) {
	iv, err := _I.Get(207, "DBusConnection", "get_capabilities")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = DBusCapabilityFlags(ret.Int())
	return
}

// g_dbus_connection_get_exit_on_close
// container is not nil, container is DBusConnection
// is method
func (v DBusConnection) GetExitOnClose() (result bool) {
	iv, err := _I.Get(208, "DBusConnection", "get_exit_on_close")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_dbus_connection_get_guid
// container is not nil, container is DBusConnection
// is method
func (v DBusConnection) GetGuid() (result string) {
	iv, err := _I.Get(209, "DBusConnection", "get_guid")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Take()
	return
}

// g_dbus_connection_get_last_serial
// container is not nil, container is DBusConnection
// is method
func (v DBusConnection) GetLastSerial() (result uint32) {
	iv, err := _I.Get(210, "DBusConnection", "get_last_serial")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Uint32()
	return
}

// g_dbus_connection_get_peer_credentials
// container is not nil, container is DBusConnection
// is method
func (v DBusConnection) GetPeerCredentials() (result Credentials) {
	iv, err := _I.Get(211, "DBusConnection", "get_peer_credentials")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_dbus_connection_get_stream
// container is not nil, container is DBusConnection
// is method
func (v DBusConnection) GetStream() (result IOStream) {
	iv, err := _I.Get(212, "DBusConnection", "get_stream")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_dbus_connection_get_unique_name
// container is not nil, container is DBusConnection
// is method
func (v DBusConnection) GetUniqueName() (result string) {
	iv, err := _I.Get(213, "DBusConnection", "get_unique_name")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Take()
	return
}

// g_dbus_connection_is_closed
// container is not nil, container is DBusConnection
// is method
func (v DBusConnection) IsClosed() (result bool) {
	iv, err := _I.Get(214, "DBusConnection", "is_closed")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_dbus_connection_register_object_with_closures
// container is not nil, container is DBusConnection
// is method
func (v DBusConnection) RegisterObject(object_path string, interface_info DBusInterfaceInfo, method_call_closure gobject.Closure, get_property_closure gobject.Closure, set_property_closure gobject.Closure) (result uint32, err error) {
	iv, err := _I.Get(215, "DBusConnection", "register_object")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	c_object_path := gi.CString(object_path)
	arg_v := gi.NewPointerArgument(v.P)
	arg_object_path := gi.NewStringArgument(c_object_path)
	arg_interface_info := gi.NewPointerArgument(interface_info.P)
	arg_method_call_closure := gi.NewPointerArgument(method_call_closure.P)
	arg_get_property_closure := gi.NewPointerArgument(get_property_closure.P)
	arg_set_property_closure := gi.NewPointerArgument(set_property_closure.P)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_object_path, arg_interface_info, arg_method_call_closure, arg_get_property_closure, arg_set_property_closure, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	gi.Free(c_object_path)
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Uint32()
	return
}

// g_dbus_connection_register_subtree
// container is not nil, container is DBusConnection
// is method
func (v DBusConnection) RegisterSubtree(object_path string, vtable DBusSubtreeVTable, flags DBusSubtreeFlags, user_data unsafe.Pointer, user_data_free_func int /*TODO_TYPE isPtr: false, tag: interface*/) (result uint32, err error) {
	iv, err := _I.Get(216, "DBusConnection", "register_subtree")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	c_object_path := gi.CString(object_path)
	arg_v := gi.NewPointerArgument(v.P)
	arg_object_path := gi.NewStringArgument(c_object_path)
	arg_vtable := gi.NewPointerArgument(vtable.P)
	arg_flags := gi.NewIntArgument(int(flags))
	arg_user_data := gi.NewPointerArgument(user_data)
	arg_user_data_free_func := gi.NewIntArgument(user_data_free_func) /*TODO*/
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_object_path, arg_vtable, arg_flags, arg_user_data, arg_user_data_free_func, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	gi.Free(c_object_path)
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Uint32()
	return
}

// g_dbus_connection_remove_filter
// container is not nil, container is DBusConnection
// is method
func (v DBusConnection) RemoveFilter(filter_id uint32) {
	iv, err := _I.Get(217, "DBusConnection", "remove_filter")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_filter_id := gi.NewUint32Argument(filter_id)
	args := []gi.Argument{arg_v, arg_filter_id}
	iv.Call(args, nil, nil)
}

// g_dbus_connection_send_message
// container is not nil, container is DBusConnection
// is method
func (v DBusConnection) SendMessage(message IDBusMessage, flags DBusSendMessageFlags) (result bool, out_serial uint32, err error) {
	iv, err := _I.Get(218, "DBusConnection", "send_message")
	if err != nil {
		return
	}
	var outArgs [2]gi.Argument
	var tmp unsafe.Pointer
	if message != nil {
		tmp = message.P_DBusMessage()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_message := gi.NewPointerArgument(tmp)
	arg_flags := gi.NewIntArgument(int(flags))
	arg_out_serial := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[1]))
	args := []gi.Argument{arg_v, arg_message, arg_flags, arg_out_serial, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[1].Pointer())
	out_serial = outArgs[0].Uint32()
	result = ret.Bool()
	return
}

// g_dbus_connection_send_message_with_reply
// container is not nil, container is DBusConnection
// is method
func (v DBusConnection) SendMessageWithReply(message IDBusMessage, flags DBusSendMessageFlags, timeout_msec int32, cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) (out_serial uint32) {
	iv, err := _I.Get(219, "DBusConnection", "send_message_with_reply")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if message != nil {
		tmp = message.P_DBusMessage()
	}
	var tmp1 unsafe.Pointer
	if cancellable != nil {
		tmp1 = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_message := gi.NewPointerArgument(tmp)
	arg_flags := gi.NewIntArgument(int(flags))
	arg_timeout_msec := gi.NewInt32Argument(timeout_msec)
	arg_out_serial := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	arg_cancellable := gi.NewPointerArgument(tmp1)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_v, arg_message, arg_flags, arg_timeout_msec, arg_out_serial, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, &outArgs[0])
	out_serial = outArgs[0].Uint32()
	return
}

// g_dbus_connection_send_message_with_reply_finish
// container is not nil, container is DBusConnection
// is method
func (v DBusConnection) SendMessageWithReplyFinish(res IAsyncResult) (result DBusMessage, err error) {
	iv, err := _I.Get(220, "DBusConnection", "send_message_with_reply_finish")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if res != nil {
		tmp = res.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_res := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_res, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// g_dbus_connection_send_message_with_reply_sync
// container is not nil, container is DBusConnection
// is method
func (v DBusConnection) SendMessageWithReplySync(message IDBusMessage, flags DBusSendMessageFlags, timeout_msec int32, cancellable ICancellable) (result DBusMessage, out_serial uint32, err error) {
	iv, err := _I.Get(221, "DBusConnection", "send_message_with_reply_sync")
	if err != nil {
		return
	}
	var outArgs [2]gi.Argument
	var tmp unsafe.Pointer
	if message != nil {
		tmp = message.P_DBusMessage()
	}
	var tmp1 unsafe.Pointer
	if cancellable != nil {
		tmp1 = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_message := gi.NewPointerArgument(tmp)
	arg_flags := gi.NewIntArgument(int(flags))
	arg_timeout_msec := gi.NewInt32Argument(timeout_msec)
	arg_out_serial := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	arg_cancellable := gi.NewPointerArgument(tmp1)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[1]))
	args := []gi.Argument{arg_v, arg_message, arg_flags, arg_timeout_msec, arg_out_serial, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[1].Pointer())
	out_serial = outArgs[0].Uint32()
	result.P = ret.Pointer()
	return
}

// g_dbus_connection_set_exit_on_close
// container is not nil, container is DBusConnection
// is method
func (v DBusConnection) SetExitOnClose(exit_on_close bool) {
	iv, err := _I.Get(222, "DBusConnection", "set_exit_on_close")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_exit_on_close := gi.NewBoolArgument(exit_on_close)
	args := []gi.Argument{arg_v, arg_exit_on_close}
	iv.Call(args, nil, nil)
}

// g_dbus_connection_signal_subscribe
// container is not nil, container is DBusConnection
// is method
func (v DBusConnection) SignalSubscribe(sender string, interface_name string, member string, object_path string, arg0 string, flags DBusSignalFlags, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer, user_data_free_func int /*TODO_TYPE isPtr: false, tag: interface*/) (result uint32) {
	iv, err := _I.Get(223, "DBusConnection", "signal_subscribe")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_sender := gi.CString(sender)
	c_interface_name := gi.CString(interface_name)
	c_member := gi.CString(member)
	c_object_path := gi.CString(object_path)
	c_arg0 := gi.CString(arg0)
	arg_v := gi.NewPointerArgument(v.P)
	arg_sender := gi.NewStringArgument(c_sender)
	arg_interface_name := gi.NewStringArgument(c_interface_name)
	arg_member := gi.NewStringArgument(c_member)
	arg_object_path := gi.NewStringArgument(c_object_path)
	arg_arg0 := gi.NewStringArgument(c_arg0)
	arg_flags := gi.NewIntArgument(int(flags))
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	arg_user_data_free_func := gi.NewIntArgument(user_data_free_func) /*TODO*/
	args := []gi.Argument{arg_v, arg_sender, arg_interface_name, arg_member, arg_object_path, arg_arg0, arg_flags, arg_callback, arg_user_data, arg_user_data_free_func}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_sender)
	gi.Free(c_interface_name)
	gi.Free(c_member)
	gi.Free(c_object_path)
	gi.Free(c_arg0)
	result = ret.Uint32()
	return
}

// g_dbus_connection_signal_unsubscribe
// container is not nil, container is DBusConnection
// is method
func (v DBusConnection) SignalUnsubscribe(subscription_id uint32) {
	iv, err := _I.Get(224, "DBusConnection", "signal_unsubscribe")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_subscription_id := gi.NewUint32Argument(subscription_id)
	args := []gi.Argument{arg_v, arg_subscription_id}
	iv.Call(args, nil, nil)
}

// g_dbus_connection_start_message_processing
// container is not nil, container is DBusConnection
// is method
func (v DBusConnection) StartMessageProcessing() {
	iv, err := _I.Get(225, "DBusConnection", "start_message_processing")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	iv.Call(args, nil, nil)
}

// g_dbus_connection_unexport_action_group
// container is not nil, container is DBusConnection
// is method
func (v DBusConnection) UnexportActionGroup(export_id uint32) {
	iv, err := _I.Get(226, "DBusConnection", "unexport_action_group")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_export_id := gi.NewUint32Argument(export_id)
	args := []gi.Argument{arg_v, arg_export_id}
	iv.Call(args, nil, nil)
}

// g_dbus_connection_unexport_menu_model
// container is not nil, container is DBusConnection
// is method
func (v DBusConnection) UnexportMenuModel(export_id uint32) {
	iv, err := _I.Get(227, "DBusConnection", "unexport_menu_model")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_export_id := gi.NewUint32Argument(export_id)
	args := []gi.Argument{arg_v, arg_export_id}
	iv.Call(args, nil, nil)
}

// g_dbus_connection_unregister_object
// container is not nil, container is DBusConnection
// is method
func (v DBusConnection) UnregisterObject(registration_id uint32) (result bool) {
	iv, err := _I.Get(228, "DBusConnection", "unregister_object")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_registration_id := gi.NewUint32Argument(registration_id)
	args := []gi.Argument{arg_v, arg_registration_id}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_dbus_connection_unregister_subtree
// container is not nil, container is DBusConnection
// is method
func (v DBusConnection) UnregisterSubtree(registration_id uint32) (result bool) {
	iv, err := _I.Get(229, "DBusConnection", "unregister_subtree")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_registration_id := gi.NewUint32Argument(registration_id)
	args := []gi.Argument{arg_v, arg_registration_id}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// Flags DBusConnectionFlags
type DBusConnectionFlags int

const (
	DBusConnectionFlagsNone                         DBusConnectionFlags = 0
	DBusConnectionFlagsAuthenticationClient         DBusConnectionFlags = 1
	DBusConnectionFlagsAuthenticationServer         DBusConnectionFlags = 2
	DBusConnectionFlagsAuthenticationAllowAnonymous DBusConnectionFlags = 4
	DBusConnectionFlagsMessageBusConnection         DBusConnectionFlags = 8
	DBusConnectionFlagsDelayMessageProcessing       DBusConnectionFlags = 16
)

func DBusConnectionFlagsGetType() gi.GType {
	ret := _I.GetGType(44, "DBusConnectionFlags")
	return ret
}

// Enum DBusError
type DBusErrorEnum int

const (
	DBusErrorFailed                        DBusErrorEnum = 0
	DBusErrorNoMemory                      DBusErrorEnum = 1
	DBusErrorServiceUnknown                DBusErrorEnum = 2
	DBusErrorNameHasNoOwner                DBusErrorEnum = 3
	DBusErrorNoReply                       DBusErrorEnum = 4
	DBusErrorIoError                       DBusErrorEnum = 5
	DBusErrorBadAddress                    DBusErrorEnum = 6
	DBusErrorNotSupported                  DBusErrorEnum = 7
	DBusErrorLimitsExceeded                DBusErrorEnum = 8
	DBusErrorAccessDenied                  DBusErrorEnum = 9
	DBusErrorAuthFailed                    DBusErrorEnum = 10
	DBusErrorNoServer                      DBusErrorEnum = 11
	DBusErrorTimeout                       DBusErrorEnum = 12
	DBusErrorNoNetwork                     DBusErrorEnum = 13
	DBusErrorAddressInUse                  DBusErrorEnum = 14
	DBusErrorDisconnected                  DBusErrorEnum = 15
	DBusErrorInvalidArgs                   DBusErrorEnum = 16
	DBusErrorFileNotFound                  DBusErrorEnum = 17
	DBusErrorFileExists                    DBusErrorEnum = 18
	DBusErrorUnknownMethod                 DBusErrorEnum = 19
	DBusErrorTimedOut                      DBusErrorEnum = 20
	DBusErrorMatchRuleNotFound             DBusErrorEnum = 21
	DBusErrorMatchRuleInvalid              DBusErrorEnum = 22
	DBusErrorSpawnExecFailed               DBusErrorEnum = 23
	DBusErrorSpawnForkFailed               DBusErrorEnum = 24
	DBusErrorSpawnChildExited              DBusErrorEnum = 25
	DBusErrorSpawnChildSignaled            DBusErrorEnum = 26
	DBusErrorSpawnFailed                   DBusErrorEnum = 27
	DBusErrorSpawnSetupFailed              DBusErrorEnum = 28
	DBusErrorSpawnConfigInvalid            DBusErrorEnum = 29
	DBusErrorSpawnServiceInvalid           DBusErrorEnum = 30
	DBusErrorSpawnServiceNotFound          DBusErrorEnum = 31
	DBusErrorSpawnPermissionsInvalid       DBusErrorEnum = 32
	DBusErrorSpawnFileInvalid              DBusErrorEnum = 33
	DBusErrorSpawnNoMemory                 DBusErrorEnum = 34
	DBusErrorUnixProcessIdUnknown          DBusErrorEnum = 35
	DBusErrorInvalidSignature              DBusErrorEnum = 36
	DBusErrorInvalidFileContent            DBusErrorEnum = 37
	DBusErrorSelinuxSecurityContextUnknown DBusErrorEnum = 38
	DBusErrorAdtAuditDataUnknown           DBusErrorEnum = 39
	DBusErrorObjectPathInUse               DBusErrorEnum = 40
	DBusErrorUnknownObject                 DBusErrorEnum = 41
	DBusErrorUnknownInterface              DBusErrorEnum = 42
	DBusErrorUnknownProperty               DBusErrorEnum = 43
	DBusErrorPropertyReadOnly              DBusErrorEnum = 44
)

func DBusErrorGetType() gi.GType {
	ret := _I.GetGType(45, "DBusError")
	return ret
}

// Struct DBusErrorEntry
type DBusErrorEntry struct {
	P unsafe.Pointer
}

const SizeOfStructDBusErrorEntry = 16

func DBusErrorEntryGetType() gi.GType {
	ret := _I.GetGType(46, "DBusErrorEntry")
	return ret
}

// Interface DBusInterface
type DBusInterface struct {
	DBusInterfaceIfc
	P unsafe.Pointer
}
type DBusInterfaceIfc struct{}
type IDBusInterface interface{ P_DBusInterface() unsafe.Pointer }

func (v DBusInterface) P_DBusInterface() unsafe.Pointer { return v.P }
func DBusInterfaceGetType() gi.GType {
	ret := _I.GetGType(47, "DBusInterface")
	return ret
}

// g_dbus_interface_dup_object
// container is not nil, container is DBusInterface
// is method
func (v *DBusInterfaceIfc) GetObject() (result DBusObject) {
	iv, err := _I.Get(230, "DBusInterface", "get_object")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_dbus_interface_get_info
// container is not nil, container is DBusInterface
// is method
func (v *DBusInterfaceIfc) GetInfo() (result DBusInterfaceInfo) {
	iv, err := _I.Get(231, "DBusInterface", "get_info")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_dbus_interface_set_object
// container is not nil, container is DBusInterface
// is method
func (v *DBusInterfaceIfc) SetObject(object IDBusObject) {
	iv, err := _I.Get(232, "DBusInterface", "set_object")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if object != nil {
		tmp = object.P_DBusObject()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_object := gi.NewPointerArgument(tmp)
	args := []gi.Argument{arg_v, arg_object}
	iv.Call(args, nil, nil)
}

type DBusInterfaceGetPropertyFuncStruct struct {
	F_connection     DBusConnection
	F_sender         string
	F_object_path    string
	F_interface_name string
	F_property_name  string
	F_error          unsafe.Pointer
}

//export myDBusInterfaceGetPropertyFunc
func myDBusInterfaceGetPropertyFunc(connection *C.GDBusConnection, sender *C.gchar, object_path *C.gchar, interface_name *C.gchar, property_name *C.gchar, error **C.GError, user_data C.gpointer) {
	fn := gi.GetFunc(uint(uintptr(user_data)))
	args := DBusInterfaceGetPropertyFuncStruct{
		F_connection:     WrapDBusConnection(unsafe.Pointer(connection)),
		F_sender:         gi.GoString(unsafe.Pointer(sender)),
		F_object_path:    gi.GoString(unsafe.Pointer(object_path)),
		F_interface_name: gi.GoString(unsafe.Pointer(interface_name)),
		F_property_name:  gi.GoString(unsafe.Pointer(property_name)),
		F_error:          unsafe.Pointer(error),
	}
	fn(args)
}

// ignore GType struct DBusInterfaceIface
// Struct DBusInterfaceInfo
type DBusInterfaceInfo struct {
	P unsafe.Pointer
}

const SizeOfStructDBusInterfaceInfo = 48

func DBusInterfaceInfoGetType() gi.GType {
	ret := _I.GetGType(48, "DBusInterfaceInfo")
	return ret
}

// g_dbus_interface_info_cache_build
// container is not nil, container is DBusInterfaceInfo
// is method
func (v DBusInterfaceInfo) CacheBuild() {
	iv, err := _I.Get(233, "DBusInterfaceInfo", "cache_build")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	iv.Call(args, nil, nil)
}

// g_dbus_interface_info_cache_release
// container is not nil, container is DBusInterfaceInfo
// is method
func (v DBusInterfaceInfo) CacheRelease() {
	iv, err := _I.Get(234, "DBusInterfaceInfo", "cache_release")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	iv.Call(args, nil, nil)
}

// g_dbus_interface_info_generate_xml
// container is not nil, container is DBusInterfaceInfo
// is method
func (v DBusInterfaceInfo) GenerateXml(indent uint32, string_builder glib.String) {
	iv, err := _I.Get(235, "DBusInterfaceInfo", "generate_xml")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_indent := gi.NewUint32Argument(indent)
	arg_string_builder := gi.NewPointerArgument(string_builder.P)
	args := []gi.Argument{arg_v, arg_indent, arg_string_builder}
	iv.Call(args, nil, nil)
}

// g_dbus_interface_info_lookup_method
// container is not nil, container is DBusInterfaceInfo
// is method
func (v DBusInterfaceInfo) LookupMethod(name string) (result DBusMethodInfo) {
	iv, err := _I.Get(236, "DBusInterfaceInfo", "lookup_method")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_name := gi.CString(name)
	arg_v := gi.NewPointerArgument(v.P)
	arg_name := gi.NewStringArgument(c_name)
	args := []gi.Argument{arg_v, arg_name}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_name)
	result.P = ret.Pointer()
	return
}

// g_dbus_interface_info_lookup_property
// container is not nil, container is DBusInterfaceInfo
// is method
func (v DBusInterfaceInfo) LookupProperty(name string) (result DBusPropertyInfo) {
	iv, err := _I.Get(237, "DBusInterfaceInfo", "lookup_property")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_name := gi.CString(name)
	arg_v := gi.NewPointerArgument(v.P)
	arg_name := gi.NewStringArgument(c_name)
	args := []gi.Argument{arg_v, arg_name}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_name)
	result.P = ret.Pointer()
	return
}

// g_dbus_interface_info_lookup_signal
// container is not nil, container is DBusInterfaceInfo
// is method
func (v DBusInterfaceInfo) LookupSignal(name string) (result DBusSignalInfo) {
	iv, err := _I.Get(238, "DBusInterfaceInfo", "lookup_signal")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_name := gi.CString(name)
	arg_v := gi.NewPointerArgument(v.P)
	arg_name := gi.NewStringArgument(c_name)
	args := []gi.Argument{arg_v, arg_name}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_name)
	result.P = ret.Pointer()
	return
}

// g_dbus_interface_info_ref
// container is not nil, container is DBusInterfaceInfo
// is method
func (v DBusInterfaceInfo) Ref() (result DBusInterfaceInfo) {
	iv, err := _I.Get(239, "DBusInterfaceInfo", "ref")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_dbus_interface_info_unref
// container is not nil, container is DBusInterfaceInfo
// is method
func (v DBusInterfaceInfo) Unref() {
	iv, err := _I.Get(240, "DBusInterfaceInfo", "unref")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	iv.Call(args, nil, nil)
}

type DBusInterfaceMethodCallFuncStruct struct {
	F_connection     DBusConnection
	F_sender         string
	F_object_path    string
	F_interface_name string
	F_method_name    string
	F_parameters     glib.Variant
	F_invocation     DBusMethodInvocation
}

//export myDBusInterfaceMethodCallFunc
func myDBusInterfaceMethodCallFunc(connection *C.GDBusConnection, sender *C.gchar, object_path *C.gchar, interface_name *C.gchar, method_name *C.gchar, parameters *C.GVariant, invocation *C.GDBusMethodInvocation, user_data C.gpointer) {
	fn := gi.GetFunc(uint(uintptr(user_data)))
	args := DBusInterfaceMethodCallFuncStruct{
		F_connection:     WrapDBusConnection(unsafe.Pointer(connection)),
		F_sender:         gi.GoString(unsafe.Pointer(sender)),
		F_object_path:    gi.GoString(unsafe.Pointer(object_path)),
		F_interface_name: gi.GoString(unsafe.Pointer(interface_name)),
		F_method_name:    gi.GoString(unsafe.Pointer(method_name)),
		F_parameters:     glib.Variant{P: unsafe.Pointer(parameters)},
		F_invocation:     WrapDBusMethodInvocation(unsafe.Pointer(invocation)),
	}
	fn(args)
}

type DBusInterfaceSetPropertyFuncStruct struct {
	F_connection     DBusConnection
	F_sender         string
	F_object_path    string
	F_interface_name string
	F_property_name  string
	F_value          glib.Variant
	F_error          unsafe.Pointer
}

//export myDBusInterfaceSetPropertyFunc
func myDBusInterfaceSetPropertyFunc(connection *C.GDBusConnection, sender *C.gchar, object_path *C.gchar, interface_name *C.gchar, property_name *C.gchar, value *C.GVariant, error **C.GError, user_data C.gpointer) {
	fn := gi.GetFunc(uint(uintptr(user_data)))
	args := DBusInterfaceSetPropertyFuncStruct{
		F_connection:     WrapDBusConnection(unsafe.Pointer(connection)),
		F_sender:         gi.GoString(unsafe.Pointer(sender)),
		F_object_path:    gi.GoString(unsafe.Pointer(object_path)),
		F_interface_name: gi.GoString(unsafe.Pointer(interface_name)),
		F_property_name:  gi.GoString(unsafe.Pointer(property_name)),
		F_value:          glib.Variant{P: unsafe.Pointer(value)},
		F_error:          unsafe.Pointer(error),
	}
	fn(args)
}

// Object DBusInterfaceSkeleton
type DBusInterfaceSkeleton struct {
	DBusInterfaceIfc
	gobject.Object
}

func WrapDBusInterfaceSkeleton(p unsafe.Pointer) (r DBusInterfaceSkeleton) { r.P = p; return }

type IDBusInterfaceSkeleton interface{ P_DBusInterfaceSkeleton() unsafe.Pointer }

func (v DBusInterfaceSkeleton) P_DBusInterfaceSkeleton() unsafe.Pointer { return v.P }
func (v DBusInterfaceSkeleton) P_DBusInterface() unsafe.Pointer         { return v.P }
func DBusInterfaceSkeletonGetType() gi.GType {
	ret := _I.GetGType(49, "DBusInterfaceSkeleton")
	return ret
}

// g_dbus_interface_skeleton_export
// container is not nil, container is DBusInterfaceSkeleton
// is method
func (v DBusInterfaceSkeleton) Export(connection IDBusConnection, object_path string) (result bool, err error) {
	iv, err := _I.Get(241, "DBusInterfaceSkeleton", "export")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if connection != nil {
		tmp = connection.P_DBusConnection()
	}
	c_object_path := gi.CString(object_path)
	arg_v := gi.NewPointerArgument(v.P)
	arg_connection := gi.NewPointerArgument(tmp)
	arg_object_path := gi.NewStringArgument(c_object_path)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_connection, arg_object_path, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	gi.Free(c_object_path)
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Bool()
	return
}

// g_dbus_interface_skeleton_flush
// container is not nil, container is DBusInterfaceSkeleton
// is method
func (v DBusInterfaceSkeleton) Flush() {
	iv, err := _I.Get(242, "DBusInterfaceSkeleton", "flush")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	iv.Call(args, nil, nil)
}

// g_dbus_interface_skeleton_get_connection
// container is not nil, container is DBusInterfaceSkeleton
// is method
func (v DBusInterfaceSkeleton) GetConnection() (result DBusConnection) {
	iv, err := _I.Get(243, "DBusInterfaceSkeleton", "get_connection")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_dbus_interface_skeleton_get_connections
// container is not nil, container is DBusInterfaceSkeleton
// is method
func (v DBusInterfaceSkeleton) GetConnections() (result glib.List) {
	iv, err := _I.Get(244, "DBusInterfaceSkeleton", "get_connections")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_dbus_interface_skeleton_get_flags
// container is not nil, container is DBusInterfaceSkeleton
// is method
func (v DBusInterfaceSkeleton) GetFlags() (result DBusInterfaceSkeletonFlags) {
	iv, err := _I.Get(245, "DBusInterfaceSkeleton", "get_flags")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = DBusInterfaceSkeletonFlags(ret.Int())
	return
}

// g_dbus_interface_skeleton_get_info
// container is not nil, container is DBusInterfaceSkeleton
// is method
func (v DBusInterfaceSkeleton) GetInfo() (result DBusInterfaceInfo) {
	iv, err := _I.Get(246, "DBusInterfaceSkeleton", "get_info")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_dbus_interface_skeleton_get_object_path
// container is not nil, container is DBusInterfaceSkeleton
// is method
func (v DBusInterfaceSkeleton) GetObjectPath() (result string) {
	iv, err := _I.Get(247, "DBusInterfaceSkeleton", "get_object_path")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Take()
	return
}

// g_dbus_interface_skeleton_get_properties
// container is not nil, container is DBusInterfaceSkeleton
// is method
func (v DBusInterfaceSkeleton) GetProperties() (result glib.Variant) {
	iv, err := _I.Get(248, "DBusInterfaceSkeleton", "get_properties")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_dbus_interface_skeleton_has_connection
// container is not nil, container is DBusInterfaceSkeleton
// is method
func (v DBusInterfaceSkeleton) HasConnection(connection IDBusConnection) (result bool) {
	iv, err := _I.Get(249, "DBusInterfaceSkeleton", "has_connection")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if connection != nil {
		tmp = connection.P_DBusConnection()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_connection := gi.NewPointerArgument(tmp)
	args := []gi.Argument{arg_v, arg_connection}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_dbus_interface_skeleton_set_flags
// container is not nil, container is DBusInterfaceSkeleton
// is method
func (v DBusInterfaceSkeleton) SetFlags(flags DBusInterfaceSkeletonFlags) {
	iv, err := _I.Get(250, "DBusInterfaceSkeleton", "set_flags")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_flags := gi.NewIntArgument(int(flags))
	args := []gi.Argument{arg_v, arg_flags}
	iv.Call(args, nil, nil)
}

// g_dbus_interface_skeleton_unexport
// container is not nil, container is DBusInterfaceSkeleton
// is method
func (v DBusInterfaceSkeleton) Unexport() {
	iv, err := _I.Get(251, "DBusInterfaceSkeleton", "unexport")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	iv.Call(args, nil, nil)
}

// g_dbus_interface_skeleton_unexport_from_connection
// container is not nil, container is DBusInterfaceSkeleton
// is method
func (v DBusInterfaceSkeleton) UnexportFromConnection(connection IDBusConnection) {
	iv, err := _I.Get(252, "DBusInterfaceSkeleton", "unexport_from_connection")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if connection != nil {
		tmp = connection.P_DBusConnection()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_connection := gi.NewPointerArgument(tmp)
	args := []gi.Argument{arg_v, arg_connection}
	iv.Call(args, nil, nil)
}

// ignore GType struct DBusInterfaceSkeletonClass
// Flags DBusInterfaceSkeletonFlags
type DBusInterfaceSkeletonFlags int

const (
	DBusInterfaceSkeletonFlagsNone                            DBusInterfaceSkeletonFlags = 0
	DBusInterfaceSkeletonFlagsHandleMethodInvocationsInThread DBusInterfaceSkeletonFlags = 1
)

func DBusInterfaceSkeletonFlagsGetType() gi.GType {
	ret := _I.GetGType(50, "DBusInterfaceSkeletonFlags")
	return ret
}

// Struct DBusInterfaceSkeletonPrivate
type DBusInterfaceSkeletonPrivate struct {
	P unsafe.Pointer
}

func DBusInterfaceSkeletonPrivateGetType() gi.GType {
	ret := _I.GetGType(51, "DBusInterfaceSkeletonPrivate")
	return ret
}

// Struct DBusInterfaceVTable
type DBusInterfaceVTable struct {
	P unsafe.Pointer
}

const SizeOfStructDBusInterfaceVTable = 88

func DBusInterfaceVTableGetType() gi.GType {
	ret := _I.GetGType(52, "DBusInterfaceVTable")
	return ret
}

// Object DBusMenuModel
type DBusMenuModel struct {
	MenuModel
}

func WrapDBusMenuModel(p unsafe.Pointer) (r DBusMenuModel) { r.P = p; return }

type IDBusMenuModel interface{ P_DBusMenuModel() unsafe.Pointer }

func (v DBusMenuModel) P_DBusMenuModel() unsafe.Pointer { return v.P }
func DBusMenuModelGetType() gi.GType {
	ret := _I.GetGType(53, "DBusMenuModel")
	return ret
}

// g_dbus_menu_model_get
// container is not nil, container is DBusMenuModel
// is method
// arg0Type tag: interface, isPtr: true
func DBusMenuModelGet1(connection IDBusConnection, bus_name string, object_path string) (result DBusMenuModel) {
	iv, err := _I.Get(253, "DBusMenuModel", "get")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if connection != nil {
		tmp = connection.P_DBusConnection()
	}
	c_bus_name := gi.CString(bus_name)
	c_object_path := gi.CString(object_path)
	arg_connection := gi.NewPointerArgument(tmp)
	arg_bus_name := gi.NewStringArgument(c_bus_name)
	arg_object_path := gi.NewStringArgument(c_object_path)
	args := []gi.Argument{arg_connection, arg_bus_name, arg_object_path}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_bus_name)
	gi.Free(c_object_path)
	result.P = ret.Pointer()
	return
}

// Object DBusMessage
type DBusMessage struct {
	gobject.Object
}

func WrapDBusMessage(p unsafe.Pointer) (r DBusMessage) { r.P = p; return }

type IDBusMessage interface{ P_DBusMessage() unsafe.Pointer }

func (v DBusMessage) P_DBusMessage() unsafe.Pointer { return v.P }
func DBusMessageGetType() gi.GType {
	ret := _I.GetGType(54, "DBusMessage")
	return ret
}

// g_dbus_message_new
// container is not nil, container is DBusMessage
// is constructor
func NewDBusMessage() (result DBusMessage) {
	iv, err := _I.Get(254, "DBusMessage", "new")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var ret gi.Argument
	iv.Call(nil, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_dbus_message_new_from_blob
// container is not nil, container is DBusMessage
// is constructor
// arg 0 blob lenArgIdx 1
func NewDBusMessageFromBlob(blob gi.Uint8Array, blob_len uint64, capabilities DBusCapabilityFlags) (result DBusMessage, err error) {
	iv, err := _I.Get(255, "DBusMessage", "new_from_blob")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	arg_blob := gi.NewPointerArgument(blob.P)
	arg_blob_len := gi.NewUint64Argument(blob_len)
	arg_capabilities := gi.NewIntArgument(int(capabilities))
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_blob, arg_blob_len, arg_capabilities, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// g_dbus_message_new_method_call
// container is not nil, container is DBusMessage
// is constructor
func NewDBusMessageMethodCall(name string, path string, interface_ string, method string) (result DBusMessage) {
	iv, err := _I.Get(256, "DBusMessage", "new_method_call")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_name := gi.CString(name)
	c_path := gi.CString(path)
	c_interface_ := gi.CString(interface_)
	c_method := gi.CString(method)
	arg_name := gi.NewStringArgument(c_name)
	arg_path := gi.NewStringArgument(c_path)
	arg_interface_ := gi.NewStringArgument(c_interface_)
	arg_method := gi.NewStringArgument(c_method)
	args := []gi.Argument{arg_name, arg_path, arg_interface_, arg_method}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_name)
	gi.Free(c_path)
	gi.Free(c_interface_)
	gi.Free(c_method)
	result.P = ret.Pointer()
	return
}

// g_dbus_message_new_signal
// container is not nil, container is DBusMessage
// is constructor
func NewDBusMessageSignal(path string, interface_ string, signal string) (result DBusMessage) {
	iv, err := _I.Get(257, "DBusMessage", "new_signal")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_path := gi.CString(path)
	c_interface_ := gi.CString(interface_)
	c_signal := gi.CString(signal)
	arg_path := gi.NewStringArgument(c_path)
	arg_interface_ := gi.NewStringArgument(c_interface_)
	arg_signal := gi.NewStringArgument(c_signal)
	args := []gi.Argument{arg_path, arg_interface_, arg_signal}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_path)
	gi.Free(c_interface_)
	gi.Free(c_signal)
	result.P = ret.Pointer()
	return
}

// g_dbus_message_bytes_needed
// container is not nil, container is DBusMessage
// is method
// arg0Type tag: array, isPtr: true
// arg 0 blob lenArgIdx 1
func DBusMessageBytesNeeded1(blob gi.Uint8Array, blob_len uint64) (result int64, err error) {
	iv, err := _I.Get(258, "DBusMessage", "bytes_needed")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	arg_blob := gi.NewPointerArgument(blob.P)
	arg_blob_len := gi.NewUint64Argument(blob_len)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_blob, arg_blob_len, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Int64()
	return
}

// g_dbus_message_copy
// container is not nil, container is DBusMessage
// is method
func (v DBusMessage) Copy() (result DBusMessage, err error) {
	iv, err := _I.Get(259, "DBusMessage", "copy")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	arg_v := gi.NewPointerArgument(v.P)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// g_dbus_message_get_arg0
// container is not nil, container is DBusMessage
// is method
func (v DBusMessage) GetArg0() (result string) {
	iv, err := _I.Get(260, "DBusMessage", "get_arg0")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Take()
	return
}

// g_dbus_message_get_body
// container is not nil, container is DBusMessage
// is method
func (v DBusMessage) GetBody() (result glib.Variant) {
	iv, err := _I.Get(261, "DBusMessage", "get_body")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_dbus_message_get_byte_order
// container is not nil, container is DBusMessage
// is method
func (v DBusMessage) GetByteOrder() (result DBusMessageByteOrderEnum) {
	iv, err := _I.Get(262, "DBusMessage", "get_byte_order")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = DBusMessageByteOrderEnum(ret.Int())
	return
}

// g_dbus_message_get_destination
// container is not nil, container is DBusMessage
// is method
func (v DBusMessage) GetDestination() (result string) {
	iv, err := _I.Get(263, "DBusMessage", "get_destination")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Take()
	return
}

// g_dbus_message_get_error_name
// container is not nil, container is DBusMessage
// is method
func (v DBusMessage) GetErrorName() (result string) {
	iv, err := _I.Get(264, "DBusMessage", "get_error_name")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Take()
	return
}

// g_dbus_message_get_flags
// container is not nil, container is DBusMessage
// is method
func (v DBusMessage) GetFlags() (result DBusMessageFlags) {
	iv, err := _I.Get(265, "DBusMessage", "get_flags")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = DBusMessageFlags(ret.Int())
	return
}

// g_dbus_message_get_header
// container is not nil, container is DBusMessage
// is method
func (v DBusMessage) GetHeader(header_field DBusMessageHeaderFieldEnum) (result glib.Variant) {
	iv, err := _I.Get(266, "DBusMessage", "get_header")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_header_field := gi.NewIntArgument(int(header_field))
	args := []gi.Argument{arg_v, arg_header_field}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_dbus_message_get_header_fields
// container is not nil, container is DBusMessage
// is method
func (v DBusMessage) GetHeaderFields() (result gi.Uint8Array) {
	iv, err := _I.Get(267, "DBusMessage", "get_header_fields")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = gi.Uint8Array{P: ret.Pointer(), Len: int(0)}
	return
}

// g_dbus_message_get_interface
// container is not nil, container is DBusMessage
// is method
func (v DBusMessage) GetInterface() (result string) {
	iv, err := _I.Get(268, "DBusMessage", "get_interface")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Take()
	return
}

// g_dbus_message_get_locked
// container is not nil, container is DBusMessage
// is method
func (v DBusMessage) GetLocked() (result bool) {
	iv, err := _I.Get(269, "DBusMessage", "get_locked")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_dbus_message_get_member
// container is not nil, container is DBusMessage
// is method
func (v DBusMessage) GetMember() (result string) {
	iv, err := _I.Get(270, "DBusMessage", "get_member")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Take()
	return
}

// g_dbus_message_get_message_type
// container is not nil, container is DBusMessage
// is method
func (v DBusMessage) GetMessageType() (result DBusMessageTypeEnum) {
	iv, err := _I.Get(271, "DBusMessage", "get_message_type")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = DBusMessageTypeEnum(ret.Int())
	return
}

// g_dbus_message_get_num_unix_fds
// container is not nil, container is DBusMessage
// is method
func (v DBusMessage) GetNumUnixFds() (result uint32) {
	iv, err := _I.Get(272, "DBusMessage", "get_num_unix_fds")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Uint32()
	return
}

// g_dbus_message_get_path
// container is not nil, container is DBusMessage
// is method
func (v DBusMessage) GetPath() (result string) {
	iv, err := _I.Get(273, "DBusMessage", "get_path")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Take()
	return
}

// g_dbus_message_get_reply_serial
// container is not nil, container is DBusMessage
// is method
func (v DBusMessage) GetReplySerial() (result uint32) {
	iv, err := _I.Get(274, "DBusMessage", "get_reply_serial")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Uint32()
	return
}

// g_dbus_message_get_sender
// container is not nil, container is DBusMessage
// is method
func (v DBusMessage) GetSender() (result string) {
	iv, err := _I.Get(275, "DBusMessage", "get_sender")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Take()
	return
}

// g_dbus_message_get_serial
// container is not nil, container is DBusMessage
// is method
func (v DBusMessage) GetSerial() (result uint32) {
	iv, err := _I.Get(276, "DBusMessage", "get_serial")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Uint32()
	return
}

// g_dbus_message_get_signature
// container is not nil, container is DBusMessage
// is method
func (v DBusMessage) GetSignature() (result string) {
	iv, err := _I.Get(277, "DBusMessage", "get_signature")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Take()
	return
}

// g_dbus_message_get_unix_fd_list
// container is not nil, container is DBusMessage
// is method
func (v DBusMessage) GetUnixFdList() (result UnixFDList) {
	iv, err := _I.Get(278, "DBusMessage", "get_unix_fd_list")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_dbus_message_lock
// container is not nil, container is DBusMessage
// is method
func (v DBusMessage) Lock() {
	iv, err := _I.Get(279, "DBusMessage", "lock")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	iv.Call(args, nil, nil)
}

// g_dbus_message_new_method_error_literal
// container is not nil, container is DBusMessage
// is method
func (v DBusMessage) NewMethodErrorLiteral(error_name string, error_message string) (result DBusMessage) {
	iv, err := _I.Get(280, "DBusMessage", "new_method_error_literal")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_error_name := gi.CString(error_name)
	c_error_message := gi.CString(error_message)
	arg_v := gi.NewPointerArgument(v.P)
	arg_error_name := gi.NewStringArgument(c_error_name)
	arg_error_message := gi.NewStringArgument(c_error_message)
	args := []gi.Argument{arg_v, arg_error_name, arg_error_message}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_error_name)
	gi.Free(c_error_message)
	result.P = ret.Pointer()
	return
}

// g_dbus_message_new_method_reply
// container is not nil, container is DBusMessage
// is method
func (v DBusMessage) NewMethodReply() (result DBusMessage) {
	iv, err := _I.Get(281, "DBusMessage", "new_method_reply")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_dbus_message_print
// container is not nil, container is DBusMessage
// is method
func (v DBusMessage) Print(indent uint32) (result string) {
	iv, err := _I.Get(282, "DBusMessage", "print")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_indent := gi.NewUint32Argument(indent)
	args := []gi.Argument{arg_v, arg_indent}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Take()
	return
}

// g_dbus_message_set_body
// container is not nil, container is DBusMessage
// is method
func (v DBusMessage) SetBody(body glib.Variant) {
	iv, err := _I.Get(283, "DBusMessage", "set_body")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_body := gi.NewPointerArgument(body.P)
	args := []gi.Argument{arg_v, arg_body}
	iv.Call(args, nil, nil)
}

// g_dbus_message_set_byte_order
// container is not nil, container is DBusMessage
// is method
func (v DBusMessage) SetByteOrder(byte_order DBusMessageByteOrderEnum) {
	iv, err := _I.Get(284, "DBusMessage", "set_byte_order")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_byte_order := gi.NewIntArgument(int(byte_order))
	args := []gi.Argument{arg_v, arg_byte_order}
	iv.Call(args, nil, nil)
}

// g_dbus_message_set_destination
// container is not nil, container is DBusMessage
// is method
func (v DBusMessage) SetDestination(value string) {
	iv, err := _I.Get(285, "DBusMessage", "set_destination")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_value := gi.CString(value)
	arg_v := gi.NewPointerArgument(v.P)
	arg_value := gi.NewStringArgument(c_value)
	args := []gi.Argument{arg_v, arg_value}
	iv.Call(args, nil, nil)
	gi.Free(c_value)
}

// g_dbus_message_set_error_name
// container is not nil, container is DBusMessage
// is method
func (v DBusMessage) SetErrorName(value string) {
	iv, err := _I.Get(286, "DBusMessage", "set_error_name")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_value := gi.CString(value)
	arg_v := gi.NewPointerArgument(v.P)
	arg_value := gi.NewStringArgument(c_value)
	args := []gi.Argument{arg_v, arg_value}
	iv.Call(args, nil, nil)
	gi.Free(c_value)
}

// g_dbus_message_set_flags
// container is not nil, container is DBusMessage
// is method
func (v DBusMessage) SetFlags(flags DBusMessageFlags) {
	iv, err := _I.Get(287, "DBusMessage", "set_flags")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_flags := gi.NewIntArgument(int(flags))
	args := []gi.Argument{arg_v, arg_flags}
	iv.Call(args, nil, nil)
}

// g_dbus_message_set_header
// container is not nil, container is DBusMessage
// is method
func (v DBusMessage) SetHeader(header_field DBusMessageHeaderFieldEnum, value glib.Variant) {
	iv, err := _I.Get(288, "DBusMessage", "set_header")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_header_field := gi.NewIntArgument(int(header_field))
	arg_value := gi.NewPointerArgument(value.P)
	args := []gi.Argument{arg_v, arg_header_field, arg_value}
	iv.Call(args, nil, nil)
}

// g_dbus_message_set_interface
// container is not nil, container is DBusMessage
// is method
func (v DBusMessage) SetInterface(value string) {
	iv, err := _I.Get(289, "DBusMessage", "set_interface")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_value := gi.CString(value)
	arg_v := gi.NewPointerArgument(v.P)
	arg_value := gi.NewStringArgument(c_value)
	args := []gi.Argument{arg_v, arg_value}
	iv.Call(args, nil, nil)
	gi.Free(c_value)
}

// g_dbus_message_set_member
// container is not nil, container is DBusMessage
// is method
func (v DBusMessage) SetMember(value string) {
	iv, err := _I.Get(290, "DBusMessage", "set_member")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_value := gi.CString(value)
	arg_v := gi.NewPointerArgument(v.P)
	arg_value := gi.NewStringArgument(c_value)
	args := []gi.Argument{arg_v, arg_value}
	iv.Call(args, nil, nil)
	gi.Free(c_value)
}

// g_dbus_message_set_message_type
// container is not nil, container is DBusMessage
// is method
func (v DBusMessage) SetMessageType(type1 DBusMessageTypeEnum) {
	iv, err := _I.Get(291, "DBusMessage", "set_message_type")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_type1 := gi.NewIntArgument(int(type1))
	args := []gi.Argument{arg_v, arg_type1}
	iv.Call(args, nil, nil)
}

// g_dbus_message_set_num_unix_fds
// container is not nil, container is DBusMessage
// is method
func (v DBusMessage) SetNumUnixFds(value uint32) {
	iv, err := _I.Get(292, "DBusMessage", "set_num_unix_fds")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_value := gi.NewUint32Argument(value)
	args := []gi.Argument{arg_v, arg_value}
	iv.Call(args, nil, nil)
}

// g_dbus_message_set_path
// container is not nil, container is DBusMessage
// is method
func (v DBusMessage) SetPath(value string) {
	iv, err := _I.Get(293, "DBusMessage", "set_path")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_value := gi.CString(value)
	arg_v := gi.NewPointerArgument(v.P)
	arg_value := gi.NewStringArgument(c_value)
	args := []gi.Argument{arg_v, arg_value}
	iv.Call(args, nil, nil)
	gi.Free(c_value)
}

// g_dbus_message_set_reply_serial
// container is not nil, container is DBusMessage
// is method
func (v DBusMessage) SetReplySerial(value uint32) {
	iv, err := _I.Get(294, "DBusMessage", "set_reply_serial")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_value := gi.NewUint32Argument(value)
	args := []gi.Argument{arg_v, arg_value}
	iv.Call(args, nil, nil)
}

// g_dbus_message_set_sender
// container is not nil, container is DBusMessage
// is method
func (v DBusMessage) SetSender(value string) {
	iv, err := _I.Get(295, "DBusMessage", "set_sender")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_value := gi.CString(value)
	arg_v := gi.NewPointerArgument(v.P)
	arg_value := gi.NewStringArgument(c_value)
	args := []gi.Argument{arg_v, arg_value}
	iv.Call(args, nil, nil)
	gi.Free(c_value)
}

// g_dbus_message_set_serial
// container is not nil, container is DBusMessage
// is method
func (v DBusMessage) SetSerial(serial uint32) {
	iv, err := _I.Get(296, "DBusMessage", "set_serial")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_serial := gi.NewUint32Argument(serial)
	args := []gi.Argument{arg_v, arg_serial}
	iv.Call(args, nil, nil)
}

// g_dbus_message_set_signature
// container is not nil, container is DBusMessage
// is method
func (v DBusMessage) SetSignature(value string) {
	iv, err := _I.Get(297, "DBusMessage", "set_signature")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_value := gi.CString(value)
	arg_v := gi.NewPointerArgument(v.P)
	arg_value := gi.NewStringArgument(c_value)
	args := []gi.Argument{arg_v, arg_value}
	iv.Call(args, nil, nil)
	gi.Free(c_value)
}

// g_dbus_message_set_unix_fd_list
// container is not nil, container is DBusMessage
// is method
func (v DBusMessage) SetUnixFdList(fd_list IUnixFDList) {
	iv, err := _I.Get(298, "DBusMessage", "set_unix_fd_list")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if fd_list != nil {
		tmp = fd_list.P_UnixFDList()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_fd_list := gi.NewPointerArgument(tmp)
	args := []gi.Argument{arg_v, arg_fd_list}
	iv.Call(args, nil, nil)
}

// g_dbus_message_to_blob
// container is not nil, container is DBusMessage
// is method
// ret lenArgIdx 0
func (v DBusMessage) ToBlob(capabilities DBusCapabilityFlags) (result gi.Uint8Array, err error) {
	iv, err := _I.Get(299, "DBusMessage", "to_blob")
	if err != nil {
		return
	}
	var outArgs [2]gi.Argument
	arg_v := gi.NewPointerArgument(v.P)
	arg_out_size := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	arg_capabilities := gi.NewIntArgument(int(capabilities))
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[1]))
	args := []gi.Argument{arg_v, arg_out_size, arg_capabilities, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	var out_size uint64
	_ = out_size
	err = gi.ToError(outArgs[1].Pointer())
	out_size = outArgs[0].Uint64()
	result = gi.Uint8Array{P: ret.Pointer(), Len: int(out_size)}
	return
}

// g_dbus_message_to_gerror
// container is not nil, container is DBusMessage
// is method
func (v DBusMessage) ToGerror() (result bool, err error) {
	iv, err := _I.Get(300, "DBusMessage", "to_gerror")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	arg_v := gi.NewPointerArgument(v.P)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Bool()
	return
}

// Enum DBusMessageByteOrder
type DBusMessageByteOrderEnum int

const (
	DBusMessageByteOrderBigEndian    DBusMessageByteOrderEnum = 66
	DBusMessageByteOrderLittleEndian DBusMessageByteOrderEnum = 108
)

func DBusMessageByteOrderGetType() gi.GType {
	ret := _I.GetGType(55, "DBusMessageByteOrder")
	return ret
}

type DBusMessageFilterFunctionStruct struct {
	F_connection DBusConnection
	F_message    DBusMessage
	F_incoming   bool
}

//export myDBusMessageFilterFunction
func myDBusMessageFilterFunction(connection *C.GDBusConnection, message *C.GDBusMessage, incoming C.gboolean, user_data C.gpointer) {
	fn := gi.GetFunc(uint(uintptr(user_data)))
	args := DBusMessageFilterFunctionStruct{
		F_connection: WrapDBusConnection(unsafe.Pointer(connection)),
		F_message:    WrapDBusMessage(unsafe.Pointer(message)),
		F_incoming:   gi.Int2Bool(int(incoming)),
	}
	fn(args)
}

// Flags DBusMessageFlags
type DBusMessageFlags int

const (
	DBusMessageFlagsNone                          DBusMessageFlags = 0
	DBusMessageFlagsNoReplyExpected               DBusMessageFlags = 1
	DBusMessageFlagsNoAutoStart                   DBusMessageFlags = 2
	DBusMessageFlagsAllowInteractiveAuthorization DBusMessageFlags = 4
)

func DBusMessageFlagsGetType() gi.GType {
	ret := _I.GetGType(56, "DBusMessageFlags")
	return ret
}

// Enum DBusMessageHeaderField
type DBusMessageHeaderFieldEnum int

const (
	DBusMessageHeaderFieldInvalid     DBusMessageHeaderFieldEnum = 0
	DBusMessageHeaderFieldPath        DBusMessageHeaderFieldEnum = 1
	DBusMessageHeaderFieldInterface   DBusMessageHeaderFieldEnum = 2
	DBusMessageHeaderFieldMember      DBusMessageHeaderFieldEnum = 3
	DBusMessageHeaderFieldErrorName   DBusMessageHeaderFieldEnum = 4
	DBusMessageHeaderFieldReplySerial DBusMessageHeaderFieldEnum = 5
	DBusMessageHeaderFieldDestination DBusMessageHeaderFieldEnum = 6
	DBusMessageHeaderFieldSender      DBusMessageHeaderFieldEnum = 7
	DBusMessageHeaderFieldSignature   DBusMessageHeaderFieldEnum = 8
	DBusMessageHeaderFieldNumUnixFds  DBusMessageHeaderFieldEnum = 9
)

func DBusMessageHeaderFieldGetType() gi.GType {
	ret := _I.GetGType(57, "DBusMessageHeaderField")
	return ret
}

// Enum DBusMessageType
type DBusMessageTypeEnum int

const (
	DBusMessageTypeInvalid      DBusMessageTypeEnum = 0
	DBusMessageTypeMethodCall   DBusMessageTypeEnum = 1
	DBusMessageTypeMethodReturn DBusMessageTypeEnum = 2
	DBusMessageTypeError        DBusMessageTypeEnum = 3
	DBusMessageTypeSignal       DBusMessageTypeEnum = 4
)

func DBusMessageTypeGetType() gi.GType {
	ret := _I.GetGType(58, "DBusMessageType")
	return ret
}

// Struct DBusMethodInfo
type DBusMethodInfo struct {
	P unsafe.Pointer
}

const SizeOfStructDBusMethodInfo = 40

func DBusMethodInfoGetType() gi.GType {
	ret := _I.GetGType(59, "DBusMethodInfo")
	return ret
}

// g_dbus_method_info_ref
// container is not nil, container is DBusMethodInfo
// is method
func (v DBusMethodInfo) Ref() (result DBusMethodInfo) {
	iv, err := _I.Get(301, "DBusMethodInfo", "ref")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_dbus_method_info_unref
// container is not nil, container is DBusMethodInfo
// is method
func (v DBusMethodInfo) Unref() {
	iv, err := _I.Get(302, "DBusMethodInfo", "unref")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	iv.Call(args, nil, nil)
}

// Object DBusMethodInvocation
type DBusMethodInvocation struct {
	gobject.Object
}

func WrapDBusMethodInvocation(p unsafe.Pointer) (r DBusMethodInvocation) { r.P = p; return }

type IDBusMethodInvocation interface{ P_DBusMethodInvocation() unsafe.Pointer }

func (v DBusMethodInvocation) P_DBusMethodInvocation() unsafe.Pointer { return v.P }
func DBusMethodInvocationGetType() gi.GType {
	ret := _I.GetGType(60, "DBusMethodInvocation")
	return ret
}

// g_dbus_method_invocation_get_connection
// container is not nil, container is DBusMethodInvocation
// is method
func (v DBusMethodInvocation) GetConnection() (result DBusConnection) {
	iv, err := _I.Get(303, "DBusMethodInvocation", "get_connection")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_dbus_method_invocation_get_interface_name
// container is not nil, container is DBusMethodInvocation
// is method
func (v DBusMethodInvocation) GetInterfaceName() (result string) {
	iv, err := _I.Get(304, "DBusMethodInvocation", "get_interface_name")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Take()
	return
}

// g_dbus_method_invocation_get_message
// container is not nil, container is DBusMethodInvocation
// is method
func (v DBusMethodInvocation) GetMessage() (result DBusMessage) {
	iv, err := _I.Get(305, "DBusMethodInvocation", "get_message")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_dbus_method_invocation_get_method_info
// container is not nil, container is DBusMethodInvocation
// is method
func (v DBusMethodInvocation) GetMethodInfo() (result DBusMethodInfo) {
	iv, err := _I.Get(306, "DBusMethodInvocation", "get_method_info")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_dbus_method_invocation_get_method_name
// container is not nil, container is DBusMethodInvocation
// is method
func (v DBusMethodInvocation) GetMethodName() (result string) {
	iv, err := _I.Get(307, "DBusMethodInvocation", "get_method_name")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Take()
	return
}

// g_dbus_method_invocation_get_object_path
// container is not nil, container is DBusMethodInvocation
// is method
func (v DBusMethodInvocation) GetObjectPath() (result string) {
	iv, err := _I.Get(308, "DBusMethodInvocation", "get_object_path")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Take()
	return
}

// g_dbus_method_invocation_get_parameters
// container is not nil, container is DBusMethodInvocation
// is method
func (v DBusMethodInvocation) GetParameters() (result glib.Variant) {
	iv, err := _I.Get(309, "DBusMethodInvocation", "get_parameters")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_dbus_method_invocation_get_property_info
// container is not nil, container is DBusMethodInvocation
// is method
func (v DBusMethodInvocation) GetPropertyInfo() (result DBusPropertyInfo) {
	iv, err := _I.Get(310, "DBusMethodInvocation", "get_property_info")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_dbus_method_invocation_get_sender
// container is not nil, container is DBusMethodInvocation
// is method
func (v DBusMethodInvocation) GetSender() (result string) {
	iv, err := _I.Get(311, "DBusMethodInvocation", "get_sender")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Take()
	return
}

// g_dbus_method_invocation_return_dbus_error
// container is not nil, container is DBusMethodInvocation
// is method
func (v DBusMethodInvocation) ReturnDbusError(error_name string, error_message string) {
	iv, err := _I.Get(312, "DBusMethodInvocation", "return_dbus_error")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_error_name := gi.CString(error_name)
	c_error_message := gi.CString(error_message)
	arg_v := gi.NewPointerArgument(v.P)
	arg_error_name := gi.NewStringArgument(c_error_name)
	arg_error_message := gi.NewStringArgument(c_error_message)
	args := []gi.Argument{arg_v, arg_error_name, arg_error_message}
	iv.Call(args, nil, nil)
	gi.Free(c_error_name)
	gi.Free(c_error_message)
}

// g_dbus_method_invocation_return_error_literal
// container is not nil, container is DBusMethodInvocation
// is method
func (v DBusMethodInvocation) ReturnErrorLiteral(domain uint32, code int32, message string) {
	iv, err := _I.Get(313, "DBusMethodInvocation", "return_error_literal")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_message := gi.CString(message)
	arg_v := gi.NewPointerArgument(v.P)
	arg_domain := gi.NewUint32Argument(domain)
	arg_code := gi.NewInt32Argument(code)
	arg_message := gi.NewStringArgument(c_message)
	args := []gi.Argument{arg_v, arg_domain, arg_code, arg_message}
	iv.Call(args, nil, nil)
	gi.Free(c_message)
}

// g_dbus_method_invocation_return_gerror
// container is not nil, container is DBusMethodInvocation
// is method
func (v DBusMethodInvocation) ReturnGerror(error glib.Error) {
	iv, err := _I.Get(314, "DBusMethodInvocation", "return_gerror")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_error := gi.NewPointerArgument(error.P)
	args := []gi.Argument{arg_v, arg_error}
	iv.Call(args, nil, nil)
}

// g_dbus_method_invocation_return_value
// container is not nil, container is DBusMethodInvocation
// is method
func (v DBusMethodInvocation) ReturnValue(parameters glib.Variant) {
	iv, err := _I.Get(315, "DBusMethodInvocation", "return_value")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_parameters := gi.NewPointerArgument(parameters.P)
	args := []gi.Argument{arg_v, arg_parameters}
	iv.Call(args, nil, nil)
}

// g_dbus_method_invocation_return_value_with_unix_fd_list
// container is not nil, container is DBusMethodInvocation
// is method
func (v DBusMethodInvocation) ReturnValueWithUnixFdList(parameters glib.Variant, fd_list IUnixFDList) {
	iv, err := _I.Get(316, "DBusMethodInvocation", "return_value_with_unix_fd_list")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if fd_list != nil {
		tmp = fd_list.P_UnixFDList()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_parameters := gi.NewPointerArgument(parameters.P)
	arg_fd_list := gi.NewPointerArgument(tmp)
	args := []gi.Argument{arg_v, arg_parameters, arg_fd_list}
	iv.Call(args, nil, nil)
}

// Struct DBusNodeInfo
type DBusNodeInfo struct {
	P unsafe.Pointer
}

const SizeOfStructDBusNodeInfo = 40

func DBusNodeInfoGetType() gi.GType {
	ret := _I.GetGType(61, "DBusNodeInfo")
	return ret
}

// g_dbus_node_info_new_for_xml
// container is not nil, container is DBusNodeInfo
// is constructor
func NewDBusNodeInfoForXml(xml_data string) (result DBusNodeInfo, err error) {
	iv, err := _I.Get(317, "DBusNodeInfo", "new_for_xml")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	c_xml_data := gi.CString(xml_data)
	arg_xml_data := gi.NewStringArgument(c_xml_data)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_xml_data, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	gi.Free(c_xml_data)
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// g_dbus_node_info_generate_xml
// container is not nil, container is DBusNodeInfo
// is method
func (v DBusNodeInfo) GenerateXml(indent uint32, string_builder glib.String) {
	iv, err := _I.Get(318, "DBusNodeInfo", "generate_xml")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_indent := gi.NewUint32Argument(indent)
	arg_string_builder := gi.NewPointerArgument(string_builder.P)
	args := []gi.Argument{arg_v, arg_indent, arg_string_builder}
	iv.Call(args, nil, nil)
}

// g_dbus_node_info_lookup_interface
// container is not nil, container is DBusNodeInfo
// is method
func (v DBusNodeInfo) LookupInterface(name string) (result DBusInterfaceInfo) {
	iv, err := _I.Get(319, "DBusNodeInfo", "lookup_interface")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_name := gi.CString(name)
	arg_v := gi.NewPointerArgument(v.P)
	arg_name := gi.NewStringArgument(c_name)
	args := []gi.Argument{arg_v, arg_name}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_name)
	result.P = ret.Pointer()
	return
}

// g_dbus_node_info_ref
// container is not nil, container is DBusNodeInfo
// is method
func (v DBusNodeInfo) Ref() (result DBusNodeInfo) {
	iv, err := _I.Get(320, "DBusNodeInfo", "ref")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_dbus_node_info_unref
// container is not nil, container is DBusNodeInfo
// is method
func (v DBusNodeInfo) Unref() {
	iv, err := _I.Get(321, "DBusNodeInfo", "unref")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	iv.Call(args, nil, nil)
}

// Interface DBusObject
type DBusObject struct {
	DBusObjectIfc
	P unsafe.Pointer
}
type DBusObjectIfc struct{}
type IDBusObject interface{ P_DBusObject() unsafe.Pointer }

func (v DBusObject) P_DBusObject() unsafe.Pointer { return v.P }
func DBusObjectGetType() gi.GType {
	ret := _I.GetGType(62, "DBusObject")
	return ret
}

// g_dbus_object_get_interface
// container is not nil, container is DBusObject
// is method
func (v *DBusObjectIfc) GetInterface(interface_name string) (result DBusInterface) {
	iv, err := _I.Get(322, "DBusObject", "get_interface")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_interface_name := gi.CString(interface_name)
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_interface_name := gi.NewStringArgument(c_interface_name)
	args := []gi.Argument{arg_v, arg_interface_name}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_interface_name)
	result.P = ret.Pointer()
	return
}

// g_dbus_object_get_interfaces
// container is not nil, container is DBusObject
// is method
func (v *DBusObjectIfc) GetInterfaces() (result glib.List) {
	iv, err := _I.Get(323, "DBusObject", "get_interfaces")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_dbus_object_get_object_path
// container is not nil, container is DBusObject
// is method
func (v *DBusObjectIfc) GetObjectPath() (result string) {
	iv, err := _I.Get(324, "DBusObject", "get_object_path")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Take()
	return
}

// ignore GType struct DBusObjectIface
// Interface DBusObjectManager
type DBusObjectManager struct {
	DBusObjectManagerIfc
	P unsafe.Pointer
}
type DBusObjectManagerIfc struct{}
type IDBusObjectManager interface{ P_DBusObjectManager() unsafe.Pointer }

func (v DBusObjectManager) P_DBusObjectManager() unsafe.Pointer { return v.P }
func DBusObjectManagerGetType() gi.GType {
	ret := _I.GetGType(63, "DBusObjectManager")
	return ret
}

// g_dbus_object_manager_get_interface
// container is not nil, container is DBusObjectManager
// is method
func (v *DBusObjectManagerIfc) GetInterface(object_path string, interface_name string) (result DBusInterface) {
	iv, err := _I.Get(325, "DBusObjectManager", "get_interface")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_object_path := gi.CString(object_path)
	c_interface_name := gi.CString(interface_name)
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_object_path := gi.NewStringArgument(c_object_path)
	arg_interface_name := gi.NewStringArgument(c_interface_name)
	args := []gi.Argument{arg_v, arg_object_path, arg_interface_name}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_object_path)
	gi.Free(c_interface_name)
	result.P = ret.Pointer()
	return
}

// g_dbus_object_manager_get_object
// container is not nil, container is DBusObjectManager
// is method
func (v *DBusObjectManagerIfc) GetObject(object_path string) (result DBusObject) {
	iv, err := _I.Get(326, "DBusObjectManager", "get_object")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_object_path := gi.CString(object_path)
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_object_path := gi.NewStringArgument(c_object_path)
	args := []gi.Argument{arg_v, arg_object_path}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_object_path)
	result.P = ret.Pointer()
	return
}

// g_dbus_object_manager_get_object_path
// container is not nil, container is DBusObjectManager
// is method
func (v *DBusObjectManagerIfc) GetObjectPath() (result string) {
	iv, err := _I.Get(327, "DBusObjectManager", "get_object_path")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Take()
	return
}

// g_dbus_object_manager_get_objects
// container is not nil, container is DBusObjectManager
// is method
func (v *DBusObjectManagerIfc) GetObjects() (result glib.List) {
	iv, err := _I.Get(328, "DBusObjectManager", "get_objects")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// Object DBusObjectManagerClient
type DBusObjectManagerClient struct {
	AsyncInitableIfc
	DBusObjectManagerIfc
	InitableIfc
	gobject.Object
}

func WrapDBusObjectManagerClient(p unsafe.Pointer) (r DBusObjectManagerClient) { r.P = p; return }

type IDBusObjectManagerClient interface{ P_DBusObjectManagerClient() unsafe.Pointer }

func (v DBusObjectManagerClient) P_DBusObjectManagerClient() unsafe.Pointer { return v.P }
func (v DBusObjectManagerClient) P_AsyncInitable() unsafe.Pointer           { return v.P }
func (v DBusObjectManagerClient) P_DBusObjectManager() unsafe.Pointer       { return v.P }
func (v DBusObjectManagerClient) P_Initable() unsafe.Pointer                { return v.P }
func DBusObjectManagerClientGetType() gi.GType {
	ret := _I.GetGType(64, "DBusObjectManagerClient")
	return ret
}

// g_dbus_object_manager_client_new_finish
// container is not nil, container is DBusObjectManagerClient
// is constructor
func NewDBusObjectManagerClientFinish(res IAsyncResult) (result DBusObjectManagerClient, err error) {
	iv, err := _I.Get(329, "DBusObjectManagerClient", "new_finish")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if res != nil {
		tmp = res.P_AsyncResult()
	}
	arg_res := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_res, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// g_dbus_object_manager_client_new_for_bus_finish
// container is not nil, container is DBusObjectManagerClient
// is constructor
func NewDBusObjectManagerClientForBusFinish(res IAsyncResult) (result DBusObjectManagerClient, err error) {
	iv, err := _I.Get(330, "DBusObjectManagerClient", "new_for_bus_finish")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if res != nil {
		tmp = res.P_AsyncResult()
	}
	arg_res := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_res, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// g_dbus_object_manager_client_new_for_bus_sync
// container is not nil, container is DBusObjectManagerClient
// is constructor
func NewDBusObjectManagerClientForBusSync(bus_type BusTypeEnum, flags DBusObjectManagerClientFlags, name string, object_path string, get_proxy_type_func int /*TODO_TYPE isPtr: false, tag: interface*/, get_proxy_type_user_data unsafe.Pointer, get_proxy_type_destroy_notify int /*TODO_TYPE isPtr: false, tag: interface*/, cancellable ICancellable) (result DBusObjectManagerClient, err error) {
	iv, err := _I.Get(331, "DBusObjectManagerClient", "new_for_bus_sync")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	c_name := gi.CString(name)
	c_object_path := gi.CString(object_path)
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_bus_type := gi.NewIntArgument(int(bus_type))
	arg_flags := gi.NewIntArgument(int(flags))
	arg_name := gi.NewStringArgument(c_name)
	arg_object_path := gi.NewStringArgument(c_object_path)
	arg_get_proxy_type_func := gi.NewIntArgument(get_proxy_type_func) /*TODO*/
	arg_get_proxy_type_user_data := gi.NewPointerArgument(get_proxy_type_user_data)
	arg_get_proxy_type_destroy_notify := gi.NewIntArgument(get_proxy_type_destroy_notify) /*TODO*/
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_bus_type, arg_flags, arg_name, arg_object_path, arg_get_proxy_type_func, arg_get_proxy_type_user_data, arg_get_proxy_type_destroy_notify, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	gi.Free(c_name)
	gi.Free(c_object_path)
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// g_dbus_object_manager_client_new_sync
// container is not nil, container is DBusObjectManagerClient
// is constructor
func NewDBusObjectManagerClientSync(connection IDBusConnection, flags DBusObjectManagerClientFlags, name string, object_path string, get_proxy_type_func int /*TODO_TYPE isPtr: false, tag: interface*/, get_proxy_type_user_data unsafe.Pointer, get_proxy_type_destroy_notify int /*TODO_TYPE isPtr: false, tag: interface*/, cancellable ICancellable) (result DBusObjectManagerClient, err error) {
	iv, err := _I.Get(332, "DBusObjectManagerClient", "new_sync")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if connection != nil {
		tmp = connection.P_DBusConnection()
	}
	c_name := gi.CString(name)
	c_object_path := gi.CString(object_path)
	var tmp1 unsafe.Pointer
	if cancellable != nil {
		tmp1 = cancellable.P_Cancellable()
	}
	arg_connection := gi.NewPointerArgument(tmp)
	arg_flags := gi.NewIntArgument(int(flags))
	arg_name := gi.NewStringArgument(c_name)
	arg_object_path := gi.NewStringArgument(c_object_path)
	arg_get_proxy_type_func := gi.NewIntArgument(get_proxy_type_func) /*TODO*/
	arg_get_proxy_type_user_data := gi.NewPointerArgument(get_proxy_type_user_data)
	arg_get_proxy_type_destroy_notify := gi.NewIntArgument(get_proxy_type_destroy_notify) /*TODO*/
	arg_cancellable := gi.NewPointerArgument(tmp1)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_connection, arg_flags, arg_name, arg_object_path, arg_get_proxy_type_func, arg_get_proxy_type_user_data, arg_get_proxy_type_destroy_notify, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	gi.Free(c_name)
	gi.Free(c_object_path)
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// g_dbus_object_manager_client_new
// container is not nil, container is DBusObjectManagerClient
// is method
// arg0Type tag: interface, isPtr: true
func DBusObjectManagerClientNew1(connection IDBusConnection, flags DBusObjectManagerClientFlags, name string, object_path string, get_proxy_type_func int /*TODO_TYPE isPtr: false, tag: interface*/, get_proxy_type_user_data unsafe.Pointer, get_proxy_type_destroy_notify int /*TODO_TYPE isPtr: false, tag: interface*/, cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(333, "DBusObjectManagerClient", "new")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if connection != nil {
		tmp = connection.P_DBusConnection()
	}
	c_name := gi.CString(name)
	c_object_path := gi.CString(object_path)
	var tmp1 unsafe.Pointer
	if cancellable != nil {
		tmp1 = cancellable.P_Cancellable()
	}
	arg_connection := gi.NewPointerArgument(tmp)
	arg_flags := gi.NewIntArgument(int(flags))
	arg_name := gi.NewStringArgument(c_name)
	arg_object_path := gi.NewStringArgument(c_object_path)
	arg_get_proxy_type_func := gi.NewIntArgument(get_proxy_type_func) /*TODO*/
	arg_get_proxy_type_user_data := gi.NewPointerArgument(get_proxy_type_user_data)
	arg_get_proxy_type_destroy_notify := gi.NewIntArgument(get_proxy_type_destroy_notify) /*TODO*/
	arg_cancellable := gi.NewPointerArgument(tmp1)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_connection, arg_flags, arg_name, arg_object_path, arg_get_proxy_type_func, arg_get_proxy_type_user_data, arg_get_proxy_type_destroy_notify, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
	gi.Free(c_name)
	gi.Free(c_object_path)
}

// g_dbus_object_manager_client_new_for_bus
// container is not nil, container is DBusObjectManagerClient
// is method
// arg0Type tag: interface, isPtr: false
func DBusObjectManagerClientNewForBus1(bus_type BusTypeEnum, flags DBusObjectManagerClientFlags, name string, object_path string, get_proxy_type_func int /*TODO_TYPE isPtr: false, tag: interface*/, get_proxy_type_user_data unsafe.Pointer, get_proxy_type_destroy_notify int /*TODO_TYPE isPtr: false, tag: interface*/, cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(334, "DBusObjectManagerClient", "new_for_bus")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_name := gi.CString(name)
	c_object_path := gi.CString(object_path)
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_bus_type := gi.NewIntArgument(int(bus_type))
	arg_flags := gi.NewIntArgument(int(flags))
	arg_name := gi.NewStringArgument(c_name)
	arg_object_path := gi.NewStringArgument(c_object_path)
	arg_get_proxy_type_func := gi.NewIntArgument(get_proxy_type_func) /*TODO*/
	arg_get_proxy_type_user_data := gi.NewPointerArgument(get_proxy_type_user_data)
	arg_get_proxy_type_destroy_notify := gi.NewIntArgument(get_proxy_type_destroy_notify) /*TODO*/
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_bus_type, arg_flags, arg_name, arg_object_path, arg_get_proxy_type_func, arg_get_proxy_type_user_data, arg_get_proxy_type_destroy_notify, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
	gi.Free(c_name)
	gi.Free(c_object_path)
}

// g_dbus_object_manager_client_get_connection
// container is not nil, container is DBusObjectManagerClient
// is method
func (v DBusObjectManagerClient) GetConnection() (result DBusConnection) {
	iv, err := _I.Get(335, "DBusObjectManagerClient", "get_connection")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_dbus_object_manager_client_get_flags
// container is not nil, container is DBusObjectManagerClient
// is method
func (v DBusObjectManagerClient) GetFlags() (result DBusObjectManagerClientFlags) {
	iv, err := _I.Get(336, "DBusObjectManagerClient", "get_flags")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = DBusObjectManagerClientFlags(ret.Int())
	return
}

// g_dbus_object_manager_client_get_name
// container is not nil, container is DBusObjectManagerClient
// is method
func (v DBusObjectManagerClient) GetName() (result string) {
	iv, err := _I.Get(337, "DBusObjectManagerClient", "get_name")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Take()
	return
}

// g_dbus_object_manager_client_get_name_owner
// container is not nil, container is DBusObjectManagerClient
// is method
func (v DBusObjectManagerClient) GetNameOwner() (result string) {
	iv, err := _I.Get(338, "DBusObjectManagerClient", "get_name_owner")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Take()
	return
}

// ignore GType struct DBusObjectManagerClientClass
// Flags DBusObjectManagerClientFlags
type DBusObjectManagerClientFlags int

const (
	DBusObjectManagerClientFlagsNone           DBusObjectManagerClientFlags = 0
	DBusObjectManagerClientFlagsDoNotAutoStart DBusObjectManagerClientFlags = 1
)

func DBusObjectManagerClientFlagsGetType() gi.GType {
	ret := _I.GetGType(65, "DBusObjectManagerClientFlags")
	return ret
}

// Struct DBusObjectManagerClientPrivate
type DBusObjectManagerClientPrivate struct {
	P unsafe.Pointer
}

func DBusObjectManagerClientPrivateGetType() gi.GType {
	ret := _I.GetGType(66, "DBusObjectManagerClientPrivate")
	return ret
}

// ignore GType struct DBusObjectManagerIface
// Object DBusObjectManagerServer
type DBusObjectManagerServer struct {
	DBusObjectManagerIfc
	gobject.Object
}

func WrapDBusObjectManagerServer(p unsafe.Pointer) (r DBusObjectManagerServer) { r.P = p; return }

type IDBusObjectManagerServer interface{ P_DBusObjectManagerServer() unsafe.Pointer }

func (v DBusObjectManagerServer) P_DBusObjectManagerServer() unsafe.Pointer { return v.P }
func (v DBusObjectManagerServer) P_DBusObjectManager() unsafe.Pointer       { return v.P }
func DBusObjectManagerServerGetType() gi.GType {
	ret := _I.GetGType(67, "DBusObjectManagerServer")
	return ret
}

// g_dbus_object_manager_server_new
// container is not nil, container is DBusObjectManagerServer
// is constructor
func NewDBusObjectManagerServer(object_path string) (result DBusObjectManagerServer) {
	iv, err := _I.Get(339, "DBusObjectManagerServer", "new")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_object_path := gi.CString(object_path)
	arg_object_path := gi.NewStringArgument(c_object_path)
	args := []gi.Argument{arg_object_path}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_object_path)
	result.P = ret.Pointer()
	return
}

// g_dbus_object_manager_server_export
// container is not nil, container is DBusObjectManagerServer
// is method
func (v DBusObjectManagerServer) Export(object IDBusObjectSkeleton) {
	iv, err := _I.Get(340, "DBusObjectManagerServer", "export")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if object != nil {
		tmp = object.P_DBusObjectSkeleton()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_object := gi.NewPointerArgument(tmp)
	args := []gi.Argument{arg_v, arg_object}
	iv.Call(args, nil, nil)
}

// g_dbus_object_manager_server_export_uniquely
// container is not nil, container is DBusObjectManagerServer
// is method
func (v DBusObjectManagerServer) ExportUniquely(object IDBusObjectSkeleton) {
	iv, err := _I.Get(341, "DBusObjectManagerServer", "export_uniquely")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if object != nil {
		tmp = object.P_DBusObjectSkeleton()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_object := gi.NewPointerArgument(tmp)
	args := []gi.Argument{arg_v, arg_object}
	iv.Call(args, nil, nil)
}

// g_dbus_object_manager_server_get_connection
// container is not nil, container is DBusObjectManagerServer
// is method
func (v DBusObjectManagerServer) GetConnection() (result DBusConnection) {
	iv, err := _I.Get(342, "DBusObjectManagerServer", "get_connection")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_dbus_object_manager_server_is_exported
// container is not nil, container is DBusObjectManagerServer
// is method
func (v DBusObjectManagerServer) IsExported(object IDBusObjectSkeleton) (result bool) {
	iv, err := _I.Get(343, "DBusObjectManagerServer", "is_exported")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if object != nil {
		tmp = object.P_DBusObjectSkeleton()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_object := gi.NewPointerArgument(tmp)
	args := []gi.Argument{arg_v, arg_object}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_dbus_object_manager_server_set_connection
// container is not nil, container is DBusObjectManagerServer
// is method
func (v DBusObjectManagerServer) SetConnection(connection IDBusConnection) {
	iv, err := _I.Get(344, "DBusObjectManagerServer", "set_connection")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if connection != nil {
		tmp = connection.P_DBusConnection()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_connection := gi.NewPointerArgument(tmp)
	args := []gi.Argument{arg_v, arg_connection}
	iv.Call(args, nil, nil)
}

// g_dbus_object_manager_server_unexport
// container is not nil, container is DBusObjectManagerServer
// is method
func (v DBusObjectManagerServer) Unexport(object_path string) (result bool) {
	iv, err := _I.Get(345, "DBusObjectManagerServer", "unexport")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_object_path := gi.CString(object_path)
	arg_v := gi.NewPointerArgument(v.P)
	arg_object_path := gi.NewStringArgument(c_object_path)
	args := []gi.Argument{arg_v, arg_object_path}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_object_path)
	result = ret.Bool()
	return
}

// ignore GType struct DBusObjectManagerServerClass
// Struct DBusObjectManagerServerPrivate
type DBusObjectManagerServerPrivate struct {
	P unsafe.Pointer
}

func DBusObjectManagerServerPrivateGetType() gi.GType {
	ret := _I.GetGType(68, "DBusObjectManagerServerPrivate")
	return ret
}

// Object DBusObjectProxy
type DBusObjectProxy struct {
	DBusObjectIfc
	gobject.Object
}

func WrapDBusObjectProxy(p unsafe.Pointer) (r DBusObjectProxy) { r.P = p; return }

type IDBusObjectProxy interface{ P_DBusObjectProxy() unsafe.Pointer }

func (v DBusObjectProxy) P_DBusObjectProxy() unsafe.Pointer { return v.P }
func (v DBusObjectProxy) P_DBusObject() unsafe.Pointer      { return v.P }
func DBusObjectProxyGetType() gi.GType {
	ret := _I.GetGType(69, "DBusObjectProxy")
	return ret
}

// g_dbus_object_proxy_new
// container is not nil, container is DBusObjectProxy
// is constructor
func NewDBusObjectProxy(connection IDBusConnection, object_path string) (result DBusObjectProxy) {
	iv, err := _I.Get(346, "DBusObjectProxy", "new")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if connection != nil {
		tmp = connection.P_DBusConnection()
	}
	c_object_path := gi.CString(object_path)
	arg_connection := gi.NewPointerArgument(tmp)
	arg_object_path := gi.NewStringArgument(c_object_path)
	args := []gi.Argument{arg_connection, arg_object_path}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_object_path)
	result.P = ret.Pointer()
	return
}

// g_dbus_object_proxy_get_connection
// container is not nil, container is DBusObjectProxy
// is method
func (v DBusObjectProxy) GetConnection() (result DBusConnection) {
	iv, err := _I.Get(347, "DBusObjectProxy", "get_connection")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// ignore GType struct DBusObjectProxyClass
// Struct DBusObjectProxyPrivate
type DBusObjectProxyPrivate struct {
	P unsafe.Pointer
}

func DBusObjectProxyPrivateGetType() gi.GType {
	ret := _I.GetGType(70, "DBusObjectProxyPrivate")
	return ret
}

// Object DBusObjectSkeleton
type DBusObjectSkeleton struct {
	DBusObjectIfc
	gobject.Object
}

func WrapDBusObjectSkeleton(p unsafe.Pointer) (r DBusObjectSkeleton) { r.P = p; return }

type IDBusObjectSkeleton interface{ P_DBusObjectSkeleton() unsafe.Pointer }

func (v DBusObjectSkeleton) P_DBusObjectSkeleton() unsafe.Pointer { return v.P }
func (v DBusObjectSkeleton) P_DBusObject() unsafe.Pointer         { return v.P }
func DBusObjectSkeletonGetType() gi.GType {
	ret := _I.GetGType(71, "DBusObjectSkeleton")
	return ret
}

// g_dbus_object_skeleton_new
// container is not nil, container is DBusObjectSkeleton
// is constructor
func NewDBusObjectSkeleton(object_path string) (result DBusObjectSkeleton) {
	iv, err := _I.Get(348, "DBusObjectSkeleton", "new")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_object_path := gi.CString(object_path)
	arg_object_path := gi.NewStringArgument(c_object_path)
	args := []gi.Argument{arg_object_path}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_object_path)
	result.P = ret.Pointer()
	return
}

// g_dbus_object_skeleton_add_interface
// container is not nil, container is DBusObjectSkeleton
// is method
func (v DBusObjectSkeleton) AddInterface(interface_ IDBusInterfaceSkeleton) {
	iv, err := _I.Get(349, "DBusObjectSkeleton", "add_interface")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if interface_ != nil {
		tmp = interface_.P_DBusInterfaceSkeleton()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_interface_ := gi.NewPointerArgument(tmp)
	args := []gi.Argument{arg_v, arg_interface_}
	iv.Call(args, nil, nil)
}

// g_dbus_object_skeleton_flush
// container is not nil, container is DBusObjectSkeleton
// is method
func (v DBusObjectSkeleton) Flush() {
	iv, err := _I.Get(350, "DBusObjectSkeleton", "flush")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	iv.Call(args, nil, nil)
}

// g_dbus_object_skeleton_remove_interface
// container is not nil, container is DBusObjectSkeleton
// is method
func (v DBusObjectSkeleton) RemoveInterface(interface_ IDBusInterfaceSkeleton) {
	iv, err := _I.Get(351, "DBusObjectSkeleton", "remove_interface")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if interface_ != nil {
		tmp = interface_.P_DBusInterfaceSkeleton()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_interface_ := gi.NewPointerArgument(tmp)
	args := []gi.Argument{arg_v, arg_interface_}
	iv.Call(args, nil, nil)
}

// g_dbus_object_skeleton_remove_interface_by_name
// container is not nil, container is DBusObjectSkeleton
// is method
func (v DBusObjectSkeleton) RemoveInterfaceByName(interface_name string) {
	iv, err := _I.Get(352, "DBusObjectSkeleton", "remove_interface_by_name")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_interface_name := gi.CString(interface_name)
	arg_v := gi.NewPointerArgument(v.P)
	arg_interface_name := gi.NewStringArgument(c_interface_name)
	args := []gi.Argument{arg_v, arg_interface_name}
	iv.Call(args, nil, nil)
	gi.Free(c_interface_name)
}

// g_dbus_object_skeleton_set_object_path
// container is not nil, container is DBusObjectSkeleton
// is method
func (v DBusObjectSkeleton) SetObjectPath(object_path string) {
	iv, err := _I.Get(353, "DBusObjectSkeleton", "set_object_path")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_object_path := gi.CString(object_path)
	arg_v := gi.NewPointerArgument(v.P)
	arg_object_path := gi.NewStringArgument(c_object_path)
	args := []gi.Argument{arg_v, arg_object_path}
	iv.Call(args, nil, nil)
	gi.Free(c_object_path)
}

// ignore GType struct DBusObjectSkeletonClass
// Struct DBusObjectSkeletonPrivate
type DBusObjectSkeletonPrivate struct {
	P unsafe.Pointer
}

func DBusObjectSkeletonPrivateGetType() gi.GType {
	ret := _I.GetGType(72, "DBusObjectSkeletonPrivate")
	return ret
}

// Struct DBusPropertyInfo
type DBusPropertyInfo struct {
	P unsafe.Pointer
}

const SizeOfStructDBusPropertyInfo = 40

func DBusPropertyInfoGetType() gi.GType {
	ret := _I.GetGType(73, "DBusPropertyInfo")
	return ret
}

// g_dbus_property_info_ref
// container is not nil, container is DBusPropertyInfo
// is method
func (v DBusPropertyInfo) Ref() (result DBusPropertyInfo) {
	iv, err := _I.Get(354, "DBusPropertyInfo", "ref")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_dbus_property_info_unref
// container is not nil, container is DBusPropertyInfo
// is method
func (v DBusPropertyInfo) Unref() {
	iv, err := _I.Get(355, "DBusPropertyInfo", "unref")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	iv.Call(args, nil, nil)
}

// Flags DBusPropertyInfoFlags
type DBusPropertyInfoFlags int

const (
	DBusPropertyInfoFlagsNone     DBusPropertyInfoFlags = 0
	DBusPropertyInfoFlagsReadable DBusPropertyInfoFlags = 1
	DBusPropertyInfoFlagsWritable DBusPropertyInfoFlags = 2
)

func DBusPropertyInfoFlagsGetType() gi.GType {
	ret := _I.GetGType(74, "DBusPropertyInfoFlags")
	return ret
}

// Object DBusProxy
type DBusProxy struct {
	AsyncInitableIfc
	DBusInterfaceIfc
	InitableIfc
	gobject.Object
}

func WrapDBusProxy(p unsafe.Pointer) (r DBusProxy) { r.P = p; return }

type IDBusProxy interface{ P_DBusProxy() unsafe.Pointer }

func (v DBusProxy) P_DBusProxy() unsafe.Pointer     { return v.P }
func (v DBusProxy) P_AsyncInitable() unsafe.Pointer { return v.P }
func (v DBusProxy) P_DBusInterface() unsafe.Pointer { return v.P }
func (v DBusProxy) P_Initable() unsafe.Pointer      { return v.P }
func DBusProxyGetType() gi.GType {
	ret := _I.GetGType(75, "DBusProxy")
	return ret
}

// g_dbus_proxy_new_finish
// container is not nil, container is DBusProxy
// is constructor
func NewDBusProxyFinish(res IAsyncResult) (result DBusProxy, err error) {
	iv, err := _I.Get(356, "DBusProxy", "new_finish")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if res != nil {
		tmp = res.P_AsyncResult()
	}
	arg_res := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_res, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// g_dbus_proxy_new_for_bus_finish
// container is not nil, container is DBusProxy
// is constructor
func NewDBusProxyForBusFinish(res IAsyncResult) (result DBusProxy, err error) {
	iv, err := _I.Get(357, "DBusProxy", "new_for_bus_finish")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if res != nil {
		tmp = res.P_AsyncResult()
	}
	arg_res := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_res, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// g_dbus_proxy_new_for_bus_sync
// container is not nil, container is DBusProxy
// is constructor
func NewDBusProxyForBusSync(bus_type BusTypeEnum, flags DBusProxyFlags, info DBusInterfaceInfo, name string, object_path string, interface_name string, cancellable ICancellable) (result DBusProxy, err error) {
	iv, err := _I.Get(358, "DBusProxy", "new_for_bus_sync")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	c_name := gi.CString(name)
	c_object_path := gi.CString(object_path)
	c_interface_name := gi.CString(interface_name)
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_bus_type := gi.NewIntArgument(int(bus_type))
	arg_flags := gi.NewIntArgument(int(flags))
	arg_info := gi.NewPointerArgument(info.P)
	arg_name := gi.NewStringArgument(c_name)
	arg_object_path := gi.NewStringArgument(c_object_path)
	arg_interface_name := gi.NewStringArgument(c_interface_name)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_bus_type, arg_flags, arg_info, arg_name, arg_object_path, arg_interface_name, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	gi.Free(c_name)
	gi.Free(c_object_path)
	gi.Free(c_interface_name)
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// g_dbus_proxy_new_sync
// container is not nil, container is DBusProxy
// is constructor
func NewDBusProxySync(connection IDBusConnection, flags DBusProxyFlags, info DBusInterfaceInfo, name string, object_path string, interface_name string, cancellable ICancellable) (result DBusProxy, err error) {
	iv, err := _I.Get(359, "DBusProxy", "new_sync")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if connection != nil {
		tmp = connection.P_DBusConnection()
	}
	c_name := gi.CString(name)
	c_object_path := gi.CString(object_path)
	c_interface_name := gi.CString(interface_name)
	var tmp1 unsafe.Pointer
	if cancellable != nil {
		tmp1 = cancellable.P_Cancellable()
	}
	arg_connection := gi.NewPointerArgument(tmp)
	arg_flags := gi.NewIntArgument(int(flags))
	arg_info := gi.NewPointerArgument(info.P)
	arg_name := gi.NewStringArgument(c_name)
	arg_object_path := gi.NewStringArgument(c_object_path)
	arg_interface_name := gi.NewStringArgument(c_interface_name)
	arg_cancellable := gi.NewPointerArgument(tmp1)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_connection, arg_flags, arg_info, arg_name, arg_object_path, arg_interface_name, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	gi.Free(c_name)
	gi.Free(c_object_path)
	gi.Free(c_interface_name)
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// g_dbus_proxy_new
// container is not nil, container is DBusProxy
// is method
// arg0Type tag: interface, isPtr: true
func DBusProxyNew1(connection IDBusConnection, flags DBusProxyFlags, info DBusInterfaceInfo, name string, object_path string, interface_name string, cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(360, "DBusProxy", "new")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if connection != nil {
		tmp = connection.P_DBusConnection()
	}
	c_name := gi.CString(name)
	c_object_path := gi.CString(object_path)
	c_interface_name := gi.CString(interface_name)
	var tmp1 unsafe.Pointer
	if cancellable != nil {
		tmp1 = cancellable.P_Cancellable()
	}
	arg_connection := gi.NewPointerArgument(tmp)
	arg_flags := gi.NewIntArgument(int(flags))
	arg_info := gi.NewPointerArgument(info.P)
	arg_name := gi.NewStringArgument(c_name)
	arg_object_path := gi.NewStringArgument(c_object_path)
	arg_interface_name := gi.NewStringArgument(c_interface_name)
	arg_cancellable := gi.NewPointerArgument(tmp1)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_connection, arg_flags, arg_info, arg_name, arg_object_path, arg_interface_name, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
	gi.Free(c_name)
	gi.Free(c_object_path)
	gi.Free(c_interface_name)
}

// g_dbus_proxy_new_for_bus
// container is not nil, container is DBusProxy
// is method
// arg0Type tag: interface, isPtr: false
func DBusProxyNewForBus1(bus_type BusTypeEnum, flags DBusProxyFlags, info DBusInterfaceInfo, name string, object_path string, interface_name string, cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(361, "DBusProxy", "new_for_bus")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_name := gi.CString(name)
	c_object_path := gi.CString(object_path)
	c_interface_name := gi.CString(interface_name)
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_bus_type := gi.NewIntArgument(int(bus_type))
	arg_flags := gi.NewIntArgument(int(flags))
	arg_info := gi.NewPointerArgument(info.P)
	arg_name := gi.NewStringArgument(c_name)
	arg_object_path := gi.NewStringArgument(c_object_path)
	arg_interface_name := gi.NewStringArgument(c_interface_name)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_bus_type, arg_flags, arg_info, arg_name, arg_object_path, arg_interface_name, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
	gi.Free(c_name)
	gi.Free(c_object_path)
	gi.Free(c_interface_name)
}

// g_dbus_proxy_call
// container is not nil, container is DBusProxy
// is method
func (v DBusProxy) Call(method_name string, parameters glib.Variant, flags DBusCallFlags, timeout_msec int32, cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(362, "DBusProxy", "call")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_method_name := gi.CString(method_name)
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_method_name := gi.NewStringArgument(c_method_name)
	arg_parameters := gi.NewPointerArgument(parameters.P)
	arg_flags := gi.NewIntArgument(int(flags))
	arg_timeout_msec := gi.NewInt32Argument(timeout_msec)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_v, arg_method_name, arg_parameters, arg_flags, arg_timeout_msec, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
	gi.Free(c_method_name)
}

// g_dbus_proxy_call_finish
// container is not nil, container is DBusProxy
// is method
func (v DBusProxy) CallFinish(res IAsyncResult) (result glib.Variant, err error) {
	iv, err := _I.Get(363, "DBusProxy", "call_finish")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if res != nil {
		tmp = res.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_res := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_res, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// g_dbus_proxy_call_sync
// container is not nil, container is DBusProxy
// is method
func (v DBusProxy) CallSync(method_name string, parameters glib.Variant, flags DBusCallFlags, timeout_msec int32, cancellable ICancellable) (result glib.Variant, err error) {
	iv, err := _I.Get(364, "DBusProxy", "call_sync")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	c_method_name := gi.CString(method_name)
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_method_name := gi.NewStringArgument(c_method_name)
	arg_parameters := gi.NewPointerArgument(parameters.P)
	arg_flags := gi.NewIntArgument(int(flags))
	arg_timeout_msec := gi.NewInt32Argument(timeout_msec)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_method_name, arg_parameters, arg_flags, arg_timeout_msec, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	gi.Free(c_method_name)
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// g_dbus_proxy_call_with_unix_fd_list
// container is not nil, container is DBusProxy
// is method
func (v DBusProxy) CallWithUnixFdList(method_name string, parameters glib.Variant, flags DBusCallFlags, timeout_msec int32, fd_list IUnixFDList, cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(365, "DBusProxy", "call_with_unix_fd_list")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_method_name := gi.CString(method_name)
	var tmp unsafe.Pointer
	if fd_list != nil {
		tmp = fd_list.P_UnixFDList()
	}
	var tmp1 unsafe.Pointer
	if cancellable != nil {
		tmp1 = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_method_name := gi.NewStringArgument(c_method_name)
	arg_parameters := gi.NewPointerArgument(parameters.P)
	arg_flags := gi.NewIntArgument(int(flags))
	arg_timeout_msec := gi.NewInt32Argument(timeout_msec)
	arg_fd_list := gi.NewPointerArgument(tmp)
	arg_cancellable := gi.NewPointerArgument(tmp1)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_v, arg_method_name, arg_parameters, arg_flags, arg_timeout_msec, arg_fd_list, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
	gi.Free(c_method_name)
}

// g_dbus_proxy_call_with_unix_fd_list_finish
// container is not nil, container is DBusProxy
// is method
func (v DBusProxy) CallWithUnixFdListFinish(res IAsyncResult) (result glib.Variant, out_fd_list UnixFDList, err error) {
	iv, err := _I.Get(366, "DBusProxy", "call_with_unix_fd_list_finish")
	if err != nil {
		return
	}
	var outArgs [2]gi.Argument
	var tmp unsafe.Pointer
	if res != nil {
		tmp = res.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_out_fd_list := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	arg_res := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[1]))
	args := []gi.Argument{arg_v, arg_out_fd_list, arg_res, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[1].Pointer())
	out_fd_list.P = outArgs[0].Pointer()
	result.P = ret.Pointer()
	return
}

// g_dbus_proxy_call_with_unix_fd_list_sync
// container is not nil, container is DBusProxy
// is method
func (v DBusProxy) CallWithUnixFdListSync(method_name string, parameters glib.Variant, flags DBusCallFlags, timeout_msec int32, fd_list IUnixFDList, cancellable ICancellable) (result glib.Variant, out_fd_list UnixFDList, err error) {
	iv, err := _I.Get(367, "DBusProxy", "call_with_unix_fd_list_sync")
	if err != nil {
		return
	}
	var outArgs [2]gi.Argument
	c_method_name := gi.CString(method_name)
	var tmp unsafe.Pointer
	if fd_list != nil {
		tmp = fd_list.P_UnixFDList()
	}
	var tmp1 unsafe.Pointer
	if cancellable != nil {
		tmp1 = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_method_name := gi.NewStringArgument(c_method_name)
	arg_parameters := gi.NewPointerArgument(parameters.P)
	arg_flags := gi.NewIntArgument(int(flags))
	arg_timeout_msec := gi.NewInt32Argument(timeout_msec)
	arg_fd_list := gi.NewPointerArgument(tmp)
	arg_out_fd_list := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	arg_cancellable := gi.NewPointerArgument(tmp1)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[1]))
	args := []gi.Argument{arg_v, arg_method_name, arg_parameters, arg_flags, arg_timeout_msec, arg_fd_list, arg_out_fd_list, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	gi.Free(c_method_name)
	err = gi.ToError(outArgs[1].Pointer())
	out_fd_list.P = outArgs[0].Pointer()
	result.P = ret.Pointer()
	return
}

// g_dbus_proxy_get_cached_property
// container is not nil, container is DBusProxy
// is method
func (v DBusProxy) GetCachedProperty(property_name string) (result glib.Variant) {
	iv, err := _I.Get(368, "DBusProxy", "get_cached_property")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_property_name := gi.CString(property_name)
	arg_v := gi.NewPointerArgument(v.P)
	arg_property_name := gi.NewStringArgument(c_property_name)
	args := []gi.Argument{arg_v, arg_property_name}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_property_name)
	result.P = ret.Pointer()
	return
}

// g_dbus_proxy_get_cached_property_names
// container is not nil, container is DBusProxy
// is method
func (v DBusProxy) GetCachedPropertyNames() (result gi.CStrArray) {
	iv, err := _I.Get(369, "DBusProxy", "get_cached_property_names")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = gi.CStrArray{P: ret.Pointer(), Len: -1}
	result.SetLenZT()
	return
}

// g_dbus_proxy_get_connection
// container is not nil, container is DBusProxy
// is method
func (v DBusProxy) GetConnection() (result DBusConnection) {
	iv, err := _I.Get(370, "DBusProxy", "get_connection")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_dbus_proxy_get_default_timeout
// container is not nil, container is DBusProxy
// is method
func (v DBusProxy) GetDefaultTimeout() (result int32) {
	iv, err := _I.Get(371, "DBusProxy", "get_default_timeout")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Int32()
	return
}

// g_dbus_proxy_get_flags
// container is not nil, container is DBusProxy
// is method
func (v DBusProxy) GetFlags() (result DBusProxyFlags) {
	iv, err := _I.Get(372, "DBusProxy", "get_flags")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = DBusProxyFlags(ret.Int())
	return
}

// g_dbus_proxy_get_interface_info
// container is not nil, container is DBusProxy
// is method
func (v DBusProxy) GetInterfaceInfo() (result DBusInterfaceInfo) {
	iv, err := _I.Get(373, "DBusProxy", "get_interface_info")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_dbus_proxy_get_interface_name
// container is not nil, container is DBusProxy
// is method
func (v DBusProxy) GetInterfaceName() (result string) {
	iv, err := _I.Get(374, "DBusProxy", "get_interface_name")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Take()
	return
}

// g_dbus_proxy_get_name
// container is not nil, container is DBusProxy
// is method
func (v DBusProxy) GetName() (result string) {
	iv, err := _I.Get(375, "DBusProxy", "get_name")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Take()
	return
}

// g_dbus_proxy_get_name_owner
// container is not nil, container is DBusProxy
// is method
func (v DBusProxy) GetNameOwner() (result string) {
	iv, err := _I.Get(376, "DBusProxy", "get_name_owner")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Take()
	return
}

// g_dbus_proxy_get_object_path
// container is not nil, container is DBusProxy
// is method
func (v DBusProxy) GetObjectPath() (result string) {
	iv, err := _I.Get(377, "DBusProxy", "get_object_path")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Take()
	return
}

// g_dbus_proxy_set_cached_property
// container is not nil, container is DBusProxy
// is method
func (v DBusProxy) SetCachedProperty(property_name string, value glib.Variant) {
	iv, err := _I.Get(378, "DBusProxy", "set_cached_property")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_property_name := gi.CString(property_name)
	arg_v := gi.NewPointerArgument(v.P)
	arg_property_name := gi.NewStringArgument(c_property_name)
	arg_value := gi.NewPointerArgument(value.P)
	args := []gi.Argument{arg_v, arg_property_name, arg_value}
	iv.Call(args, nil, nil)
	gi.Free(c_property_name)
}

// g_dbus_proxy_set_default_timeout
// container is not nil, container is DBusProxy
// is method
func (v DBusProxy) SetDefaultTimeout(timeout_msec int32) {
	iv, err := _I.Get(379, "DBusProxy", "set_default_timeout")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_timeout_msec := gi.NewInt32Argument(timeout_msec)
	args := []gi.Argument{arg_v, arg_timeout_msec}
	iv.Call(args, nil, nil)
}

// g_dbus_proxy_set_interface_info
// container is not nil, container is DBusProxy
// is method
func (v DBusProxy) SetInterfaceInfo(info DBusInterfaceInfo) {
	iv, err := _I.Get(380, "DBusProxy", "set_interface_info")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_info := gi.NewPointerArgument(info.P)
	args := []gi.Argument{arg_v, arg_info}
	iv.Call(args, nil, nil)
}

// ignore GType struct DBusProxyClass
// Flags DBusProxyFlags
type DBusProxyFlags int

const (
	DBusProxyFlagsNone                         DBusProxyFlags = 0
	DBusProxyFlagsDoNotLoadProperties          DBusProxyFlags = 1
	DBusProxyFlagsDoNotConnectSignals          DBusProxyFlags = 2
	DBusProxyFlagsDoNotAutoStart               DBusProxyFlags = 4
	DBusProxyFlagsGetInvalidatedProperties     DBusProxyFlags = 8
	DBusProxyFlagsDoNotAutoStartAtConstruction DBusProxyFlags = 16
)

func DBusProxyFlagsGetType() gi.GType {
	ret := _I.GetGType(76, "DBusProxyFlags")
	return ret
}

// Struct DBusProxyPrivate
type DBusProxyPrivate struct {
	P unsafe.Pointer
}

func DBusProxyPrivateGetType() gi.GType {
	ret := _I.GetGType(77, "DBusProxyPrivate")
	return ret
}

type DBusProxyTypeFuncStruct struct {
	F_manager        DBusObjectManagerClient
	F_object_path    string
	F_interface_name string
}

//export myDBusProxyTypeFunc
func myDBusProxyTypeFunc(manager *C.GDBusObjectManagerClient, object_path *C.gchar, interface_name *C.gchar, user_data C.gpointer) {
	fn := gi.GetFunc(uint(uintptr(user_data)))
	args := DBusProxyTypeFuncStruct{
		F_manager:        WrapDBusObjectManagerClient(unsafe.Pointer(manager)),
		F_object_path:    gi.GoString(unsafe.Pointer(object_path)),
		F_interface_name: gi.GoString(unsafe.Pointer(interface_name)),
	}
	fn(args)
}

// Flags DBusSendMessageFlags
type DBusSendMessageFlags int

const (
	DBusSendMessageFlagsNone           DBusSendMessageFlags = 0
	DBusSendMessageFlagsPreserveSerial DBusSendMessageFlags = 1
)

func DBusSendMessageFlagsGetType() gi.GType {
	ret := _I.GetGType(78, "DBusSendMessageFlags")
	return ret
}

// Object DBusServer
type DBusServer struct {
	InitableIfc
	gobject.Object
}

func WrapDBusServer(p unsafe.Pointer) (r DBusServer) { r.P = p; return }

type IDBusServer interface{ P_DBusServer() unsafe.Pointer }

func (v DBusServer) P_DBusServer() unsafe.Pointer { return v.P }
func (v DBusServer) P_Initable() unsafe.Pointer   { return v.P }
func DBusServerGetType() gi.GType {
	ret := _I.GetGType(79, "DBusServer")
	return ret
}

// g_dbus_server_new_sync
// container is not nil, container is DBusServer
// is constructor
func NewDBusServerSync(address string, flags DBusServerFlags, guid string, observer IDBusAuthObserver, cancellable ICancellable) (result DBusServer, err error) {
	iv, err := _I.Get(381, "DBusServer", "new_sync")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	c_address := gi.CString(address)
	c_guid := gi.CString(guid)
	var tmp unsafe.Pointer
	if observer != nil {
		tmp = observer.P_DBusAuthObserver()
	}
	var tmp1 unsafe.Pointer
	if cancellable != nil {
		tmp1 = cancellable.P_Cancellable()
	}
	arg_address := gi.NewStringArgument(c_address)
	arg_flags := gi.NewIntArgument(int(flags))
	arg_guid := gi.NewStringArgument(c_guid)
	arg_observer := gi.NewPointerArgument(tmp)
	arg_cancellable := gi.NewPointerArgument(tmp1)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_address, arg_flags, arg_guid, arg_observer, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	gi.Free(c_address)
	gi.Free(c_guid)
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// g_dbus_server_get_client_address
// container is not nil, container is DBusServer
// is method
func (v DBusServer) GetClientAddress() (result string) {
	iv, err := _I.Get(382, "DBusServer", "get_client_address")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Take()
	return
}

// g_dbus_server_get_flags
// container is not nil, container is DBusServer
// is method
func (v DBusServer) GetFlags() (result DBusServerFlags) {
	iv, err := _I.Get(383, "DBusServer", "get_flags")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = DBusServerFlags(ret.Int())
	return
}

// g_dbus_server_get_guid
// container is not nil, container is DBusServer
// is method
func (v DBusServer) GetGuid() (result string) {
	iv, err := _I.Get(384, "DBusServer", "get_guid")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Take()
	return
}

// g_dbus_server_is_active
// container is not nil, container is DBusServer
// is method
func (v DBusServer) IsActive() (result bool) {
	iv, err := _I.Get(385, "DBusServer", "is_active")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_dbus_server_start
// container is not nil, container is DBusServer
// is method
func (v DBusServer) Start() {
	iv, err := _I.Get(386, "DBusServer", "start")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	iv.Call(args, nil, nil)
}

// g_dbus_server_stop
// container is not nil, container is DBusServer
// is method
func (v DBusServer) Stop() {
	iv, err := _I.Get(387, "DBusServer", "stop")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	iv.Call(args, nil, nil)
}

// Flags DBusServerFlags
type DBusServerFlags int

const (
	DBusServerFlagsNone                         DBusServerFlags = 0
	DBusServerFlagsRunInThread                  DBusServerFlags = 1
	DBusServerFlagsAuthenticationAllowAnonymous DBusServerFlags = 2
)

func DBusServerFlagsGetType() gi.GType {
	ret := _I.GetGType(80, "DBusServerFlags")
	return ret
}

type DBusSignalCallbackStruct struct {
	F_connection     DBusConnection
	F_sender_name    string
	F_object_path    string
	F_interface_name string
	F_signal_name    string
	F_parameters     glib.Variant
}

//export myDBusSignalCallback
func myDBusSignalCallback(connection *C.GDBusConnection, sender_name *C.gchar, object_path *C.gchar, interface_name *C.gchar, signal_name *C.gchar, parameters *C.GVariant, user_data C.gpointer) {
	fn := gi.GetFunc(uint(uintptr(user_data)))
	args := DBusSignalCallbackStruct{
		F_connection:     WrapDBusConnection(unsafe.Pointer(connection)),
		F_sender_name:    gi.GoString(unsafe.Pointer(sender_name)),
		F_object_path:    gi.GoString(unsafe.Pointer(object_path)),
		F_interface_name: gi.GoString(unsafe.Pointer(interface_name)),
		F_signal_name:    gi.GoString(unsafe.Pointer(signal_name)),
		F_parameters:     glib.Variant{P: unsafe.Pointer(parameters)},
	}
	fn(args)
}

// Flags DBusSignalFlags
type DBusSignalFlags int

const (
	DBusSignalFlagsNone               DBusSignalFlags = 0
	DBusSignalFlagsNoMatchRule        DBusSignalFlags = 1
	DBusSignalFlagsMatchArg0Namespace DBusSignalFlags = 2
	DBusSignalFlagsMatchArg0Path      DBusSignalFlags = 4
)

func DBusSignalFlagsGetType() gi.GType {
	ret := _I.GetGType(81, "DBusSignalFlags")
	return ret
}

// Struct DBusSignalInfo
type DBusSignalInfo struct {
	P unsafe.Pointer
}

const SizeOfStructDBusSignalInfo = 32

func DBusSignalInfoGetType() gi.GType {
	ret := _I.GetGType(82, "DBusSignalInfo")
	return ret
}

// g_dbus_signal_info_ref
// container is not nil, container is DBusSignalInfo
// is method
func (v DBusSignalInfo) Ref() (result DBusSignalInfo) {
	iv, err := _I.Get(388, "DBusSignalInfo", "ref")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_dbus_signal_info_unref
// container is not nil, container is DBusSignalInfo
// is method
func (v DBusSignalInfo) Unref() {
	iv, err := _I.Get(389, "DBusSignalInfo", "unref")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	iv.Call(args, nil, nil)
}

type DBusSubtreeDispatchFuncStruct struct {
	F_connection     DBusConnection
	F_sender         string
	F_object_path    string
	F_interface_name string
	F_node           string
	F_out_user_data  unsafe.Pointer
}

//export myDBusSubtreeDispatchFunc
func myDBusSubtreeDispatchFunc(connection *C.GDBusConnection, sender *C.gchar, object_path *C.gchar, interface_name *C.gchar, node *C.gchar, out_user_data C.gpointer, user_data C.gpointer) {
	fn := gi.GetFunc(uint(uintptr(user_data)))
	args := DBusSubtreeDispatchFuncStruct{
		F_connection:     WrapDBusConnection(unsafe.Pointer(connection)),
		F_sender:         gi.GoString(unsafe.Pointer(sender)),
		F_object_path:    gi.GoString(unsafe.Pointer(object_path)),
		F_interface_name: gi.GoString(unsafe.Pointer(interface_name)),
		F_node:           gi.GoString(unsafe.Pointer(node)),
		F_out_user_data:  unsafe.Pointer(out_user_data),
	}
	fn(args)
}

// Flags DBusSubtreeFlags
type DBusSubtreeFlags int

const (
	DBusSubtreeFlagsNone                        DBusSubtreeFlags = 0
	DBusSubtreeFlagsDispatchToUnenumeratedNodes DBusSubtreeFlags = 1
)

func DBusSubtreeFlagsGetType() gi.GType {
	ret := _I.GetGType(83, "DBusSubtreeFlags")
	return ret
}

type DBusSubtreeIntrospectFuncStruct struct {
	F_connection  DBusConnection
	F_sender      string
	F_object_path string
	F_node        string
}

//export myDBusSubtreeIntrospectFunc
func myDBusSubtreeIntrospectFunc(connection *C.GDBusConnection, sender *C.gchar, object_path *C.gchar, node *C.gchar, user_data C.gpointer) {
	fn := gi.GetFunc(uint(uintptr(user_data)))
	args := DBusSubtreeIntrospectFuncStruct{
		F_connection:  WrapDBusConnection(unsafe.Pointer(connection)),
		F_sender:      gi.GoString(unsafe.Pointer(sender)),
		F_object_path: gi.GoString(unsafe.Pointer(object_path)),
		F_node:        gi.GoString(unsafe.Pointer(node)),
	}
	fn(args)
}

// Struct DBusSubtreeVTable
type DBusSubtreeVTable struct {
	P unsafe.Pointer
}

const SizeOfStructDBusSubtreeVTable = 88

func DBusSubtreeVTableGetType() gi.GType {
	ret := _I.GetGType(84, "DBusSubtreeVTable")
	return ret
}

// Object DataInputStream
type DataInputStream struct {
	SeekableIfc
	BufferedInputStream
}

func WrapDataInputStream(p unsafe.Pointer) (r DataInputStream) { r.P = p; return }

type IDataInputStream interface{ P_DataInputStream() unsafe.Pointer }

func (v DataInputStream) P_DataInputStream() unsafe.Pointer { return v.P }
func (v DataInputStream) P_Seekable() unsafe.Pointer        { return v.P }
func DataInputStreamGetType() gi.GType {
	ret := _I.GetGType(85, "DataInputStream")
	return ret
}

// g_data_input_stream_new
// container is not nil, container is DataInputStream
// is constructor
func NewDataInputStream(base_stream IInputStream) (result DataInputStream) {
	iv, err := _I.Get(390, "DataInputStream", "new")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if base_stream != nil {
		tmp = base_stream.P_InputStream()
	}
	arg_base_stream := gi.NewPointerArgument(tmp)
	args := []gi.Argument{arg_base_stream}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_data_input_stream_get_byte_order
// container is not nil, container is DataInputStream
// is method
func (v DataInputStream) GetByteOrder() (result DataStreamByteOrderEnum) {
	iv, err := _I.Get(391, "DataInputStream", "get_byte_order")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = DataStreamByteOrderEnum(ret.Int())
	return
}

// g_data_input_stream_get_newline_type
// container is not nil, container is DataInputStream
// is method
func (v DataInputStream) GetNewlineType() (result DataStreamNewlineTypeEnum) {
	iv, err := _I.Get(392, "DataInputStream", "get_newline_type")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = DataStreamNewlineTypeEnum(ret.Int())
	return
}

// g_data_input_stream_read_byte
// container is not nil, container is DataInputStream
// is method
func (v DataInputStream) ReadByte(cancellable ICancellable) (result uint8, err error) {
	iv, err := _I.Get(393, "DataInputStream", "read_byte")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Uint8()
	return
}

// g_data_input_stream_read_int16
// container is not nil, container is DataInputStream
// is method
func (v DataInputStream) ReadInt16(cancellable ICancellable) (result int16, err error) {
	iv, err := _I.Get(394, "DataInputStream", "read_int16")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Int16()
	return
}

// g_data_input_stream_read_int32
// container is not nil, container is DataInputStream
// is method
func (v DataInputStream) ReadInt32(cancellable ICancellable) (result int32, err error) {
	iv, err := _I.Get(395, "DataInputStream", "read_int32")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Int32()
	return
}

// g_data_input_stream_read_int64
// container is not nil, container is DataInputStream
// is method
func (v DataInputStream) ReadInt64(cancellable ICancellable) (result int64, err error) {
	iv, err := _I.Get(396, "DataInputStream", "read_int64")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Int64()
	return
}

// g_data_input_stream_read_line
// container is not nil, container is DataInputStream
// is method
func (v DataInputStream) ReadLine(cancellable ICancellable) (result gi.Uint8Array, length uint64, err error) {
	iv, err := _I.Get(397, "DataInputStream", "read_line")
	if err != nil {
		return
	}
	var outArgs [2]gi.Argument
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_length := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[1]))
	args := []gi.Argument{arg_v, arg_length, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[1].Pointer())
	length = outArgs[0].Uint64()
	result = gi.Uint8Array{P: ret.Pointer(), Len: int(0)}
	return
}

// g_data_input_stream_read_line_async
// container is not nil, container is DataInputStream
// is method
func (v DataInputStream) ReadLineAsync(io_priority int32, cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(398, "DataInputStream", "read_line_async")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_io_priority := gi.NewInt32Argument(io_priority)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_v, arg_io_priority, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
}

// g_data_input_stream_read_line_finish
// container is not nil, container is DataInputStream
// is method
func (v DataInputStream) ReadLineFinish(result IAsyncResult) (result1 gi.Uint8Array, length uint64, err error) {
	iv, err := _I.Get(399, "DataInputStream", "read_line_finish")
	if err != nil {
		return
	}
	var outArgs [2]gi.Argument
	var tmp unsafe.Pointer
	if result != nil {
		tmp = result.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_result := gi.NewPointerArgument(tmp)
	arg_length := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[1]))
	args := []gi.Argument{arg_v, arg_result, arg_length, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[1].Pointer())
	length = outArgs[0].Uint64()
	result1 = gi.Uint8Array{P: ret.Pointer(), Len: int(0)}
	return
}

// g_data_input_stream_read_line_finish_utf8
// container is not nil, container is DataInputStream
// is method
func (v DataInputStream) ReadLineFinishUtf8(result IAsyncResult) (result1 string, length uint64, err error) {
	iv, err := _I.Get(400, "DataInputStream", "read_line_finish_utf8")
	if err != nil {
		return
	}
	var outArgs [2]gi.Argument
	var tmp unsafe.Pointer
	if result != nil {
		tmp = result.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_result := gi.NewPointerArgument(tmp)
	arg_length := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[1]))
	args := []gi.Argument{arg_v, arg_result, arg_length, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[1].Pointer())
	length = outArgs[0].Uint64()
	result1 = ret.String().Take()
	return
}

// g_data_input_stream_read_line_utf8
// container is not nil, container is DataInputStream
// is method
func (v DataInputStream) ReadLineUtf8(cancellable ICancellable) (result string, length uint64, err error) {
	iv, err := _I.Get(401, "DataInputStream", "read_line_utf8")
	if err != nil {
		return
	}
	var outArgs [2]gi.Argument
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_length := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[1]))
	args := []gi.Argument{arg_v, arg_length, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[1].Pointer())
	length = outArgs[0].Uint64()
	result = ret.String().Take()
	return
}

// g_data_input_stream_read_uint16
// container is not nil, container is DataInputStream
// is method
func (v DataInputStream) ReadUint16(cancellable ICancellable) (result uint16, err error) {
	iv, err := _I.Get(402, "DataInputStream", "read_uint16")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Uint16()
	return
}

// g_data_input_stream_read_uint32
// container is not nil, container is DataInputStream
// is method
func (v DataInputStream) ReadUint32(cancellable ICancellable) (result uint32, err error) {
	iv, err := _I.Get(403, "DataInputStream", "read_uint32")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Uint32()
	return
}

// g_data_input_stream_read_uint64
// container is not nil, container is DataInputStream
// is method
func (v DataInputStream) ReadUint64(cancellable ICancellable) (result uint64, err error) {
	iv, err := _I.Get(404, "DataInputStream", "read_uint64")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Uint64()
	return
}

// g_data_input_stream_read_until
// container is not nil, container is DataInputStream
// is method
func (v DataInputStream) ReadUntil(stop_chars string, cancellable ICancellable) (result string, length uint64, err error) {
	iv, err := _I.Get(405, "DataInputStream", "read_until")
	if err != nil {
		return
	}
	var outArgs [2]gi.Argument
	c_stop_chars := gi.CString(stop_chars)
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_stop_chars := gi.NewStringArgument(c_stop_chars)
	arg_length := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[1]))
	args := []gi.Argument{arg_v, arg_stop_chars, arg_length, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	gi.Free(c_stop_chars)
	err = gi.ToError(outArgs[1].Pointer())
	length = outArgs[0].Uint64()
	result = ret.String().Take()
	return
}

// g_data_input_stream_read_until_async
// container is not nil, container is DataInputStream
// is method
func (v DataInputStream) ReadUntilAsync(stop_chars string, io_priority int32, cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(406, "DataInputStream", "read_until_async")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_stop_chars := gi.CString(stop_chars)
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_stop_chars := gi.NewStringArgument(c_stop_chars)
	arg_io_priority := gi.NewInt32Argument(io_priority)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_v, arg_stop_chars, arg_io_priority, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
	gi.Free(c_stop_chars)
}

// g_data_input_stream_read_until_finish
// container is not nil, container is DataInputStream
// is method
func (v DataInputStream) ReadUntilFinish(result IAsyncResult) (result1 string, length uint64, err error) {
	iv, err := _I.Get(407, "DataInputStream", "read_until_finish")
	if err != nil {
		return
	}
	var outArgs [2]gi.Argument
	var tmp unsafe.Pointer
	if result != nil {
		tmp = result.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_result := gi.NewPointerArgument(tmp)
	arg_length := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[1]))
	args := []gi.Argument{arg_v, arg_result, arg_length, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[1].Pointer())
	length = outArgs[0].Uint64()
	result1 = ret.String().Take()
	return
}

// g_data_input_stream_read_upto
// container is not nil, container is DataInputStream
// is method
func (v DataInputStream) ReadUpto(stop_chars string, stop_chars_len int64, cancellable ICancellable) (result string, length uint64, err error) {
	iv, err := _I.Get(408, "DataInputStream", "read_upto")
	if err != nil {
		return
	}
	var outArgs [2]gi.Argument
	c_stop_chars := gi.CString(stop_chars)
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_stop_chars := gi.NewStringArgument(c_stop_chars)
	arg_stop_chars_len := gi.NewInt64Argument(stop_chars_len)
	arg_length := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[1]))
	args := []gi.Argument{arg_v, arg_stop_chars, arg_stop_chars_len, arg_length, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	gi.Free(c_stop_chars)
	err = gi.ToError(outArgs[1].Pointer())
	length = outArgs[0].Uint64()
	result = ret.String().Take()
	return
}

// g_data_input_stream_read_upto_async
// container is not nil, container is DataInputStream
// is method
func (v DataInputStream) ReadUptoAsync(stop_chars string, stop_chars_len int64, io_priority int32, cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(409, "DataInputStream", "read_upto_async")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_stop_chars := gi.CString(stop_chars)
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_stop_chars := gi.NewStringArgument(c_stop_chars)
	arg_stop_chars_len := gi.NewInt64Argument(stop_chars_len)
	arg_io_priority := gi.NewInt32Argument(io_priority)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_v, arg_stop_chars, arg_stop_chars_len, arg_io_priority, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
	gi.Free(c_stop_chars)
}

// g_data_input_stream_read_upto_finish
// container is not nil, container is DataInputStream
// is method
func (v DataInputStream) ReadUptoFinish(result IAsyncResult) (result1 string, length uint64, err error) {
	iv, err := _I.Get(410, "DataInputStream", "read_upto_finish")
	if err != nil {
		return
	}
	var outArgs [2]gi.Argument
	var tmp unsafe.Pointer
	if result != nil {
		tmp = result.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_result := gi.NewPointerArgument(tmp)
	arg_length := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[1]))
	args := []gi.Argument{arg_v, arg_result, arg_length, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[1].Pointer())
	length = outArgs[0].Uint64()
	result1 = ret.String().Take()
	return
}

// g_data_input_stream_set_byte_order
// container is not nil, container is DataInputStream
// is method
func (v DataInputStream) SetByteOrder(order DataStreamByteOrderEnum) {
	iv, err := _I.Get(411, "DataInputStream", "set_byte_order")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_order := gi.NewIntArgument(int(order))
	args := []gi.Argument{arg_v, arg_order}
	iv.Call(args, nil, nil)
}

// g_data_input_stream_set_newline_type
// container is not nil, container is DataInputStream
// is method
func (v DataInputStream) SetNewlineType(type1 DataStreamNewlineTypeEnum) {
	iv, err := _I.Get(412, "DataInputStream", "set_newline_type")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_type1 := gi.NewIntArgument(int(type1))
	args := []gi.Argument{arg_v, arg_type1}
	iv.Call(args, nil, nil)
}

// ignore GType struct DataInputStreamClass
// Struct DataInputStreamPrivate
type DataInputStreamPrivate struct {
	P unsafe.Pointer
}

func DataInputStreamPrivateGetType() gi.GType {
	ret := _I.GetGType(86, "DataInputStreamPrivate")
	return ret
}

// Object DataOutputStream
type DataOutputStream struct {
	SeekableIfc
	FilterOutputStream
}

func WrapDataOutputStream(p unsafe.Pointer) (r DataOutputStream) { r.P = p; return }

type IDataOutputStream interface{ P_DataOutputStream() unsafe.Pointer }

func (v DataOutputStream) P_DataOutputStream() unsafe.Pointer { return v.P }
func (v DataOutputStream) P_Seekable() unsafe.Pointer         { return v.P }
func DataOutputStreamGetType() gi.GType {
	ret := _I.GetGType(87, "DataOutputStream")
	return ret
}

// g_data_output_stream_new
// container is not nil, container is DataOutputStream
// is constructor
func NewDataOutputStream(base_stream IOutputStream) (result DataOutputStream) {
	iv, err := _I.Get(413, "DataOutputStream", "new")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if base_stream != nil {
		tmp = base_stream.P_OutputStream()
	}
	arg_base_stream := gi.NewPointerArgument(tmp)
	args := []gi.Argument{arg_base_stream}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_data_output_stream_get_byte_order
// container is not nil, container is DataOutputStream
// is method
func (v DataOutputStream) GetByteOrder() (result DataStreamByteOrderEnum) {
	iv, err := _I.Get(414, "DataOutputStream", "get_byte_order")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = DataStreamByteOrderEnum(ret.Int())
	return
}

// g_data_output_stream_put_byte
// container is not nil, container is DataOutputStream
// is method
func (v DataOutputStream) PutByte(data uint8, cancellable ICancellable) (result bool, err error) {
	iv, err := _I.Get(415, "DataOutputStream", "put_byte")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_data := gi.NewUint8Argument(data)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_data, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Bool()
	return
}

// g_data_output_stream_put_int16
// container is not nil, container is DataOutputStream
// is method
func (v DataOutputStream) PutInt16(data int16, cancellable ICancellable) (result bool, err error) {
	iv, err := _I.Get(416, "DataOutputStream", "put_int16")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_data := gi.NewInt16Argument(data)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_data, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Bool()
	return
}

// g_data_output_stream_put_int32
// container is not nil, container is DataOutputStream
// is method
func (v DataOutputStream) PutInt32(data int32, cancellable ICancellable) (result bool, err error) {
	iv, err := _I.Get(417, "DataOutputStream", "put_int32")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_data := gi.NewInt32Argument(data)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_data, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Bool()
	return
}

// g_data_output_stream_put_int64
// container is not nil, container is DataOutputStream
// is method
func (v DataOutputStream) PutInt64(data int64, cancellable ICancellable) (result bool, err error) {
	iv, err := _I.Get(418, "DataOutputStream", "put_int64")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_data := gi.NewInt64Argument(data)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_data, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Bool()
	return
}

// g_data_output_stream_put_string
// container is not nil, container is DataOutputStream
// is method
func (v DataOutputStream) PutString(str string, cancellable ICancellable) (result bool, err error) {
	iv, err := _I.Get(419, "DataOutputStream", "put_string")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	c_str := gi.CString(str)
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_str := gi.NewStringArgument(c_str)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_str, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	gi.Free(c_str)
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Bool()
	return
}

// g_data_output_stream_put_uint16
// container is not nil, container is DataOutputStream
// is method
func (v DataOutputStream) PutUint16(data uint16, cancellable ICancellable) (result bool, err error) {
	iv, err := _I.Get(420, "DataOutputStream", "put_uint16")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_data := gi.NewUint16Argument(data)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_data, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Bool()
	return
}

// g_data_output_stream_put_uint32
// container is not nil, container is DataOutputStream
// is method
func (v DataOutputStream) PutUint32(data uint32, cancellable ICancellable) (result bool, err error) {
	iv, err := _I.Get(421, "DataOutputStream", "put_uint32")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_data := gi.NewUint32Argument(data)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_data, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Bool()
	return
}

// g_data_output_stream_put_uint64
// container is not nil, container is DataOutputStream
// is method
func (v DataOutputStream) PutUint64(data uint64, cancellable ICancellable) (result bool, err error) {
	iv, err := _I.Get(422, "DataOutputStream", "put_uint64")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_data := gi.NewUint64Argument(data)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_data, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Bool()
	return
}

// g_data_output_stream_set_byte_order
// container is not nil, container is DataOutputStream
// is method
func (v DataOutputStream) SetByteOrder(order DataStreamByteOrderEnum) {
	iv, err := _I.Get(423, "DataOutputStream", "set_byte_order")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_order := gi.NewIntArgument(int(order))
	args := []gi.Argument{arg_v, arg_order}
	iv.Call(args, nil, nil)
}

// ignore GType struct DataOutputStreamClass
// Struct DataOutputStreamPrivate
type DataOutputStreamPrivate struct {
	P unsafe.Pointer
}

func DataOutputStreamPrivateGetType() gi.GType {
	ret := _I.GetGType(88, "DataOutputStreamPrivate")
	return ret
}

// Enum DataStreamByteOrder
type DataStreamByteOrderEnum int

const (
	DataStreamByteOrderBigEndian    DataStreamByteOrderEnum = 0
	DataStreamByteOrderLittleEndian DataStreamByteOrderEnum = 1
	DataStreamByteOrderHostEndian   DataStreamByteOrderEnum = 2
)

func DataStreamByteOrderGetType() gi.GType {
	ret := _I.GetGType(89, "DataStreamByteOrder")
	return ret
}

// Enum DataStreamNewlineType
type DataStreamNewlineTypeEnum int

const (
	DataStreamNewlineTypeLf   DataStreamNewlineTypeEnum = 0
	DataStreamNewlineTypeCr   DataStreamNewlineTypeEnum = 1
	DataStreamNewlineTypeCrLf DataStreamNewlineTypeEnum = 2
	DataStreamNewlineTypeAny  DataStreamNewlineTypeEnum = 3
)

func DataStreamNewlineTypeGetType() gi.GType {
	ret := _I.GetGType(90, "DataStreamNewlineType")
	return ret
}

// Interface DatagramBased
type DatagramBased struct {
	DatagramBasedIfc
	P unsafe.Pointer
}
type DatagramBasedIfc struct{}
type IDatagramBased interface{ P_DatagramBased() unsafe.Pointer }

func (v DatagramBased) P_DatagramBased() unsafe.Pointer { return v.P }
func DatagramBasedGetType() gi.GType {
	ret := _I.GetGType(91, "DatagramBased")
	return ret
}

// g_datagram_based_condition_check
// container is not nil, container is DatagramBased
// is method
func (v *DatagramBasedIfc) ConditionCheck(condition glib.IOConditionFlags) (result glib.IOConditionFlags) {
	iv, err := _I.Get(424, "DatagramBased", "condition_check")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_condition := gi.NewIntArgument(int(condition))
	args := []gi.Argument{arg_v, arg_condition}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = glib.IOConditionFlags(ret.Int())
	return
}

// g_datagram_based_condition_wait
// container is not nil, container is DatagramBased
// is method
func (v *DatagramBasedIfc) ConditionWait(condition glib.IOConditionFlags, timeout int64, cancellable ICancellable) (result bool, err error) {
	iv, err := _I.Get(425, "DatagramBased", "condition_wait")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_condition := gi.NewIntArgument(int(condition))
	arg_timeout := gi.NewInt64Argument(timeout)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_condition, arg_timeout, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Bool()
	return
}

// g_datagram_based_create_source
// container is not nil, container is DatagramBased
// is method
func (v *DatagramBasedIfc) CreateSource(condition glib.IOConditionFlags, cancellable ICancellable) (result glib.Source) {
	iv, err := _I.Get(426, "DatagramBased", "create_source")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_condition := gi.NewIntArgument(int(condition))
	arg_cancellable := gi.NewPointerArgument(tmp)
	args := []gi.Argument{arg_v, arg_condition, arg_cancellable}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_datagram_based_receive_messages
// container is not nil, container is DatagramBased
// is method
// arg 0 messages lenArgIdx 1
func (v *DatagramBasedIfc) ReceiveMessages(messages unsafe.Pointer, num_messages uint32, flags int32, timeout int64, cancellable ICancellable) (result int32, err error) {
	iv, err := _I.Get(427, "DatagramBased", "receive_messages")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_messages := gi.NewPointerArgument(messages)
	arg_num_messages := gi.NewUint32Argument(num_messages)
	arg_flags := gi.NewInt32Argument(flags)
	arg_timeout := gi.NewInt64Argument(timeout)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_messages, arg_num_messages, arg_flags, arg_timeout, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Int32()
	return
}

// g_datagram_based_send_messages
// container is not nil, container is DatagramBased
// is method
// arg 0 messages lenArgIdx 1
func (v *DatagramBasedIfc) SendMessages(messages unsafe.Pointer, num_messages uint32, flags int32, timeout int64, cancellable ICancellable) (result int32, err error) {
	iv, err := _I.Get(428, "DatagramBased", "send_messages")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_messages := gi.NewPointerArgument(messages)
	arg_num_messages := gi.NewUint32Argument(num_messages)
	arg_flags := gi.NewInt32Argument(flags)
	arg_timeout := gi.NewInt64Argument(timeout)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_messages, arg_num_messages, arg_flags, arg_timeout, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Int32()
	return
}

// ignore GType struct DatagramBasedInterface
type DatagramBasedSourceFuncStruct struct {
	F_datagram_based DatagramBased
	F_condition      glib.IOConditionFlags
}

//export myDatagramBasedSourceFunc
func myDatagramBasedSourceFunc(datagram_based *C.GDatagramBased, condition C.GIOCondition, user_data C.gpointer) {
	fn := gi.GetFunc(uint(uintptr(user_data)))
	args := DatagramBasedSourceFuncStruct{
		F_datagram_based: DatagramBased{P: unsafe.Pointer(datagram_based)},
		F_condition:      glib.IOConditionFlags(condition),
	}
	fn(args)
}

// Object DesktopAppInfo
type DesktopAppInfo struct {
	AppInfoIfc
	gobject.Object
}

func WrapDesktopAppInfo(p unsafe.Pointer) (r DesktopAppInfo) { r.P = p; return }

type IDesktopAppInfo interface{ P_DesktopAppInfo() unsafe.Pointer }

func (v DesktopAppInfo) P_DesktopAppInfo() unsafe.Pointer { return v.P }
func (v DesktopAppInfo) P_AppInfo() unsafe.Pointer        { return v.P }
func DesktopAppInfoGetType() gi.GType {
	ret := _I.GetGType(92, "DesktopAppInfo")
	return ret
}

// g_desktop_app_info_new
// container is not nil, container is DesktopAppInfo
// is constructor
func NewDesktopAppInfo(desktop_id string) (result DesktopAppInfo) {
	iv, err := _I.Get(429, "DesktopAppInfo", "new")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_desktop_id := gi.CString(desktop_id)
	arg_desktop_id := gi.NewStringArgument(c_desktop_id)
	args := []gi.Argument{arg_desktop_id}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_desktop_id)
	result.P = ret.Pointer()
	return
}

// g_desktop_app_info_new_from_filename
// container is not nil, container is DesktopAppInfo
// is constructor
func NewDesktopAppInfoFromFilename(filename string) (result DesktopAppInfo) {
	iv, err := _I.Get(430, "DesktopAppInfo", "new_from_filename")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_filename := gi.CString(filename)
	arg_filename := gi.NewStringArgument(c_filename)
	args := []gi.Argument{arg_filename}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_filename)
	result.P = ret.Pointer()
	return
}

// g_desktop_app_info_new_from_keyfile
// container is not nil, container is DesktopAppInfo
// is constructor
func NewDesktopAppInfoFromKeyfile(key_file glib.KeyFile) (result DesktopAppInfo) {
	iv, err := _I.Get(431, "DesktopAppInfo", "new_from_keyfile")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_key_file := gi.NewPointerArgument(key_file.P)
	args := []gi.Argument{arg_key_file}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_desktop_app_info_get_implementations
// container is not nil, container is DesktopAppInfo
// is method
// arg0Type tag: utf8, isPtr: true
func DesktopAppInfoGetImplementations1(interface1 string) (result glib.List) {
	iv, err := _I.Get(432, "DesktopAppInfo", "get_implementations")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_interface1 := gi.CString(interface1)
	arg_interface1 := gi.NewStringArgument(c_interface1)
	args := []gi.Argument{arg_interface1}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_interface1)
	result.P = ret.Pointer()
	return
}

// g_desktop_app_info_search
// container is not nil, container is DesktopAppInfo
// is method
// arg0Type tag: utf8, isPtr: true
func DesktopAppInfoSearch1(search_string string) (result int /*TODO_TYPE array type c, elemTypeTag: array, isPtr: true*/) {
	iv, err := _I.Get(433, "DesktopAppInfo", "search")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_search_string := gi.CString(search_string)
	arg_search_string := gi.NewStringArgument(c_search_string)
	args := []gi.Argument{arg_search_string}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_search_string)
	result = ret.Int() /*TODO*/
	return
}

// g_desktop_app_info_set_desktop_env
// container is not nil, container is DesktopAppInfo
// is method
// arg0Type tag: utf8, isPtr: true
func DesktopAppInfoSetDesktopEnv1(desktop_env string) {
	iv, err := _I.Get(434, "DesktopAppInfo", "set_desktop_env")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_desktop_env := gi.CString(desktop_env)
	arg_desktop_env := gi.NewStringArgument(c_desktop_env)
	args := []gi.Argument{arg_desktop_env}
	iv.Call(args, nil, nil)
	gi.Free(c_desktop_env)
}

// g_desktop_app_info_get_action_name
// container is not nil, container is DesktopAppInfo
// is method
func (v DesktopAppInfo) GetActionName(action_name string) (result string) {
	iv, err := _I.Get(435, "DesktopAppInfo", "get_action_name")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_action_name := gi.CString(action_name)
	arg_v := gi.NewPointerArgument(v.P)
	arg_action_name := gi.NewStringArgument(c_action_name)
	args := []gi.Argument{arg_v, arg_action_name}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_action_name)
	result = ret.String().Take()
	return
}

// g_desktop_app_info_get_boolean
// container is not nil, container is DesktopAppInfo
// is method
func (v DesktopAppInfo) GetBoolean(key string) (result bool) {
	iv, err := _I.Get(436, "DesktopAppInfo", "get_boolean")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_key := gi.CString(key)
	arg_v := gi.NewPointerArgument(v.P)
	arg_key := gi.NewStringArgument(c_key)
	args := []gi.Argument{arg_v, arg_key}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_key)
	result = ret.Bool()
	return
}

// g_desktop_app_info_get_categories
// container is not nil, container is DesktopAppInfo
// is method
func (v DesktopAppInfo) GetCategories() (result string) {
	iv, err := _I.Get(437, "DesktopAppInfo", "get_categories")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Take()
	return
}

// g_desktop_app_info_get_filename
// container is not nil, container is DesktopAppInfo
// is method
func (v DesktopAppInfo) GetFilename() (result string) {
	iv, err := _I.Get(438, "DesktopAppInfo", "get_filename")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Take()
	return
}

// g_desktop_app_info_get_generic_name
// container is not nil, container is DesktopAppInfo
// is method
func (v DesktopAppInfo) GetGenericName() (result string) {
	iv, err := _I.Get(439, "DesktopAppInfo", "get_generic_name")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Take()
	return
}

// g_desktop_app_info_get_is_hidden
// container is not nil, container is DesktopAppInfo
// is method
func (v DesktopAppInfo) GetIsHidden() (result bool) {
	iv, err := _I.Get(440, "DesktopAppInfo", "get_is_hidden")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_desktop_app_info_get_keywords
// container is not nil, container is DesktopAppInfo
// is method
func (v DesktopAppInfo) GetKeywords() (result gi.CStrArray) {
	iv, err := _I.Get(441, "DesktopAppInfo", "get_keywords")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = gi.CStrArray{P: ret.Pointer(), Len: -1}
	result.SetLenZT()
	return
}

// g_desktop_app_info_get_locale_string
// container is not nil, container is DesktopAppInfo
// is method
func (v DesktopAppInfo) GetLocaleString(key string) (result string) {
	iv, err := _I.Get(442, "DesktopAppInfo", "get_locale_string")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_key := gi.CString(key)
	arg_v := gi.NewPointerArgument(v.P)
	arg_key := gi.NewStringArgument(c_key)
	args := []gi.Argument{arg_v, arg_key}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_key)
	result = ret.String().Take()
	return
}

// g_desktop_app_info_get_nodisplay
// container is not nil, container is DesktopAppInfo
// is method
func (v DesktopAppInfo) GetNodisplay() (result bool) {
	iv, err := _I.Get(443, "DesktopAppInfo", "get_nodisplay")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_desktop_app_info_get_show_in
// container is not nil, container is DesktopAppInfo
// is method
func (v DesktopAppInfo) GetShowIn(desktop_env string) (result bool) {
	iv, err := _I.Get(444, "DesktopAppInfo", "get_show_in")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_desktop_env := gi.CString(desktop_env)
	arg_v := gi.NewPointerArgument(v.P)
	arg_desktop_env := gi.NewStringArgument(c_desktop_env)
	args := []gi.Argument{arg_v, arg_desktop_env}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_desktop_env)
	result = ret.Bool()
	return
}

// g_desktop_app_info_get_startup_wm_class
// container is not nil, container is DesktopAppInfo
// is method
func (v DesktopAppInfo) GetStartupWmClass() (result string) {
	iv, err := _I.Get(445, "DesktopAppInfo", "get_startup_wm_class")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Take()
	return
}

// g_desktop_app_info_get_string
// container is not nil, container is DesktopAppInfo
// is method
func (v DesktopAppInfo) GetString(key string) (result string) {
	iv, err := _I.Get(446, "DesktopAppInfo", "get_string")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_key := gi.CString(key)
	arg_v := gi.NewPointerArgument(v.P)
	arg_key := gi.NewStringArgument(c_key)
	args := []gi.Argument{arg_v, arg_key}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_key)
	result = ret.String().Take()
	return
}

// g_desktop_app_info_has_key
// container is not nil, container is DesktopAppInfo
// is method
func (v DesktopAppInfo) HasKey(key string) (result bool) {
	iv, err := _I.Get(447, "DesktopAppInfo", "has_key")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_key := gi.CString(key)
	arg_v := gi.NewPointerArgument(v.P)
	arg_key := gi.NewStringArgument(c_key)
	args := []gi.Argument{arg_v, arg_key}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_key)
	result = ret.Bool()
	return
}

// g_desktop_app_info_launch_action
// container is not nil, container is DesktopAppInfo
// is method
func (v DesktopAppInfo) LaunchAction(action_name string, launch_context IAppLaunchContext) {
	iv, err := _I.Get(448, "DesktopAppInfo", "launch_action")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_action_name := gi.CString(action_name)
	var tmp unsafe.Pointer
	if launch_context != nil {
		tmp = launch_context.P_AppLaunchContext()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_action_name := gi.NewStringArgument(c_action_name)
	arg_launch_context := gi.NewPointerArgument(tmp)
	args := []gi.Argument{arg_v, arg_action_name, arg_launch_context}
	iv.Call(args, nil, nil)
	gi.Free(c_action_name)
}

// g_desktop_app_info_launch_uris_as_manager
// container is not nil, container is DesktopAppInfo
// is method
func (v DesktopAppInfo) LaunchUrisAsManager(uris glib.List, launch_context IAppLaunchContext, spawn_flags glib.SpawnFlags, user_setup int /*TODO_TYPE isPtr: false, tag: interface*/, user_setup_data unsafe.Pointer, pid_callback int /*TODO_TYPE isPtr: false, tag: interface*/, pid_callback_data unsafe.Pointer) (result bool, err error) {
	iv, err := _I.Get(449, "DesktopAppInfo", "launch_uris_as_manager")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if launch_context != nil {
		tmp = launch_context.P_AppLaunchContext()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_uris := gi.NewPointerArgument(uris.P)
	arg_launch_context := gi.NewPointerArgument(tmp)
	arg_spawn_flags := gi.NewIntArgument(int(spawn_flags))
	arg_user_setup := gi.NewIntArgument(user_setup) /*TODO*/
	arg_user_setup_data := gi.NewPointerArgument(user_setup_data)
	arg_pid_callback := gi.NewIntArgument(pid_callback) /*TODO*/
	arg_pid_callback_data := gi.NewPointerArgument(pid_callback_data)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_uris, arg_launch_context, arg_spawn_flags, arg_user_setup, arg_user_setup_data, arg_pid_callback, arg_pid_callback_data, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Bool()
	return
}

// g_desktop_app_info_launch_uris_as_manager_with_fds
// container is not nil, container is DesktopAppInfo
// is method
func (v DesktopAppInfo) LaunchUrisAsManagerWithFds(uris glib.List, launch_context IAppLaunchContext, spawn_flags glib.SpawnFlags, user_setup int /*TODO_TYPE isPtr: false, tag: interface*/, user_setup_data unsafe.Pointer, pid_callback int /*TODO_TYPE isPtr: false, tag: interface*/, pid_callback_data unsafe.Pointer, stdin_fd int32, stdout_fd int32, stderr_fd int32) (result bool, err error) {
	iv, err := _I.Get(450, "DesktopAppInfo", "launch_uris_as_manager_with_fds")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if launch_context != nil {
		tmp = launch_context.P_AppLaunchContext()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_uris := gi.NewPointerArgument(uris.P)
	arg_launch_context := gi.NewPointerArgument(tmp)
	arg_spawn_flags := gi.NewIntArgument(int(spawn_flags))
	arg_user_setup := gi.NewIntArgument(user_setup) /*TODO*/
	arg_user_setup_data := gi.NewPointerArgument(user_setup_data)
	arg_pid_callback := gi.NewIntArgument(pid_callback) /*TODO*/
	arg_pid_callback_data := gi.NewPointerArgument(pid_callback_data)
	arg_stdin_fd := gi.NewInt32Argument(stdin_fd)
	arg_stdout_fd := gi.NewInt32Argument(stdout_fd)
	arg_stderr_fd := gi.NewInt32Argument(stderr_fd)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_uris, arg_launch_context, arg_spawn_flags, arg_user_setup, arg_user_setup_data, arg_pid_callback, arg_pid_callback_data, arg_stdin_fd, arg_stdout_fd, arg_stderr_fd, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Bool()
	return
}

// g_desktop_app_info_list_actions
// container is not nil, container is DesktopAppInfo
// is method
func (v DesktopAppInfo) ListActions() (result gi.CStrArray) {
	iv, err := _I.Get(451, "DesktopAppInfo", "list_actions")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = gi.CStrArray{P: ret.Pointer(), Len: -1}
	result.SetLenZT()
	return
}

// ignore GType struct DesktopAppInfoClass
// Interface DesktopAppInfoLookup
type DesktopAppInfoLookup struct {
	DesktopAppInfoLookupIfc
	P unsafe.Pointer
}
type DesktopAppInfoLookupIfc struct{}
type IDesktopAppInfoLookup interface{ P_DesktopAppInfoLookup() unsafe.Pointer }

func (v DesktopAppInfoLookup) P_DesktopAppInfoLookup() unsafe.Pointer { return v.P }
func DesktopAppInfoLookupGetType() gi.GType {
	ret := _I.GetGType(93, "DesktopAppInfoLookup")
	return ret
}

// g_desktop_app_info_lookup_get_default_for_uri_scheme
// container is not nil, container is DesktopAppInfoLookup
// is method
func (v *DesktopAppInfoLookupIfc) GetDefaultForUriScheme(uri_scheme string) (result AppInfo) {
	iv, err := _I.Get(452, "DesktopAppInfoLookup", "get_default_for_uri_scheme")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_uri_scheme := gi.CString(uri_scheme)
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_uri_scheme := gi.NewStringArgument(c_uri_scheme)
	args := []gi.Argument{arg_v, arg_uri_scheme}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_uri_scheme)
	result.P = ret.Pointer()
	return
}

// ignore GType struct DesktopAppInfoLookupIface
type DesktopAppLaunchCallbackStruct struct {
	F_appinfo DesktopAppInfo
	F_pid     int32
}

//export myDesktopAppLaunchCallback
func myDesktopAppLaunchCallback(appinfo *C.GDesktopAppInfo, pid C.gint32, user_data C.gpointer) {
	fn := gi.GetFunc(uint(uintptr(user_data)))
	args := DesktopAppLaunchCallbackStruct{
		F_appinfo: WrapDesktopAppInfo(unsafe.Pointer(appinfo)),
		F_pid:     int32(pid),
	}
	fn(args)
}

// Interface Drive
type Drive struct {
	DriveIfc
	P unsafe.Pointer
}
type DriveIfc struct{}
type IDrive interface{ P_Drive() unsafe.Pointer }

func (v Drive) P_Drive() unsafe.Pointer { return v.P }
func DriveGetType() gi.GType {
	ret := _I.GetGType(94, "Drive")
	return ret
}

// g_drive_can_eject
// container is not nil, container is Drive
// is method
func (v *DriveIfc) CanEject() (result bool) {
	iv, err := _I.Get(453, "Drive", "can_eject")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_drive_can_poll_for_media
// container is not nil, container is Drive
// is method
func (v *DriveIfc) CanPollForMedia() (result bool) {
	iv, err := _I.Get(454, "Drive", "can_poll_for_media")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_drive_can_start
// container is not nil, container is Drive
// is method
func (v *DriveIfc) CanStart() (result bool) {
	iv, err := _I.Get(455, "Drive", "can_start")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_drive_can_start_degraded
// container is not nil, container is Drive
// is method
func (v *DriveIfc) CanStartDegraded() (result bool) {
	iv, err := _I.Get(456, "Drive", "can_start_degraded")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_drive_can_stop
// container is not nil, container is Drive
// is method
func (v *DriveIfc) CanStop() (result bool) {
	iv, err := _I.Get(457, "Drive", "can_stop")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_drive_eject
// container is not nil, container is Drive
// is method
func (v *DriveIfc) Eject(flags MountUnmountFlags, cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(458, "Drive", "eject")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_flags := gi.NewIntArgument(int(flags))
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_v, arg_flags, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
}

// g_drive_eject_finish
// container is not nil, container is Drive
// is method
func (v *DriveIfc) EjectFinish(result IAsyncResult) (result1 bool, err error) {
	iv, err := _I.Get(459, "Drive", "eject_finish")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if result != nil {
		tmp = result.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_result := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_result, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result1 = ret.Bool()
	return
}

// g_drive_eject_with_operation
// container is not nil, container is Drive
// is method
func (v *DriveIfc) EjectWithOperation(flags MountUnmountFlags, mount_operation IMountOperation, cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(460, "Drive", "eject_with_operation")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if mount_operation != nil {
		tmp = mount_operation.P_MountOperation()
	}
	var tmp1 unsafe.Pointer
	if cancellable != nil {
		tmp1 = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_flags := gi.NewIntArgument(int(flags))
	arg_mount_operation := gi.NewPointerArgument(tmp)
	arg_cancellable := gi.NewPointerArgument(tmp1)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_v, arg_flags, arg_mount_operation, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
}

// g_drive_eject_with_operation_finish
// container is not nil, container is Drive
// is method
func (v *DriveIfc) EjectWithOperationFinish(result IAsyncResult) (result1 bool, err error) {
	iv, err := _I.Get(461, "Drive", "eject_with_operation_finish")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if result != nil {
		tmp = result.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_result := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_result, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result1 = ret.Bool()
	return
}

// g_drive_enumerate_identifiers
// container is not nil, container is Drive
// is method
func (v *DriveIfc) EnumerateIdentifiers() (result gi.CStrArray) {
	iv, err := _I.Get(462, "Drive", "enumerate_identifiers")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = gi.CStrArray{P: ret.Pointer(), Len: -1}
	result.SetLenZT()
	return
}

// g_drive_get_icon
// container is not nil, container is Drive
// is method
func (v *DriveIfc) GetIcon() (result Icon) {
	iv, err := _I.Get(463, "Drive", "get_icon")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_drive_get_identifier
// container is not nil, container is Drive
// is method
func (v *DriveIfc) GetIdentifier(kind string) (result string) {
	iv, err := _I.Get(464, "Drive", "get_identifier")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_kind := gi.CString(kind)
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_kind := gi.NewStringArgument(c_kind)
	args := []gi.Argument{arg_v, arg_kind}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_kind)
	result = ret.String().Take()
	return
}

// g_drive_get_name
// container is not nil, container is Drive
// is method
func (v *DriveIfc) GetName() (result string) {
	iv, err := _I.Get(465, "Drive", "get_name")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Take()
	return
}

// g_drive_get_sort_key
// container is not nil, container is Drive
// is method
func (v *DriveIfc) GetSortKey() (result string) {
	iv, err := _I.Get(466, "Drive", "get_sort_key")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Take()
	return
}

// g_drive_get_start_stop_type
// container is not nil, container is Drive
// is method
func (v *DriveIfc) GetStartStopType() (result DriveStartStopTypeEnum) {
	iv, err := _I.Get(467, "Drive", "get_start_stop_type")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = DriveStartStopTypeEnum(ret.Int())
	return
}

// g_drive_get_symbolic_icon
// container is not nil, container is Drive
// is method
func (v *DriveIfc) GetSymbolicIcon() (result Icon) {
	iv, err := _I.Get(468, "Drive", "get_symbolic_icon")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_drive_get_volumes
// container is not nil, container is Drive
// is method
func (v *DriveIfc) GetVolumes() (result glib.List) {
	iv, err := _I.Get(469, "Drive", "get_volumes")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_drive_has_media
// container is not nil, container is Drive
// is method
func (v *DriveIfc) HasMedia() (result bool) {
	iv, err := _I.Get(470, "Drive", "has_media")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_drive_has_volumes
// container is not nil, container is Drive
// is method
func (v *DriveIfc) HasVolumes() (result bool) {
	iv, err := _I.Get(471, "Drive", "has_volumes")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_drive_is_media_check_automatic
// container is not nil, container is Drive
// is method
func (v *DriveIfc) IsMediaCheckAutomatic() (result bool) {
	iv, err := _I.Get(472, "Drive", "is_media_check_automatic")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_drive_is_media_removable
// container is not nil, container is Drive
// is method
func (v *DriveIfc) IsMediaRemovable() (result bool) {
	iv, err := _I.Get(473, "Drive", "is_media_removable")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_drive_is_removable
// container is not nil, container is Drive
// is method
func (v *DriveIfc) IsRemovable() (result bool) {
	iv, err := _I.Get(474, "Drive", "is_removable")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_drive_poll_for_media
// container is not nil, container is Drive
// is method
func (v *DriveIfc) PollForMedia(cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(475, "Drive", "poll_for_media")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_v, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
}

// g_drive_poll_for_media_finish
// container is not nil, container is Drive
// is method
func (v *DriveIfc) PollForMediaFinish(result IAsyncResult) (result1 bool, err error) {
	iv, err := _I.Get(476, "Drive", "poll_for_media_finish")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if result != nil {
		tmp = result.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_result := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_result, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result1 = ret.Bool()
	return
}

// g_drive_start
// container is not nil, container is Drive
// is method
func (v *DriveIfc) Start(flags DriveStartFlags, mount_operation IMountOperation, cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(477, "Drive", "start")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if mount_operation != nil {
		tmp = mount_operation.P_MountOperation()
	}
	var tmp1 unsafe.Pointer
	if cancellable != nil {
		tmp1 = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_flags := gi.NewIntArgument(int(flags))
	arg_mount_operation := gi.NewPointerArgument(tmp)
	arg_cancellable := gi.NewPointerArgument(tmp1)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_v, arg_flags, arg_mount_operation, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
}

// g_drive_start_finish
// container is not nil, container is Drive
// is method
func (v *DriveIfc) StartFinish(result IAsyncResult) (result1 bool, err error) {
	iv, err := _I.Get(478, "Drive", "start_finish")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if result != nil {
		tmp = result.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_result := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_result, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result1 = ret.Bool()
	return
}

// g_drive_stop
// container is not nil, container is Drive
// is method
func (v *DriveIfc) Stop(flags MountUnmountFlags, mount_operation IMountOperation, cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(479, "Drive", "stop")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if mount_operation != nil {
		tmp = mount_operation.P_MountOperation()
	}
	var tmp1 unsafe.Pointer
	if cancellable != nil {
		tmp1 = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_flags := gi.NewIntArgument(int(flags))
	arg_mount_operation := gi.NewPointerArgument(tmp)
	arg_cancellable := gi.NewPointerArgument(tmp1)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_v, arg_flags, arg_mount_operation, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
}

// g_drive_stop_finish
// container is not nil, container is Drive
// is method
func (v *DriveIfc) StopFinish(result IAsyncResult) (result1 bool, err error) {
	iv, err := _I.Get(480, "Drive", "stop_finish")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if result != nil {
		tmp = result.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_result := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_result, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result1 = ret.Bool()
	return
}

// ignore GType struct DriveIface
// Flags DriveStartFlags
type DriveStartFlags int

const (
	DriveStartFlagsNone DriveStartFlags = 0
)

func DriveStartFlagsGetType() gi.GType {
	ret := _I.GetGType(95, "DriveStartFlags")
	return ret
}

// Enum DriveStartStopType
type DriveStartStopTypeEnum int

const (
	DriveStartStopTypeUnknown   DriveStartStopTypeEnum = 0
	DriveStartStopTypeShutdown  DriveStartStopTypeEnum = 1
	DriveStartStopTypeNetwork   DriveStartStopTypeEnum = 2
	DriveStartStopTypeMultidisk DriveStartStopTypeEnum = 3
	DriveStartStopTypePassword  DriveStartStopTypeEnum = 4
)

func DriveStartStopTypeGetType() gi.GType {
	ret := _I.GetGType(96, "DriveStartStopType")
	return ret
}

// Interface DtlsClientConnection
type DtlsClientConnection struct {
	DtlsClientConnectionIfc
	P unsafe.Pointer
}
type DtlsClientConnectionIfc struct{}
type IDtlsClientConnection interface{ P_DtlsClientConnection() unsafe.Pointer }

func (v DtlsClientConnection) P_DtlsClientConnection() unsafe.Pointer { return v.P }
func DtlsClientConnectionGetType() gi.GType {
	ret := _I.GetGType(97, "DtlsClientConnection")
	return ret
}

// g_dtls_client_connection_new
// container is not nil, container is DtlsClientConnection
// is method
// arg0Type tag: interface, isPtr: true
func DtlsClientConnectionNew1(base_socket IDatagramBased, server_identity ISocketConnectable) (result DtlsClientConnection, err error) {
	iv, err := _I.Get(481, "DtlsClientConnection", "new")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if base_socket != nil {
		tmp = base_socket.P_DatagramBased()
	}
	var tmp1 unsafe.Pointer
	if server_identity != nil {
		tmp1 = server_identity.P_SocketConnectable()
	}
	arg_base_socket := gi.NewPointerArgument(tmp)
	arg_server_identity := gi.NewPointerArgument(tmp1)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_base_socket, arg_server_identity, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// g_dtls_client_connection_get_accepted_cas
// container is not nil, container is DtlsClientConnection
// is method
func (v *DtlsClientConnectionIfc) GetAcceptedCas() (result glib.List) {
	iv, err := _I.Get(482, "DtlsClientConnection", "get_accepted_cas")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_dtls_client_connection_get_server_identity
// container is not nil, container is DtlsClientConnection
// is method
func (v *DtlsClientConnectionIfc) GetServerIdentity() (result SocketConnectable) {
	iv, err := _I.Get(483, "DtlsClientConnection", "get_server_identity")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_dtls_client_connection_get_validation_flags
// container is not nil, container is DtlsClientConnection
// is method
func (v *DtlsClientConnectionIfc) GetValidationFlags() (result TlsCertificateFlags) {
	iv, err := _I.Get(484, "DtlsClientConnection", "get_validation_flags")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = TlsCertificateFlags(ret.Int())
	return
}

// g_dtls_client_connection_set_server_identity
// container is not nil, container is DtlsClientConnection
// is method
func (v *DtlsClientConnectionIfc) SetServerIdentity(identity ISocketConnectable) {
	iv, err := _I.Get(485, "DtlsClientConnection", "set_server_identity")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if identity != nil {
		tmp = identity.P_SocketConnectable()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_identity := gi.NewPointerArgument(tmp)
	args := []gi.Argument{arg_v, arg_identity}
	iv.Call(args, nil, nil)
}

// g_dtls_client_connection_set_validation_flags
// container is not nil, container is DtlsClientConnection
// is method
func (v *DtlsClientConnectionIfc) SetValidationFlags(flags TlsCertificateFlags) {
	iv, err := _I.Get(486, "DtlsClientConnection", "set_validation_flags")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_flags := gi.NewIntArgument(int(flags))
	args := []gi.Argument{arg_v, arg_flags}
	iv.Call(args, nil, nil)
}

// ignore GType struct DtlsClientConnectionInterface
// Interface DtlsConnection
type DtlsConnection struct {
	DtlsConnectionIfc
	P unsafe.Pointer
}
type DtlsConnectionIfc struct{}
type IDtlsConnection interface{ P_DtlsConnection() unsafe.Pointer }

func (v DtlsConnection) P_DtlsConnection() unsafe.Pointer { return v.P }
func DtlsConnectionGetType() gi.GType {
	ret := _I.GetGType(98, "DtlsConnection")
	return ret
}

// g_dtls_connection_close
// container is not nil, container is DtlsConnection
// is method
func (v *DtlsConnectionIfc) Close(cancellable ICancellable) (result bool, err error) {
	iv, err := _I.Get(487, "DtlsConnection", "close")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Bool()
	return
}

// g_dtls_connection_close_async
// container is not nil, container is DtlsConnection
// is method
func (v *DtlsConnectionIfc) CloseAsync(io_priority int32, cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(488, "DtlsConnection", "close_async")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_io_priority := gi.NewInt32Argument(io_priority)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_v, arg_io_priority, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
}

// g_dtls_connection_close_finish
// container is not nil, container is DtlsConnection
// is method
func (v *DtlsConnectionIfc) CloseFinish(result IAsyncResult) (result1 bool, err error) {
	iv, err := _I.Get(489, "DtlsConnection", "close_finish")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if result != nil {
		tmp = result.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_result := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_result, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result1 = ret.Bool()
	return
}

// g_dtls_connection_emit_accept_certificate
// container is not nil, container is DtlsConnection
// is method
func (v *DtlsConnectionIfc) EmitAcceptCertificate(peer_cert ITlsCertificate, errors TlsCertificateFlags) (result bool) {
	iv, err := _I.Get(490, "DtlsConnection", "emit_accept_certificate")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if peer_cert != nil {
		tmp = peer_cert.P_TlsCertificate()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_peer_cert := gi.NewPointerArgument(tmp)
	arg_errors := gi.NewIntArgument(int(errors))
	args := []gi.Argument{arg_v, arg_peer_cert, arg_errors}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_dtls_connection_get_certificate
// container is not nil, container is DtlsConnection
// is method
func (v *DtlsConnectionIfc) GetCertificate() (result TlsCertificate) {
	iv, err := _I.Get(491, "DtlsConnection", "get_certificate")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_dtls_connection_get_database
// container is not nil, container is DtlsConnection
// is method
func (v *DtlsConnectionIfc) GetDatabase() (result TlsDatabase) {
	iv, err := _I.Get(492, "DtlsConnection", "get_database")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_dtls_connection_get_interaction
// container is not nil, container is DtlsConnection
// is method
func (v *DtlsConnectionIfc) GetInteraction() (result TlsInteraction) {
	iv, err := _I.Get(493, "DtlsConnection", "get_interaction")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_dtls_connection_get_peer_certificate
// container is not nil, container is DtlsConnection
// is method
func (v *DtlsConnectionIfc) GetPeerCertificate() (result TlsCertificate) {
	iv, err := _I.Get(494, "DtlsConnection", "get_peer_certificate")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_dtls_connection_get_peer_certificate_errors
// container is not nil, container is DtlsConnection
// is method
func (v *DtlsConnectionIfc) GetPeerCertificateErrors() (result TlsCertificateFlags) {
	iv, err := _I.Get(495, "DtlsConnection", "get_peer_certificate_errors")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = TlsCertificateFlags(ret.Int())
	return
}

// g_dtls_connection_get_rehandshake_mode
// container is not nil, container is DtlsConnection
// is method
func (v *DtlsConnectionIfc) GetRehandshakeMode() (result TlsRehandshakeModeEnum) {
	iv, err := _I.Get(496, "DtlsConnection", "get_rehandshake_mode")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = TlsRehandshakeModeEnum(ret.Int())
	return
}

// g_dtls_connection_get_require_close_notify
// container is not nil, container is DtlsConnection
// is method
func (v *DtlsConnectionIfc) GetRequireCloseNotify() (result bool) {
	iv, err := _I.Get(497, "DtlsConnection", "get_require_close_notify")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_dtls_connection_handshake
// container is not nil, container is DtlsConnection
// is method
func (v *DtlsConnectionIfc) Handshake(cancellable ICancellable) (result bool, err error) {
	iv, err := _I.Get(498, "DtlsConnection", "handshake")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Bool()
	return
}

// g_dtls_connection_handshake_async
// container is not nil, container is DtlsConnection
// is method
func (v *DtlsConnectionIfc) HandshakeAsync(io_priority int32, cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(499, "DtlsConnection", "handshake_async")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_io_priority := gi.NewInt32Argument(io_priority)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_v, arg_io_priority, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
}

// g_dtls_connection_handshake_finish
// container is not nil, container is DtlsConnection
// is method
func (v *DtlsConnectionIfc) HandshakeFinish(result IAsyncResult) (result1 bool, err error) {
	iv, err := _I.Get(500, "DtlsConnection", "handshake_finish")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if result != nil {
		tmp = result.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_result := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_result, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result1 = ret.Bool()
	return
}

// g_dtls_connection_set_certificate
// container is not nil, container is DtlsConnection
// is method
func (v *DtlsConnectionIfc) SetCertificate(certificate ITlsCertificate) {
	iv, err := _I.Get(501, "DtlsConnection", "set_certificate")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if certificate != nil {
		tmp = certificate.P_TlsCertificate()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_certificate := gi.NewPointerArgument(tmp)
	args := []gi.Argument{arg_v, arg_certificate}
	iv.Call(args, nil, nil)
}

// g_dtls_connection_set_database
// container is not nil, container is DtlsConnection
// is method
func (v *DtlsConnectionIfc) SetDatabase(database ITlsDatabase) {
	iv, err := _I.Get(502, "DtlsConnection", "set_database")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if database != nil {
		tmp = database.P_TlsDatabase()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_database := gi.NewPointerArgument(tmp)
	args := []gi.Argument{arg_v, arg_database}
	iv.Call(args, nil, nil)
}

// g_dtls_connection_set_interaction
// container is not nil, container is DtlsConnection
// is method
func (v *DtlsConnectionIfc) SetInteraction(interaction ITlsInteraction) {
	iv, err := _I.Get(503, "DtlsConnection", "set_interaction")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if interaction != nil {
		tmp = interaction.P_TlsInteraction()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_interaction := gi.NewPointerArgument(tmp)
	args := []gi.Argument{arg_v, arg_interaction}
	iv.Call(args, nil, nil)
}

// g_dtls_connection_set_rehandshake_mode
// container is not nil, container is DtlsConnection
// is method
func (v *DtlsConnectionIfc) SetRehandshakeMode(mode TlsRehandshakeModeEnum) {
	iv, err := _I.Get(504, "DtlsConnection", "set_rehandshake_mode")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_mode := gi.NewIntArgument(int(mode))
	args := []gi.Argument{arg_v, arg_mode}
	iv.Call(args, nil, nil)
}

// g_dtls_connection_set_require_close_notify
// container is not nil, container is DtlsConnection
// is method
func (v *DtlsConnectionIfc) SetRequireCloseNotify(require_close_notify bool) {
	iv, err := _I.Get(505, "DtlsConnection", "set_require_close_notify")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_require_close_notify := gi.NewBoolArgument(require_close_notify)
	args := []gi.Argument{arg_v, arg_require_close_notify}
	iv.Call(args, nil, nil)
}

// g_dtls_connection_shutdown
// container is not nil, container is DtlsConnection
// is method
func (v *DtlsConnectionIfc) Shutdown(shutdown_read bool, shutdown_write bool, cancellable ICancellable) (result bool, err error) {
	iv, err := _I.Get(506, "DtlsConnection", "shutdown")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_shutdown_read := gi.NewBoolArgument(shutdown_read)
	arg_shutdown_write := gi.NewBoolArgument(shutdown_write)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_shutdown_read, arg_shutdown_write, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Bool()
	return
}

// g_dtls_connection_shutdown_async
// container is not nil, container is DtlsConnection
// is method
func (v *DtlsConnectionIfc) ShutdownAsync(shutdown_read bool, shutdown_write bool, io_priority int32, cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(507, "DtlsConnection", "shutdown_async")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_shutdown_read := gi.NewBoolArgument(shutdown_read)
	arg_shutdown_write := gi.NewBoolArgument(shutdown_write)
	arg_io_priority := gi.NewInt32Argument(io_priority)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_v, arg_shutdown_read, arg_shutdown_write, arg_io_priority, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
}

// g_dtls_connection_shutdown_finish
// container is not nil, container is DtlsConnection
// is method
func (v *DtlsConnectionIfc) ShutdownFinish(result IAsyncResult) (result1 bool, err error) {
	iv, err := _I.Get(508, "DtlsConnection", "shutdown_finish")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if result != nil {
		tmp = result.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_result := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_result, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result1 = ret.Bool()
	return
}

// ignore GType struct DtlsConnectionInterface
// Interface DtlsServerConnection
type DtlsServerConnection struct {
	DtlsServerConnectionIfc
	P unsafe.Pointer
}
type DtlsServerConnectionIfc struct{}
type IDtlsServerConnection interface{ P_DtlsServerConnection() unsafe.Pointer }

func (v DtlsServerConnection) P_DtlsServerConnection() unsafe.Pointer { return v.P }
func DtlsServerConnectionGetType() gi.GType {
	ret := _I.GetGType(99, "DtlsServerConnection")
	return ret
}

// g_dtls_server_connection_new
// container is not nil, container is DtlsServerConnection
// is method
// arg0Type tag: interface, isPtr: true
func DtlsServerConnectionNew1(base_socket IDatagramBased, certificate ITlsCertificate) (result DtlsServerConnection, err error) {
	iv, err := _I.Get(509, "DtlsServerConnection", "new")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if base_socket != nil {
		tmp = base_socket.P_DatagramBased()
	}
	var tmp1 unsafe.Pointer
	if certificate != nil {
		tmp1 = certificate.P_TlsCertificate()
	}
	arg_base_socket := gi.NewPointerArgument(tmp)
	arg_certificate := gi.NewPointerArgument(tmp1)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_base_socket, arg_certificate, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// ignore GType struct DtlsServerConnectionInterface
// Object Emblem
type Emblem struct {
	IconIfc
	gobject.Object
}

func WrapEmblem(p unsafe.Pointer) (r Emblem) { r.P = p; return }

type IEmblem interface{ P_Emblem() unsafe.Pointer }

func (v Emblem) P_Emblem() unsafe.Pointer { return v.P }
func (v Emblem) P_Icon() unsafe.Pointer   { return v.P }
func EmblemGetType() gi.GType {
	ret := _I.GetGType(100, "Emblem")
	return ret
}

// g_emblem_new
// container is not nil, container is Emblem
// is constructor
func NewEmblem(icon IIcon) (result Emblem) {
	iv, err := _I.Get(510, "Emblem", "new")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if icon != nil {
		tmp = icon.P_Icon()
	}
	arg_icon := gi.NewPointerArgument(tmp)
	args := []gi.Argument{arg_icon}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_emblem_new_with_origin
// container is not nil, container is Emblem
// is constructor
func NewEmblemWithOrigin(icon IIcon, origin EmblemOriginEnum) (result Emblem) {
	iv, err := _I.Get(511, "Emblem", "new_with_origin")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if icon != nil {
		tmp = icon.P_Icon()
	}
	arg_icon := gi.NewPointerArgument(tmp)
	arg_origin := gi.NewIntArgument(int(origin))
	args := []gi.Argument{arg_icon, arg_origin}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_emblem_get_icon
// container is not nil, container is Emblem
// is method
func (v Emblem) GetIcon() (result Icon) {
	iv, err := _I.Get(512, "Emblem", "get_icon")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_emblem_get_origin
// container is not nil, container is Emblem
// is method
func (v Emblem) GetOrigin() (result EmblemOriginEnum) {
	iv, err := _I.Get(513, "Emblem", "get_origin")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = EmblemOriginEnum(ret.Int())
	return
}

// ignore GType struct EmblemClass
// Enum EmblemOrigin
type EmblemOriginEnum int

const (
	EmblemOriginUnknown      EmblemOriginEnum = 0
	EmblemOriginDevice       EmblemOriginEnum = 1
	EmblemOriginLivemetadata EmblemOriginEnum = 2
	EmblemOriginTag          EmblemOriginEnum = 3
)

func EmblemOriginGetType() gi.GType {
	ret := _I.GetGType(101, "EmblemOrigin")
	return ret
}

// Object EmblemedIcon
type EmblemedIcon struct {
	IconIfc
	gobject.Object
}

func WrapEmblemedIcon(p unsafe.Pointer) (r EmblemedIcon) { r.P = p; return }

type IEmblemedIcon interface{ P_EmblemedIcon() unsafe.Pointer }

func (v EmblemedIcon) P_EmblemedIcon() unsafe.Pointer { return v.P }
func (v EmblemedIcon) P_Icon() unsafe.Pointer         { return v.P }
func EmblemedIconGetType() gi.GType {
	ret := _I.GetGType(102, "EmblemedIcon")
	return ret
}

// g_emblemed_icon_new
// container is not nil, container is EmblemedIcon
// is constructor
func NewEmblemedIcon(icon IIcon, emblem IEmblem) (result EmblemedIcon) {
	iv, err := _I.Get(514, "EmblemedIcon", "new")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if icon != nil {
		tmp = icon.P_Icon()
	}
	var tmp1 unsafe.Pointer
	if emblem != nil {
		tmp1 = emblem.P_Emblem()
	}
	arg_icon := gi.NewPointerArgument(tmp)
	arg_emblem := gi.NewPointerArgument(tmp1)
	args := []gi.Argument{arg_icon, arg_emblem}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_emblemed_icon_add_emblem
// container is not nil, container is EmblemedIcon
// is method
func (v EmblemedIcon) AddEmblem(emblem IEmblem) {
	iv, err := _I.Get(515, "EmblemedIcon", "add_emblem")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if emblem != nil {
		tmp = emblem.P_Emblem()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_emblem := gi.NewPointerArgument(tmp)
	args := []gi.Argument{arg_v, arg_emblem}
	iv.Call(args, nil, nil)
}

// g_emblemed_icon_clear_emblems
// container is not nil, container is EmblemedIcon
// is method
func (v EmblemedIcon) ClearEmblems() {
	iv, err := _I.Get(516, "EmblemedIcon", "clear_emblems")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	iv.Call(args, nil, nil)
}

// g_emblemed_icon_get_emblems
// container is not nil, container is EmblemedIcon
// is method
func (v EmblemedIcon) GetEmblems() (result glib.List) {
	iv, err := _I.Get(517, "EmblemedIcon", "get_emblems")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_emblemed_icon_get_icon
// container is not nil, container is EmblemedIcon
// is method
func (v EmblemedIcon) GetIcon() (result Icon) {
	iv, err := _I.Get(518, "EmblemedIcon", "get_icon")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// ignore GType struct EmblemedIconClass
// Struct EmblemedIconPrivate
type EmblemedIconPrivate struct {
	P unsafe.Pointer
}

func EmblemedIconPrivateGetType() gi.GType {
	ret := _I.GetGType(103, "EmblemedIconPrivate")
	return ret
}

// Interface File
type File struct {
	FileIfc
	P unsafe.Pointer
}
type FileIfc struct{}
type IFile interface{ P_File() unsafe.Pointer }

func (v File) P_File() unsafe.Pointer { return v.P }
func FileGetType() gi.GType {
	ret := _I.GetGType(104, "File")
	return ret
}

// g_file_new_for_commandline_arg
// container is not nil, container is File
// is method
// arg0Type tag: filename, isPtr: true
func FileNewForCommandlineArg1(arg string) (result File) {
	iv, err := _I.Get(519, "File", "new_for_commandline_arg")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_arg := gi.CString(arg)
	arg_arg := gi.NewStringArgument(c_arg)
	args := []gi.Argument{arg_arg}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_arg)
	result.P = ret.Pointer()
	return
}

// g_file_new_for_commandline_arg_and_cwd
// container is not nil, container is File
// is method
// arg0Type tag: filename, isPtr: true
func FileNewForCommandlineArgAndCwd1(arg string, cwd string) (result File) {
	iv, err := _I.Get(520, "File", "new_for_commandline_arg_and_cwd")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_arg := gi.CString(arg)
	c_cwd := gi.CString(cwd)
	arg_arg := gi.NewStringArgument(c_arg)
	arg_cwd := gi.NewStringArgument(c_cwd)
	args := []gi.Argument{arg_arg, arg_cwd}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_arg)
	gi.Free(c_cwd)
	result.P = ret.Pointer()
	return
}

// g_file_new_for_path
// container is not nil, container is File
// is method
// arg0Type tag: filename, isPtr: true
func FileNewForPath1(path string) (result File) {
	iv, err := _I.Get(521, "File", "new_for_path")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_path := gi.CString(path)
	arg_path := gi.NewStringArgument(c_path)
	args := []gi.Argument{arg_path}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_path)
	result.P = ret.Pointer()
	return
}

// g_file_new_for_uri
// container is not nil, container is File
// is method
// arg0Type tag: utf8, isPtr: true
func FileNewForUri1(uri string) (result File) {
	iv, err := _I.Get(522, "File", "new_for_uri")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_uri := gi.CString(uri)
	arg_uri := gi.NewStringArgument(c_uri)
	args := []gi.Argument{arg_uri}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_uri)
	result.P = ret.Pointer()
	return
}

// g_file_new_tmp
// container is not nil, container is File
// is method
// arg0Type tag: filename, isPtr: true
func FileNewTmp1(tmpl string) (result File, iostream FileIOStream, err error) {
	iv, err := _I.Get(523, "File", "new_tmp")
	if err != nil {
		return
	}
	var outArgs [2]gi.Argument
	c_tmpl := gi.CString(tmpl)
	arg_tmpl := gi.NewStringArgument(c_tmpl)
	arg_iostream := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[1]))
	args := []gi.Argument{arg_tmpl, arg_iostream, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	gi.Free(c_tmpl)
	err = gi.ToError(outArgs[1].Pointer())
	iostream.P = outArgs[0].Pointer()
	result.P = ret.Pointer()
	return
}

// g_file_parse_name
// container is not nil, container is File
// is method
// arg0Type tag: utf8, isPtr: true
func FileParseName1(parse_name string) (result File) {
	iv, err := _I.Get(524, "File", "parse_name")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_parse_name := gi.CString(parse_name)
	arg_parse_name := gi.NewStringArgument(c_parse_name)
	args := []gi.Argument{arg_parse_name}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_parse_name)
	result.P = ret.Pointer()
	return
}

// g_file_append_to
// container is not nil, container is File
// is method
func (v *FileIfc) AppendTo(flags FileCreateFlags, cancellable ICancellable) (result FileOutputStream, err error) {
	iv, err := _I.Get(525, "File", "append_to")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_flags := gi.NewIntArgument(int(flags))
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_flags, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// g_file_append_to_async
// container is not nil, container is File
// is method
func (v *FileIfc) AppendToAsync(flags FileCreateFlags, io_priority int32, cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(526, "File", "append_to_async")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_flags := gi.NewIntArgument(int(flags))
	arg_io_priority := gi.NewInt32Argument(io_priority)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_v, arg_flags, arg_io_priority, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
}

// g_file_append_to_finish
// container is not nil, container is File
// is method
func (v *FileIfc) AppendToFinish(res IAsyncResult) (result FileOutputStream, err error) {
	iv, err := _I.Get(527, "File", "append_to_finish")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if res != nil {
		tmp = res.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_res := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_res, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// g_file_copy
// container is not nil, container is File
// is method
func (v *FileIfc) Copy(destination IFile, flags FileCopyFlags, cancellable ICancellable, progress_callback int /*TODO_TYPE isPtr: false, tag: interface*/, progress_callback_data unsafe.Pointer) (result bool, err error) {
	iv, err := _I.Get(528, "File", "copy")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if destination != nil {
		tmp = destination.P_File()
	}
	var tmp1 unsafe.Pointer
	if cancellable != nil {
		tmp1 = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_destination := gi.NewPointerArgument(tmp)
	arg_flags := gi.NewIntArgument(int(flags))
	arg_cancellable := gi.NewPointerArgument(tmp1)
	arg_progress_callback := gi.NewIntArgument(progress_callback) /*TODO*/
	arg_progress_callback_data := gi.NewPointerArgument(progress_callback_data)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_destination, arg_flags, arg_cancellable, arg_progress_callback, arg_progress_callback_data, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Bool()
	return
}

// g_file_copy_async
// container is not nil, container is File
// is method
func (v *FileIfc) CopyAsync(destination IFile, flags FileCopyFlags, io_priority int32, cancellable ICancellable, progress_callback int /*TODO_TYPE isPtr: false, tag: interface*/, progress_callback_data unsafe.Pointer, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(529, "File", "copy_async")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if destination != nil {
		tmp = destination.P_File()
	}
	var tmp1 unsafe.Pointer
	if cancellable != nil {
		tmp1 = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_destination := gi.NewPointerArgument(tmp)
	arg_flags := gi.NewIntArgument(int(flags))
	arg_io_priority := gi.NewInt32Argument(io_priority)
	arg_cancellable := gi.NewPointerArgument(tmp1)
	arg_progress_callback := gi.NewIntArgument(progress_callback) /*TODO*/
	arg_progress_callback_data := gi.NewPointerArgument(progress_callback_data)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_v, arg_destination, arg_flags, arg_io_priority, arg_cancellable, arg_progress_callback, arg_progress_callback_data, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
}

// g_file_copy_attributes
// container is not nil, container is File
// is method
func (v *FileIfc) CopyAttributes(destination IFile, flags FileCopyFlags, cancellable ICancellable) (result bool, err error) {
	iv, err := _I.Get(530, "File", "copy_attributes")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if destination != nil {
		tmp = destination.P_File()
	}
	var tmp1 unsafe.Pointer
	if cancellable != nil {
		tmp1 = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_destination := gi.NewPointerArgument(tmp)
	arg_flags := gi.NewIntArgument(int(flags))
	arg_cancellable := gi.NewPointerArgument(tmp1)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_destination, arg_flags, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Bool()
	return
}

// g_file_copy_finish
// container is not nil, container is File
// is method
func (v *FileIfc) CopyFinish(res IAsyncResult) (result bool, err error) {
	iv, err := _I.Get(531, "File", "copy_finish")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if res != nil {
		tmp = res.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_res := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_res, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Bool()
	return
}

// g_file_create
// container is not nil, container is File
// is method
func (v *FileIfc) Create(flags FileCreateFlags, cancellable ICancellable) (result FileOutputStream, err error) {
	iv, err := _I.Get(532, "File", "create")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_flags := gi.NewIntArgument(int(flags))
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_flags, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// g_file_create_async
// container is not nil, container is File
// is method
func (v *FileIfc) CreateAsync(flags FileCreateFlags, io_priority int32, cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(533, "File", "create_async")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_flags := gi.NewIntArgument(int(flags))
	arg_io_priority := gi.NewInt32Argument(io_priority)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_v, arg_flags, arg_io_priority, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
}

// g_file_create_finish
// container is not nil, container is File
// is method
func (v *FileIfc) CreateFinish(res IAsyncResult) (result FileOutputStream, err error) {
	iv, err := _I.Get(534, "File", "create_finish")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if res != nil {
		tmp = res.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_res := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_res, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// g_file_create_readwrite
// container is not nil, container is File
// is method
func (v *FileIfc) CreateReadwrite(flags FileCreateFlags, cancellable ICancellable) (result FileIOStream, err error) {
	iv, err := _I.Get(535, "File", "create_readwrite")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_flags := gi.NewIntArgument(int(flags))
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_flags, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// g_file_create_readwrite_async
// container is not nil, container is File
// is method
func (v *FileIfc) CreateReadwriteAsync(flags FileCreateFlags, io_priority int32, cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(536, "File", "create_readwrite_async")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_flags := gi.NewIntArgument(int(flags))
	arg_io_priority := gi.NewInt32Argument(io_priority)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_v, arg_flags, arg_io_priority, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
}

// g_file_create_readwrite_finish
// container is not nil, container is File
// is method
func (v *FileIfc) CreateReadwriteFinish(res IAsyncResult) (result FileIOStream, err error) {
	iv, err := _I.Get(537, "File", "create_readwrite_finish")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if res != nil {
		tmp = res.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_res := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_res, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// g_file_delete
// container is not nil, container is File
// is method
func (v *FileIfc) Delete(cancellable ICancellable) (result bool, err error) {
	iv, err := _I.Get(538, "File", "delete")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Bool()
	return
}

// g_file_delete_async
// container is not nil, container is File
// is method
func (v *FileIfc) DeleteAsync(io_priority int32, cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(539, "File", "delete_async")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_io_priority := gi.NewInt32Argument(io_priority)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_v, arg_io_priority, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
}

// g_file_delete_finish
// container is not nil, container is File
// is method
func (v *FileIfc) DeleteFinish(result IAsyncResult) (result1 bool, err error) {
	iv, err := _I.Get(540, "File", "delete_finish")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if result != nil {
		tmp = result.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_result := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_result, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result1 = ret.Bool()
	return
}

// g_file_dup
// container is not nil, container is File
// is method
func (v *FileIfc) Dup() (result File) {
	iv, err := _I.Get(541, "File", "dup")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_file_eject_mountable
// container is not nil, container is File
// is method
func (v *FileIfc) EjectMountable(flags MountUnmountFlags, cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(542, "File", "eject_mountable")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_flags := gi.NewIntArgument(int(flags))
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_v, arg_flags, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
}

// g_file_eject_mountable_finish
// container is not nil, container is File
// is method
func (v *FileIfc) EjectMountableFinish(result IAsyncResult) (result1 bool, err error) {
	iv, err := _I.Get(543, "File", "eject_mountable_finish")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if result != nil {
		tmp = result.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_result := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_result, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result1 = ret.Bool()
	return
}

// g_file_eject_mountable_with_operation
// container is not nil, container is File
// is method
func (v *FileIfc) EjectMountableWithOperation(flags MountUnmountFlags, mount_operation IMountOperation, cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(544, "File", "eject_mountable_with_operation")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if mount_operation != nil {
		tmp = mount_operation.P_MountOperation()
	}
	var tmp1 unsafe.Pointer
	if cancellable != nil {
		tmp1 = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_flags := gi.NewIntArgument(int(flags))
	arg_mount_operation := gi.NewPointerArgument(tmp)
	arg_cancellable := gi.NewPointerArgument(tmp1)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_v, arg_flags, arg_mount_operation, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
}

// g_file_eject_mountable_with_operation_finish
// container is not nil, container is File
// is method
func (v *FileIfc) EjectMountableWithOperationFinish(result IAsyncResult) (result1 bool, err error) {
	iv, err := _I.Get(545, "File", "eject_mountable_with_operation_finish")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if result != nil {
		tmp = result.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_result := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_result, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result1 = ret.Bool()
	return
}

// g_file_enumerate_children
// container is not nil, container is File
// is method
func (v *FileIfc) EnumerateChildren(attributes string, flags FileQueryInfoFlags, cancellable ICancellable) (result FileEnumerator, err error) {
	iv, err := _I.Get(546, "File", "enumerate_children")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	c_attributes := gi.CString(attributes)
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_attributes := gi.NewStringArgument(c_attributes)
	arg_flags := gi.NewIntArgument(int(flags))
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_attributes, arg_flags, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	gi.Free(c_attributes)
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// g_file_enumerate_children_async
// container is not nil, container is File
// is method
func (v *FileIfc) EnumerateChildrenAsync(attributes string, flags FileQueryInfoFlags, io_priority int32, cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(547, "File", "enumerate_children_async")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_attributes := gi.CString(attributes)
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_attributes := gi.NewStringArgument(c_attributes)
	arg_flags := gi.NewIntArgument(int(flags))
	arg_io_priority := gi.NewInt32Argument(io_priority)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_v, arg_attributes, arg_flags, arg_io_priority, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
	gi.Free(c_attributes)
}

// g_file_enumerate_children_finish
// container is not nil, container is File
// is method
func (v *FileIfc) EnumerateChildrenFinish(res IAsyncResult) (result FileEnumerator, err error) {
	iv, err := _I.Get(548, "File", "enumerate_children_finish")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if res != nil {
		tmp = res.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_res := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_res, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// g_file_equal
// container is not nil, container is File
// is method
func (v *FileIfc) Equal(file2 IFile) (result bool) {
	iv, err := _I.Get(549, "File", "equal")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if file2 != nil {
		tmp = file2.P_File()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_file2 := gi.NewPointerArgument(tmp)
	args := []gi.Argument{arg_v, arg_file2}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_file_find_enclosing_mount
// container is not nil, container is File
// is method
func (v *FileIfc) FindEnclosingMount(cancellable ICancellable) (result Mount, err error) {
	iv, err := _I.Get(550, "File", "find_enclosing_mount")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// g_file_find_enclosing_mount_async
// container is not nil, container is File
// is method
func (v *FileIfc) FindEnclosingMountAsync(io_priority int32, cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(551, "File", "find_enclosing_mount_async")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_io_priority := gi.NewInt32Argument(io_priority)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_v, arg_io_priority, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
}

// g_file_find_enclosing_mount_finish
// container is not nil, container is File
// is method
func (v *FileIfc) FindEnclosingMountFinish(res IAsyncResult) (result Mount, err error) {
	iv, err := _I.Get(552, "File", "find_enclosing_mount_finish")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if res != nil {
		tmp = res.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_res := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_res, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// g_file_get_basename
// container is not nil, container is File
// is method
func (v *FileIfc) GetBasename() (result string) {
	iv, err := _I.Get(553, "File", "get_basename")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Take()
	return
}

// g_file_get_child
// container is not nil, container is File
// is method
func (v *FileIfc) GetChild(name string) (result File) {
	iv, err := _I.Get(554, "File", "get_child")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_name := gi.CString(name)
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_name := gi.NewStringArgument(c_name)
	args := []gi.Argument{arg_v, arg_name}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_name)
	result.P = ret.Pointer()
	return
}

// g_file_get_child_for_display_name
// container is not nil, container is File
// is method
func (v *FileIfc) GetChildForDisplayName(display_name string) (result File, err error) {
	iv, err := _I.Get(555, "File", "get_child_for_display_name")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	c_display_name := gi.CString(display_name)
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_display_name := gi.NewStringArgument(c_display_name)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_display_name, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	gi.Free(c_display_name)
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// g_file_get_parent
// container is not nil, container is File
// is method
func (v *FileIfc) GetParent() (result File) {
	iv, err := _I.Get(556, "File", "get_parent")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_file_get_parse_name
// container is not nil, container is File
// is method
func (v *FileIfc) GetParseName() (result string) {
	iv, err := _I.Get(557, "File", "get_parse_name")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Take()
	return
}

// g_file_get_path
// container is not nil, container is File
// is method
func (v *FileIfc) GetPath() (result string) {
	iv, err := _I.Get(558, "File", "get_path")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Take()
	return
}

// g_file_get_relative_path
// container is not nil, container is File
// is method
func (v *FileIfc) GetRelativePath(descendant IFile) (result string) {
	iv, err := _I.Get(559, "File", "get_relative_path")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if descendant != nil {
		tmp = descendant.P_File()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_descendant := gi.NewPointerArgument(tmp)
	args := []gi.Argument{arg_v, arg_descendant}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Take()
	return
}

// g_file_get_uri
// container is not nil, container is File
// is method
func (v *FileIfc) GetUri() (result string) {
	iv, err := _I.Get(560, "File", "get_uri")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Take()
	return
}

// g_file_get_uri_scheme
// container is not nil, container is File
// is method
func (v *FileIfc) GetUriScheme() (result string) {
	iv, err := _I.Get(561, "File", "get_uri_scheme")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Take()
	return
}

// g_file_has_parent
// container is not nil, container is File
// is method
func (v *FileIfc) HasParent(parent IFile) (result bool) {
	iv, err := _I.Get(562, "File", "has_parent")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if parent != nil {
		tmp = parent.P_File()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_parent := gi.NewPointerArgument(tmp)
	args := []gi.Argument{arg_v, arg_parent}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_file_has_prefix
// container is not nil, container is File
// is method
func (v *FileIfc) HasPrefix(prefix IFile) (result bool) {
	iv, err := _I.Get(563, "File", "has_prefix")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if prefix != nil {
		tmp = prefix.P_File()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_prefix := gi.NewPointerArgument(tmp)
	args := []gi.Argument{arg_v, arg_prefix}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_file_has_uri_scheme
// container is not nil, container is File
// is method
func (v *FileIfc) HasUriScheme(uri_scheme string) (result bool) {
	iv, err := _I.Get(564, "File", "has_uri_scheme")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_uri_scheme := gi.CString(uri_scheme)
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_uri_scheme := gi.NewStringArgument(c_uri_scheme)
	args := []gi.Argument{arg_v, arg_uri_scheme}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_uri_scheme)
	result = ret.Bool()
	return
}

// g_file_hash
// container is not nil, container is File
// is method
func (v *FileIfc) Hash() (result uint32) {
	iv, err := _I.Get(565, "File", "hash")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Uint32()
	return
}

// g_file_is_native
// container is not nil, container is File
// is method
func (v *FileIfc) IsNative() (result bool) {
	iv, err := _I.Get(566, "File", "is_native")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_file_load_bytes
// container is not nil, container is File
// is method
func (v *FileIfc) LoadBytes(cancellable ICancellable) (result glib.Bytes, etag_out string, err error) {
	iv, err := _I.Get(567, "File", "load_bytes")
	if err != nil {
		return
	}
	var outArgs [2]gi.Argument
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_etag_out := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[1]))
	args := []gi.Argument{arg_v, arg_cancellable, arg_etag_out, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[1].Pointer())
	etag_out = outArgs[0].String().Take()
	result.P = ret.Pointer()
	return
}

// g_file_load_bytes_async
// container is not nil, container is File
// is method
func (v *FileIfc) LoadBytesAsync(cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(568, "File", "load_bytes_async")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_v, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
}

// g_file_load_bytes_finish
// container is not nil, container is File
// is method
func (v *FileIfc) LoadBytesFinish(result IAsyncResult) (result1 glib.Bytes, etag_out string, err error) {
	iv, err := _I.Get(569, "File", "load_bytes_finish")
	if err != nil {
		return
	}
	var outArgs [2]gi.Argument
	var tmp unsafe.Pointer
	if result != nil {
		tmp = result.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_result := gi.NewPointerArgument(tmp)
	arg_etag_out := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[1]))
	args := []gi.Argument{arg_v, arg_result, arg_etag_out, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[1].Pointer())
	etag_out = outArgs[0].String().Take()
	result1.P = ret.Pointer()
	return
}

// g_file_load_contents
// container is not nil, container is File
// is method
// arg 1 contents lenArgIdx 2
func (v *FileIfc) LoadContents(cancellable ICancellable) (result bool, contents gi.Uint8Array, etag_out string, err error) {
	iv, err := _I.Get(570, "File", "load_contents")
	if err != nil {
		return
	}
	var outArgs [4]gi.Argument
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_contents := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	arg_length := gi.NewPointerArgument(unsafe.Pointer(&outArgs[1]))
	arg_etag_out := gi.NewPointerArgument(unsafe.Pointer(&outArgs[2]))
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[3]))
	args := []gi.Argument{arg_v, arg_cancellable, arg_contents, arg_length, arg_etag_out, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	var length uint64
	_ = length
	err = gi.ToError(outArgs[3].Pointer())
	contents.P = outArgs[0].Pointer()
	length = outArgs[1].Uint64()
	etag_out = outArgs[2].String().Take()
	result = ret.Bool()
	contents.Len = int(length)
	return
}

// g_file_load_contents_async
// container is not nil, container is File
// is method
func (v *FileIfc) LoadContentsAsync(cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(571, "File", "load_contents_async")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_v, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
}

// g_file_load_contents_finish
// container is not nil, container is File
// is method
// arg 1 contents lenArgIdx 2
func (v *FileIfc) LoadContentsFinish(res IAsyncResult) (result bool, contents gi.Uint8Array, etag_out string, err error) {
	iv, err := _I.Get(572, "File", "load_contents_finish")
	if err != nil {
		return
	}
	var outArgs [4]gi.Argument
	var tmp unsafe.Pointer
	if res != nil {
		tmp = res.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_res := gi.NewPointerArgument(tmp)
	arg_contents := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	arg_length := gi.NewPointerArgument(unsafe.Pointer(&outArgs[1]))
	arg_etag_out := gi.NewPointerArgument(unsafe.Pointer(&outArgs[2]))
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[3]))
	args := []gi.Argument{arg_v, arg_res, arg_contents, arg_length, arg_etag_out, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	var length uint64
	_ = length
	err = gi.ToError(outArgs[3].Pointer())
	contents.P = outArgs[0].Pointer()
	length = outArgs[1].Uint64()
	etag_out = outArgs[2].String().Take()
	result = ret.Bool()
	contents.Len = int(length)
	return
}

// g_file_load_partial_contents_finish
// container is not nil, container is File
// is method
// arg 1 contents lenArgIdx 2
func (v *FileIfc) LoadPartialContentsFinish(res IAsyncResult) (result bool, contents gi.Uint8Array, etag_out string, err error) {
	iv, err := _I.Get(573, "File", "load_partial_contents_finish")
	if err != nil {
		return
	}
	var outArgs [4]gi.Argument
	var tmp unsafe.Pointer
	if res != nil {
		tmp = res.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_res := gi.NewPointerArgument(tmp)
	arg_contents := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	arg_length := gi.NewPointerArgument(unsafe.Pointer(&outArgs[1]))
	arg_etag_out := gi.NewPointerArgument(unsafe.Pointer(&outArgs[2]))
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[3]))
	args := []gi.Argument{arg_v, arg_res, arg_contents, arg_length, arg_etag_out, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	var length uint64
	_ = length
	err = gi.ToError(outArgs[3].Pointer())
	contents.P = outArgs[0].Pointer()
	length = outArgs[1].Uint64()
	etag_out = outArgs[2].String().Take()
	result = ret.Bool()
	contents.Len = int(length)
	return
}

// g_file_make_directory
// container is not nil, container is File
// is method
func (v *FileIfc) MakeDirectory(cancellable ICancellable) (result bool, err error) {
	iv, err := _I.Get(574, "File", "make_directory")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Bool()
	return
}

// g_file_make_directory_async
// container is not nil, container is File
// is method
func (v *FileIfc) MakeDirectoryAsync(io_priority int32, cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(575, "File", "make_directory_async")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_io_priority := gi.NewInt32Argument(io_priority)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_v, arg_io_priority, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
}

// g_file_make_directory_finish
// container is not nil, container is File
// is method
func (v *FileIfc) MakeDirectoryFinish(result IAsyncResult) (result1 bool, err error) {
	iv, err := _I.Get(576, "File", "make_directory_finish")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if result != nil {
		tmp = result.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_result := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_result, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result1 = ret.Bool()
	return
}

// g_file_make_directory_with_parents
// container is not nil, container is File
// is method
func (v *FileIfc) MakeDirectoryWithParents(cancellable ICancellable) (result bool, err error) {
	iv, err := _I.Get(577, "File", "make_directory_with_parents")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Bool()
	return
}

// g_file_make_symbolic_link
// container is not nil, container is File
// is method
func (v *FileIfc) MakeSymbolicLink(symlink_value string, cancellable ICancellable) (result bool, err error) {
	iv, err := _I.Get(578, "File", "make_symbolic_link")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	c_symlink_value := gi.CString(symlink_value)
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_symlink_value := gi.NewStringArgument(c_symlink_value)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_symlink_value, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	gi.Free(c_symlink_value)
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Bool()
	return
}

// g_file_measure_disk_usage_finish
// container is not nil, container is File
// is method
func (v *FileIfc) MeasureDiskUsageFinish(result IAsyncResult) (result1 bool, disk_usage uint64, num_dirs uint64, num_files uint64, err error) {
	iv, err := _I.Get(579, "File", "measure_disk_usage_finish")
	if err != nil {
		return
	}
	var outArgs [4]gi.Argument
	var tmp unsafe.Pointer
	if result != nil {
		tmp = result.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_result := gi.NewPointerArgument(tmp)
	arg_disk_usage := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	arg_num_dirs := gi.NewPointerArgument(unsafe.Pointer(&outArgs[1]))
	arg_num_files := gi.NewPointerArgument(unsafe.Pointer(&outArgs[2]))
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[3]))
	args := []gi.Argument{arg_v, arg_result, arg_disk_usage, arg_num_dirs, arg_num_files, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[3].Pointer())
	disk_usage = outArgs[0].Uint64()
	num_dirs = outArgs[1].Uint64()
	num_files = outArgs[2].Uint64()
	result1 = ret.Bool()
	return
}

// g_file_monitor
// container is not nil, container is File
// is method
func (v *FileIfc) Monitor(flags FileMonitorFlags, cancellable ICancellable) (result FileMonitor, err error) {
	iv, err := _I.Get(580, "File", "monitor")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_flags := gi.NewIntArgument(int(flags))
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_flags, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// g_file_monitor_directory
// container is not nil, container is File
// is method
func (v *FileIfc) MonitorDirectory(flags FileMonitorFlags, cancellable ICancellable) (result FileMonitor, err error) {
	iv, err := _I.Get(581, "File", "monitor_directory")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_flags := gi.NewIntArgument(int(flags))
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_flags, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// g_file_monitor_file
// container is not nil, container is File
// is method
func (v *FileIfc) MonitorFile(flags FileMonitorFlags, cancellable ICancellable) (result FileMonitor, err error) {
	iv, err := _I.Get(582, "File", "monitor_file")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_flags := gi.NewIntArgument(int(flags))
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_flags, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// g_file_mount_enclosing_volume
// container is not nil, container is File
// is method
func (v *FileIfc) MountEnclosingVolume(flags MountMountFlags, mount_operation IMountOperation, cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(583, "File", "mount_enclosing_volume")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if mount_operation != nil {
		tmp = mount_operation.P_MountOperation()
	}
	var tmp1 unsafe.Pointer
	if cancellable != nil {
		tmp1 = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_flags := gi.NewIntArgument(int(flags))
	arg_mount_operation := gi.NewPointerArgument(tmp)
	arg_cancellable := gi.NewPointerArgument(tmp1)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_v, arg_flags, arg_mount_operation, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
}

// g_file_mount_enclosing_volume_finish
// container is not nil, container is File
// is method
func (v *FileIfc) MountEnclosingVolumeFinish(result IAsyncResult) (result1 bool, err error) {
	iv, err := _I.Get(584, "File", "mount_enclosing_volume_finish")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if result != nil {
		tmp = result.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_result := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_result, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result1 = ret.Bool()
	return
}

// g_file_mount_mountable
// container is not nil, container is File
// is method
func (v *FileIfc) MountMountable(flags MountMountFlags, mount_operation IMountOperation, cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(585, "File", "mount_mountable")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if mount_operation != nil {
		tmp = mount_operation.P_MountOperation()
	}
	var tmp1 unsafe.Pointer
	if cancellable != nil {
		tmp1 = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_flags := gi.NewIntArgument(int(flags))
	arg_mount_operation := gi.NewPointerArgument(tmp)
	arg_cancellable := gi.NewPointerArgument(tmp1)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_v, arg_flags, arg_mount_operation, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
}

// g_file_mount_mountable_finish
// container is not nil, container is File
// is method
func (v *FileIfc) MountMountableFinish(result IAsyncResult) (result1 File, err error) {
	iv, err := _I.Get(586, "File", "mount_mountable_finish")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if result != nil {
		tmp = result.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_result := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_result, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result1.P = ret.Pointer()
	return
}

// g_file_move
// container is not nil, container is File
// is method
func (v *FileIfc) Move(destination IFile, flags FileCopyFlags, cancellable ICancellable, progress_callback int /*TODO_TYPE isPtr: false, tag: interface*/, progress_callback_data unsafe.Pointer) (result bool, err error) {
	iv, err := _I.Get(587, "File", "move")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if destination != nil {
		tmp = destination.P_File()
	}
	var tmp1 unsafe.Pointer
	if cancellable != nil {
		tmp1 = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_destination := gi.NewPointerArgument(tmp)
	arg_flags := gi.NewIntArgument(int(flags))
	arg_cancellable := gi.NewPointerArgument(tmp1)
	arg_progress_callback := gi.NewIntArgument(progress_callback) /*TODO*/
	arg_progress_callback_data := gi.NewPointerArgument(progress_callback_data)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_destination, arg_flags, arg_cancellable, arg_progress_callback, arg_progress_callback_data, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Bool()
	return
}

// g_file_open_readwrite
// container is not nil, container is File
// is method
func (v *FileIfc) OpenReadwrite(cancellable ICancellable) (result FileIOStream, err error) {
	iv, err := _I.Get(588, "File", "open_readwrite")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// g_file_open_readwrite_async
// container is not nil, container is File
// is method
func (v *FileIfc) OpenReadwriteAsync(io_priority int32, cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(589, "File", "open_readwrite_async")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_io_priority := gi.NewInt32Argument(io_priority)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_v, arg_io_priority, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
}

// g_file_open_readwrite_finish
// container is not nil, container is File
// is method
func (v *FileIfc) OpenReadwriteFinish(res IAsyncResult) (result FileIOStream, err error) {
	iv, err := _I.Get(590, "File", "open_readwrite_finish")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if res != nil {
		tmp = res.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_res := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_res, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// g_file_peek_path
// container is not nil, container is File
// is method
func (v *FileIfc) PeekPath() (result string) {
	iv, err := _I.Get(591, "File", "peek_path")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Take()
	return
}

// g_file_poll_mountable
// container is not nil, container is File
// is method
func (v *FileIfc) PollMountable(cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(592, "File", "poll_mountable")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_v, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
}

// g_file_poll_mountable_finish
// container is not nil, container is File
// is method
func (v *FileIfc) PollMountableFinish(result IAsyncResult) (result1 bool, err error) {
	iv, err := _I.Get(593, "File", "poll_mountable_finish")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if result != nil {
		tmp = result.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_result := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_result, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result1 = ret.Bool()
	return
}

// g_file_query_default_handler
// container is not nil, container is File
// is method
func (v *FileIfc) QueryDefaultHandler(cancellable ICancellable) (result AppInfo, err error) {
	iv, err := _I.Get(594, "File", "query_default_handler")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// g_file_query_exists
// container is not nil, container is File
// is method
func (v *FileIfc) QueryExists(cancellable ICancellable) (result bool) {
	iv, err := _I.Get(595, "File", "query_exists")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_cancellable := gi.NewPointerArgument(tmp)
	args := []gi.Argument{arg_v, arg_cancellable}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_file_query_file_type
// container is not nil, container is File
// is method
func (v *FileIfc) QueryFileType(flags FileQueryInfoFlags, cancellable ICancellable) (result FileTypeEnum) {
	iv, err := _I.Get(596, "File", "query_file_type")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_flags := gi.NewIntArgument(int(flags))
	arg_cancellable := gi.NewPointerArgument(tmp)
	args := []gi.Argument{arg_v, arg_flags, arg_cancellable}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = FileTypeEnum(ret.Int())
	return
}

// g_file_query_filesystem_info
// container is not nil, container is File
// is method
func (v *FileIfc) QueryFilesystemInfo(attributes string, cancellable ICancellable) (result FileInfo, err error) {
	iv, err := _I.Get(597, "File", "query_filesystem_info")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	c_attributes := gi.CString(attributes)
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_attributes := gi.NewStringArgument(c_attributes)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_attributes, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	gi.Free(c_attributes)
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// g_file_query_filesystem_info_async
// container is not nil, container is File
// is method
func (v *FileIfc) QueryFilesystemInfoAsync(attributes string, io_priority int32, cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(598, "File", "query_filesystem_info_async")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_attributes := gi.CString(attributes)
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_attributes := gi.NewStringArgument(c_attributes)
	arg_io_priority := gi.NewInt32Argument(io_priority)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_v, arg_attributes, arg_io_priority, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
	gi.Free(c_attributes)
}

// g_file_query_filesystem_info_finish
// container is not nil, container is File
// is method
func (v *FileIfc) QueryFilesystemInfoFinish(res IAsyncResult) (result FileInfo, err error) {
	iv, err := _I.Get(599, "File", "query_filesystem_info_finish")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if res != nil {
		tmp = res.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_res := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_res, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// g_file_query_info
// container is not nil, container is File
// is method
func (v *FileIfc) QueryInfo(attributes string, flags FileQueryInfoFlags, cancellable ICancellable) (result FileInfo, err error) {
	iv, err := _I.Get(600, "File", "query_info")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	c_attributes := gi.CString(attributes)
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_attributes := gi.NewStringArgument(c_attributes)
	arg_flags := gi.NewIntArgument(int(flags))
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_attributes, arg_flags, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	gi.Free(c_attributes)
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// g_file_query_info_async
// container is not nil, container is File
// is method
func (v *FileIfc) QueryInfoAsync(attributes string, flags FileQueryInfoFlags, io_priority int32, cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(601, "File", "query_info_async")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_attributes := gi.CString(attributes)
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_attributes := gi.NewStringArgument(c_attributes)
	arg_flags := gi.NewIntArgument(int(flags))
	arg_io_priority := gi.NewInt32Argument(io_priority)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_v, arg_attributes, arg_flags, arg_io_priority, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
	gi.Free(c_attributes)
}

// g_file_query_info_finish
// container is not nil, container is File
// is method
func (v *FileIfc) QueryInfoFinish(res IAsyncResult) (result FileInfo, err error) {
	iv, err := _I.Get(602, "File", "query_info_finish")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if res != nil {
		tmp = res.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_res := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_res, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// g_file_query_settable_attributes
// container is not nil, container is File
// is method
func (v *FileIfc) QuerySettableAttributes(cancellable ICancellable) (result FileAttributeInfoList, err error) {
	iv, err := _I.Get(603, "File", "query_settable_attributes")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// g_file_query_writable_namespaces
// container is not nil, container is File
// is method
func (v *FileIfc) QueryWritableNamespaces(cancellable ICancellable) (result FileAttributeInfoList, err error) {
	iv, err := _I.Get(604, "File", "query_writable_namespaces")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// g_file_read
// container is not nil, container is File
// is method
func (v *FileIfc) Read(cancellable ICancellable) (result FileInputStream, err error) {
	iv, err := _I.Get(605, "File", "read")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// g_file_read_async
// container is not nil, container is File
// is method
func (v *FileIfc) ReadAsync(io_priority int32, cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(606, "File", "read_async")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_io_priority := gi.NewInt32Argument(io_priority)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_v, arg_io_priority, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
}

// g_file_read_finish
// container is not nil, container is File
// is method
func (v *FileIfc) ReadFinish(res IAsyncResult) (result FileInputStream, err error) {
	iv, err := _I.Get(607, "File", "read_finish")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if res != nil {
		tmp = res.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_res := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_res, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// g_file_replace
// container is not nil, container is File
// is method
func (v *FileIfc) Replace(etag string, make_backup bool, flags FileCreateFlags, cancellable ICancellable) (result FileOutputStream, err error) {
	iv, err := _I.Get(608, "File", "replace")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	c_etag := gi.CString(etag)
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_etag := gi.NewStringArgument(c_etag)
	arg_make_backup := gi.NewBoolArgument(make_backup)
	arg_flags := gi.NewIntArgument(int(flags))
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_etag, arg_make_backup, arg_flags, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	gi.Free(c_etag)
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// g_file_replace_async
// container is not nil, container is File
// is method
func (v *FileIfc) ReplaceAsync(etag string, make_backup bool, flags FileCreateFlags, io_priority int32, cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(609, "File", "replace_async")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_etag := gi.CString(etag)
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_etag := gi.NewStringArgument(c_etag)
	arg_make_backup := gi.NewBoolArgument(make_backup)
	arg_flags := gi.NewIntArgument(int(flags))
	arg_io_priority := gi.NewInt32Argument(io_priority)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_v, arg_etag, arg_make_backup, arg_flags, arg_io_priority, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
	gi.Free(c_etag)
}

// g_file_replace_contents
// container is not nil, container is File
// is method
// arg 0 contents lenArgIdx 1
func (v *FileIfc) ReplaceContents(contents gi.Uint8Array, length uint64, etag string, make_backup bool, flags FileCreateFlags, cancellable ICancellable) (result bool, new_etag string, err error) {
	iv, err := _I.Get(610, "File", "replace_contents")
	if err != nil {
		return
	}
	var outArgs [2]gi.Argument
	c_etag := gi.CString(etag)
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_contents := gi.NewPointerArgument(contents.P)
	arg_length := gi.NewUint64Argument(length)
	arg_etag := gi.NewStringArgument(c_etag)
	arg_make_backup := gi.NewBoolArgument(make_backup)
	arg_flags := gi.NewIntArgument(int(flags))
	arg_new_etag := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[1]))
	args := []gi.Argument{arg_v, arg_contents, arg_length, arg_etag, arg_make_backup, arg_flags, arg_new_etag, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	gi.Free(c_etag)
	err = gi.ToError(outArgs[1].Pointer())
	new_etag = outArgs[0].String().Take()
	result = ret.Bool()
	return
}

// g_file_replace_contents_async
// container is not nil, container is File
// is method
// arg 0 contents lenArgIdx 1
func (v *FileIfc) ReplaceContentsAsync(contents gi.Uint8Array, length uint64, etag string, make_backup bool, flags FileCreateFlags, cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(611, "File", "replace_contents_async")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_etag := gi.CString(etag)
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_contents := gi.NewPointerArgument(contents.P)
	arg_length := gi.NewUint64Argument(length)
	arg_etag := gi.NewStringArgument(c_etag)
	arg_make_backup := gi.NewBoolArgument(make_backup)
	arg_flags := gi.NewIntArgument(int(flags))
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_v, arg_contents, arg_length, arg_etag, arg_make_backup, arg_flags, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
	gi.Free(c_etag)
}

// g_file_replace_contents_bytes_async
// container is not nil, container is File
// is method
func (v *FileIfc) ReplaceContentsBytesAsync(contents glib.Bytes, etag string, make_backup bool, flags FileCreateFlags, cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(612, "File", "replace_contents_bytes_async")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_etag := gi.CString(etag)
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_contents := gi.NewPointerArgument(contents.P)
	arg_etag := gi.NewStringArgument(c_etag)
	arg_make_backup := gi.NewBoolArgument(make_backup)
	arg_flags := gi.NewIntArgument(int(flags))
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_v, arg_contents, arg_etag, arg_make_backup, arg_flags, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
	gi.Free(c_etag)
}

// g_file_replace_contents_finish
// container is not nil, container is File
// is method
func (v *FileIfc) ReplaceContentsFinish(res IAsyncResult) (result bool, new_etag string, err error) {
	iv, err := _I.Get(613, "File", "replace_contents_finish")
	if err != nil {
		return
	}
	var outArgs [2]gi.Argument
	var tmp unsafe.Pointer
	if res != nil {
		tmp = res.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_res := gi.NewPointerArgument(tmp)
	arg_new_etag := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[1]))
	args := []gi.Argument{arg_v, arg_res, arg_new_etag, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[1].Pointer())
	new_etag = outArgs[0].String().Take()
	result = ret.Bool()
	return
}

// g_file_replace_finish
// container is not nil, container is File
// is method
func (v *FileIfc) ReplaceFinish(res IAsyncResult) (result FileOutputStream, err error) {
	iv, err := _I.Get(614, "File", "replace_finish")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if res != nil {
		tmp = res.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_res := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_res, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// g_file_replace_readwrite
// container is not nil, container is File
// is method
func (v *FileIfc) ReplaceReadwrite(etag string, make_backup bool, flags FileCreateFlags, cancellable ICancellable) (result FileIOStream, err error) {
	iv, err := _I.Get(615, "File", "replace_readwrite")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	c_etag := gi.CString(etag)
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_etag := gi.NewStringArgument(c_etag)
	arg_make_backup := gi.NewBoolArgument(make_backup)
	arg_flags := gi.NewIntArgument(int(flags))
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_etag, arg_make_backup, arg_flags, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	gi.Free(c_etag)
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// g_file_replace_readwrite_async
// container is not nil, container is File
// is method
func (v *FileIfc) ReplaceReadwriteAsync(etag string, make_backup bool, flags FileCreateFlags, io_priority int32, cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(616, "File", "replace_readwrite_async")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_etag := gi.CString(etag)
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_etag := gi.NewStringArgument(c_etag)
	arg_make_backup := gi.NewBoolArgument(make_backup)
	arg_flags := gi.NewIntArgument(int(flags))
	arg_io_priority := gi.NewInt32Argument(io_priority)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_v, arg_etag, arg_make_backup, arg_flags, arg_io_priority, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
	gi.Free(c_etag)
}

// g_file_replace_readwrite_finish
// container is not nil, container is File
// is method
func (v *FileIfc) ReplaceReadwriteFinish(res IAsyncResult) (result FileIOStream, err error) {
	iv, err := _I.Get(617, "File", "replace_readwrite_finish")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if res != nil {
		tmp = res.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_res := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_res, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// g_file_resolve_relative_path
// container is not nil, container is File
// is method
func (v *FileIfc) ResolveRelativePath(relative_path string) (result File) {
	iv, err := _I.Get(618, "File", "resolve_relative_path")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_relative_path := gi.CString(relative_path)
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_relative_path := gi.NewStringArgument(c_relative_path)
	args := []gi.Argument{arg_v, arg_relative_path}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_relative_path)
	result.P = ret.Pointer()
	return
}

// g_file_set_attribute
// container is not nil, container is File
// is method
func (v *FileIfc) SetAttribute(attribute string, type1 FileAttributeTypeEnum, value_p unsafe.Pointer, flags FileQueryInfoFlags, cancellable ICancellable) (result bool, err error) {
	iv, err := _I.Get(619, "File", "set_attribute")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	c_attribute := gi.CString(attribute)
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_attribute := gi.NewStringArgument(c_attribute)
	arg_type1 := gi.NewIntArgument(int(type1))
	arg_value_p := gi.NewPointerArgument(value_p)
	arg_flags := gi.NewIntArgument(int(flags))
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_attribute, arg_type1, arg_value_p, arg_flags, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	gi.Free(c_attribute)
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Bool()
	return
}

// g_file_set_attribute_byte_string
// container is not nil, container is File
// is method
func (v *FileIfc) SetAttributeByteString(attribute string, value string, flags FileQueryInfoFlags, cancellable ICancellable) (result bool, err error) {
	iv, err := _I.Get(620, "File", "set_attribute_byte_string")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	c_attribute := gi.CString(attribute)
	c_value := gi.CString(value)
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_attribute := gi.NewStringArgument(c_attribute)
	arg_value := gi.NewStringArgument(c_value)
	arg_flags := gi.NewIntArgument(int(flags))
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_attribute, arg_value, arg_flags, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	gi.Free(c_attribute)
	gi.Free(c_value)
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Bool()
	return
}

// g_file_set_attribute_int32
// container is not nil, container is File
// is method
func (v *FileIfc) SetAttributeInt32(attribute string, value int32, flags FileQueryInfoFlags, cancellable ICancellable) (result bool, err error) {
	iv, err := _I.Get(621, "File", "set_attribute_int32")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	c_attribute := gi.CString(attribute)
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_attribute := gi.NewStringArgument(c_attribute)
	arg_value := gi.NewInt32Argument(value)
	arg_flags := gi.NewIntArgument(int(flags))
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_attribute, arg_value, arg_flags, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	gi.Free(c_attribute)
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Bool()
	return
}

// g_file_set_attribute_int64
// container is not nil, container is File
// is method
func (v *FileIfc) SetAttributeInt64(attribute string, value int64, flags FileQueryInfoFlags, cancellable ICancellable) (result bool, err error) {
	iv, err := _I.Get(622, "File", "set_attribute_int64")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	c_attribute := gi.CString(attribute)
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_attribute := gi.NewStringArgument(c_attribute)
	arg_value := gi.NewInt64Argument(value)
	arg_flags := gi.NewIntArgument(int(flags))
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_attribute, arg_value, arg_flags, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	gi.Free(c_attribute)
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Bool()
	return
}

// g_file_set_attribute_string
// container is not nil, container is File
// is method
func (v *FileIfc) SetAttributeString(attribute string, value string, flags FileQueryInfoFlags, cancellable ICancellable) (result bool, err error) {
	iv, err := _I.Get(623, "File", "set_attribute_string")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	c_attribute := gi.CString(attribute)
	c_value := gi.CString(value)
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_attribute := gi.NewStringArgument(c_attribute)
	arg_value := gi.NewStringArgument(c_value)
	arg_flags := gi.NewIntArgument(int(flags))
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_attribute, arg_value, arg_flags, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	gi.Free(c_attribute)
	gi.Free(c_value)
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Bool()
	return
}

// g_file_set_attribute_uint32
// container is not nil, container is File
// is method
func (v *FileIfc) SetAttributeUint32(attribute string, value uint32, flags FileQueryInfoFlags, cancellable ICancellable) (result bool, err error) {
	iv, err := _I.Get(624, "File", "set_attribute_uint32")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	c_attribute := gi.CString(attribute)
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_attribute := gi.NewStringArgument(c_attribute)
	arg_value := gi.NewUint32Argument(value)
	arg_flags := gi.NewIntArgument(int(flags))
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_attribute, arg_value, arg_flags, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	gi.Free(c_attribute)
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Bool()
	return
}

// g_file_set_attribute_uint64
// container is not nil, container is File
// is method
func (v *FileIfc) SetAttributeUint64(attribute string, value uint64, flags FileQueryInfoFlags, cancellable ICancellable) (result bool, err error) {
	iv, err := _I.Get(625, "File", "set_attribute_uint64")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	c_attribute := gi.CString(attribute)
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_attribute := gi.NewStringArgument(c_attribute)
	arg_value := gi.NewUint64Argument(value)
	arg_flags := gi.NewIntArgument(int(flags))
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_attribute, arg_value, arg_flags, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	gi.Free(c_attribute)
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Bool()
	return
}

// g_file_set_attributes_async
// container is not nil, container is File
// is method
func (v *FileIfc) SetAttributesAsync(info IFileInfo, flags FileQueryInfoFlags, io_priority int32, cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(626, "File", "set_attributes_async")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if info != nil {
		tmp = info.P_FileInfo()
	}
	var tmp1 unsafe.Pointer
	if cancellable != nil {
		tmp1 = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_info := gi.NewPointerArgument(tmp)
	arg_flags := gi.NewIntArgument(int(flags))
	arg_io_priority := gi.NewInt32Argument(io_priority)
	arg_cancellable := gi.NewPointerArgument(tmp1)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_v, arg_info, arg_flags, arg_io_priority, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
}

// g_file_set_attributes_finish
// container is not nil, container is File
// is method
func (v *FileIfc) SetAttributesFinish(result IAsyncResult) (result1 bool, info FileInfo, err error) {
	iv, err := _I.Get(627, "File", "set_attributes_finish")
	if err != nil {
		return
	}
	var outArgs [2]gi.Argument
	var tmp unsafe.Pointer
	if result != nil {
		tmp = result.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_result := gi.NewPointerArgument(tmp)
	arg_info := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[1]))
	args := []gi.Argument{arg_v, arg_result, arg_info, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[1].Pointer())
	info.P = outArgs[0].Pointer()
	result1 = ret.Bool()
	return
}

// g_file_set_attributes_from_info
// container is not nil, container is File
// is method
func (v *FileIfc) SetAttributesFromInfo(info IFileInfo, flags FileQueryInfoFlags, cancellable ICancellable) (result bool, err error) {
	iv, err := _I.Get(628, "File", "set_attributes_from_info")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if info != nil {
		tmp = info.P_FileInfo()
	}
	var tmp1 unsafe.Pointer
	if cancellable != nil {
		tmp1 = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_info := gi.NewPointerArgument(tmp)
	arg_flags := gi.NewIntArgument(int(flags))
	arg_cancellable := gi.NewPointerArgument(tmp1)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_info, arg_flags, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Bool()
	return
}

// g_file_set_display_name
// container is not nil, container is File
// is method
func (v *FileIfc) SetDisplayName(display_name string, cancellable ICancellable) (result File, err error) {
	iv, err := _I.Get(629, "File", "set_display_name")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	c_display_name := gi.CString(display_name)
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_display_name := gi.NewStringArgument(c_display_name)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_display_name, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	gi.Free(c_display_name)
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// g_file_set_display_name_async
// container is not nil, container is File
// is method
func (v *FileIfc) SetDisplayNameAsync(display_name string, io_priority int32, cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(630, "File", "set_display_name_async")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_display_name := gi.CString(display_name)
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_display_name := gi.NewStringArgument(c_display_name)
	arg_io_priority := gi.NewInt32Argument(io_priority)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_v, arg_display_name, arg_io_priority, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
	gi.Free(c_display_name)
}

// g_file_set_display_name_finish
// container is not nil, container is File
// is method
func (v *FileIfc) SetDisplayNameFinish(res IAsyncResult) (result File, err error) {
	iv, err := _I.Get(631, "File", "set_display_name_finish")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if res != nil {
		tmp = res.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_res := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_res, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// g_file_start_mountable
// container is not nil, container is File
// is method
func (v *FileIfc) StartMountable(flags DriveStartFlags, start_operation IMountOperation, cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(632, "File", "start_mountable")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if start_operation != nil {
		tmp = start_operation.P_MountOperation()
	}
	var tmp1 unsafe.Pointer
	if cancellable != nil {
		tmp1 = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_flags := gi.NewIntArgument(int(flags))
	arg_start_operation := gi.NewPointerArgument(tmp)
	arg_cancellable := gi.NewPointerArgument(tmp1)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_v, arg_flags, arg_start_operation, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
}

// g_file_start_mountable_finish
// container is not nil, container is File
// is method
func (v *FileIfc) StartMountableFinish(result IAsyncResult) (result1 bool, err error) {
	iv, err := _I.Get(633, "File", "start_mountable_finish")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if result != nil {
		tmp = result.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_result := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_result, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result1 = ret.Bool()
	return
}

// g_file_stop_mountable
// container is not nil, container is File
// is method
func (v *FileIfc) StopMountable(flags MountUnmountFlags, mount_operation IMountOperation, cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(634, "File", "stop_mountable")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if mount_operation != nil {
		tmp = mount_operation.P_MountOperation()
	}
	var tmp1 unsafe.Pointer
	if cancellable != nil {
		tmp1 = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_flags := gi.NewIntArgument(int(flags))
	arg_mount_operation := gi.NewPointerArgument(tmp)
	arg_cancellable := gi.NewPointerArgument(tmp1)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_v, arg_flags, arg_mount_operation, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
}

// g_file_stop_mountable_finish
// container is not nil, container is File
// is method
func (v *FileIfc) StopMountableFinish(result IAsyncResult) (result1 bool, err error) {
	iv, err := _I.Get(635, "File", "stop_mountable_finish")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if result != nil {
		tmp = result.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_result := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_result, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result1 = ret.Bool()
	return
}

// g_file_supports_thread_contexts
// container is not nil, container is File
// is method
func (v *FileIfc) SupportsThreadContexts() (result bool) {
	iv, err := _I.Get(636, "File", "supports_thread_contexts")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_file_trash
// container is not nil, container is File
// is method
func (v *FileIfc) Trash(cancellable ICancellable) (result bool, err error) {
	iv, err := _I.Get(637, "File", "trash")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Bool()
	return
}

// g_file_trash_async
// container is not nil, container is File
// is method
func (v *FileIfc) TrashAsync(io_priority int32, cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(638, "File", "trash_async")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_io_priority := gi.NewInt32Argument(io_priority)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_v, arg_io_priority, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
}

// g_file_trash_finish
// container is not nil, container is File
// is method
func (v *FileIfc) TrashFinish(result IAsyncResult) (result1 bool, err error) {
	iv, err := _I.Get(639, "File", "trash_finish")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if result != nil {
		tmp = result.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_result := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_result, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result1 = ret.Bool()
	return
}

// g_file_unmount_mountable
// container is not nil, container is File
// is method
func (v *FileIfc) UnmountMountable(flags MountUnmountFlags, cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(640, "File", "unmount_mountable")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_flags := gi.NewIntArgument(int(flags))
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_v, arg_flags, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
}

// g_file_unmount_mountable_finish
// container is not nil, container is File
// is method
func (v *FileIfc) UnmountMountableFinish(result IAsyncResult) (result1 bool, err error) {
	iv, err := _I.Get(641, "File", "unmount_mountable_finish")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if result != nil {
		tmp = result.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_result := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_result, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result1 = ret.Bool()
	return
}

// g_file_unmount_mountable_with_operation
// container is not nil, container is File
// is method
func (v *FileIfc) UnmountMountableWithOperation(flags MountUnmountFlags, mount_operation IMountOperation, cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(642, "File", "unmount_mountable_with_operation")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if mount_operation != nil {
		tmp = mount_operation.P_MountOperation()
	}
	var tmp1 unsafe.Pointer
	if cancellable != nil {
		tmp1 = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_flags := gi.NewIntArgument(int(flags))
	arg_mount_operation := gi.NewPointerArgument(tmp)
	arg_cancellable := gi.NewPointerArgument(tmp1)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_v, arg_flags, arg_mount_operation, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
}

// g_file_unmount_mountable_with_operation_finish
// container is not nil, container is File
// is method
func (v *FileIfc) UnmountMountableWithOperationFinish(result IAsyncResult) (result1 bool, err error) {
	iv, err := _I.Get(643, "File", "unmount_mountable_with_operation_finish")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if result != nil {
		tmp = result.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_result := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_result, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result1 = ret.Bool()
	return
}

// Struct FileAttributeInfo
type FileAttributeInfo struct {
	P unsafe.Pointer
}

const SizeOfStructFileAttributeInfo = 16

func FileAttributeInfoGetType() gi.GType {
	ret := _I.GetGType(105, "FileAttributeInfo")
	return ret
}

// Flags FileAttributeInfoFlags
type FileAttributeInfoFlags int

const (
	FileAttributeInfoFlagsNone          FileAttributeInfoFlags = 0
	FileAttributeInfoFlagsCopyWithFile  FileAttributeInfoFlags = 1
	FileAttributeInfoFlagsCopyWhenMoved FileAttributeInfoFlags = 2
)

func FileAttributeInfoFlagsGetType() gi.GType {
	ret := _I.GetGType(106, "FileAttributeInfoFlags")
	return ret
}

// Struct FileAttributeInfoList
type FileAttributeInfoList struct {
	P unsafe.Pointer
}

const SizeOfStructFileAttributeInfoList = 16

func FileAttributeInfoListGetType() gi.GType {
	ret := _I.GetGType(107, "FileAttributeInfoList")
	return ret
}

// g_file_attribute_info_list_new
// container is not nil, container is FileAttributeInfoList
// is constructor
func NewFileAttributeInfoList() (result FileAttributeInfoList) {
	iv, err := _I.Get(644, "FileAttributeInfoList", "new")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var ret gi.Argument
	iv.Call(nil, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_file_attribute_info_list_add
// container is not nil, container is FileAttributeInfoList
// is method
func (v FileAttributeInfoList) Add(name string, type1 FileAttributeTypeEnum, flags FileAttributeInfoFlags) {
	iv, err := _I.Get(645, "FileAttributeInfoList", "add")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_name := gi.CString(name)
	arg_v := gi.NewPointerArgument(v.P)
	arg_name := gi.NewStringArgument(c_name)
	arg_type1 := gi.NewIntArgument(int(type1))
	arg_flags := gi.NewIntArgument(int(flags))
	args := []gi.Argument{arg_v, arg_name, arg_type1, arg_flags}
	iv.Call(args, nil, nil)
	gi.Free(c_name)
}

// g_file_attribute_info_list_dup
// container is not nil, container is FileAttributeInfoList
// is method
func (v FileAttributeInfoList) Dup() (result FileAttributeInfoList) {
	iv, err := _I.Get(646, "FileAttributeInfoList", "dup")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_file_attribute_info_list_lookup
// container is not nil, container is FileAttributeInfoList
// is method
func (v FileAttributeInfoList) Lookup(name string) (result FileAttributeInfo) {
	iv, err := _I.Get(647, "FileAttributeInfoList", "lookup")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_name := gi.CString(name)
	arg_v := gi.NewPointerArgument(v.P)
	arg_name := gi.NewStringArgument(c_name)
	args := []gi.Argument{arg_v, arg_name}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_name)
	result.P = ret.Pointer()
	return
}

// g_file_attribute_info_list_ref
// container is not nil, container is FileAttributeInfoList
// is method
func (v FileAttributeInfoList) Ref() (result FileAttributeInfoList) {
	iv, err := _I.Get(648, "FileAttributeInfoList", "ref")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_file_attribute_info_list_unref
// container is not nil, container is FileAttributeInfoList
// is method
func (v FileAttributeInfoList) Unref() {
	iv, err := _I.Get(649, "FileAttributeInfoList", "unref")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	iv.Call(args, nil, nil)
}

// Struct FileAttributeMatcher
type FileAttributeMatcher struct {
	P unsafe.Pointer
}

func FileAttributeMatcherGetType() gi.GType {
	ret := _I.GetGType(108, "FileAttributeMatcher")
	return ret
}

// g_file_attribute_matcher_new
// container is not nil, container is FileAttributeMatcher
// is constructor
func NewFileAttributeMatcher(attributes string) (result FileAttributeMatcher) {
	iv, err := _I.Get(650, "FileAttributeMatcher", "new")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_attributes := gi.CString(attributes)
	arg_attributes := gi.NewStringArgument(c_attributes)
	args := []gi.Argument{arg_attributes}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_attributes)
	result.P = ret.Pointer()
	return
}

// g_file_attribute_matcher_enumerate_namespace
// container is not nil, container is FileAttributeMatcher
// is method
func (v FileAttributeMatcher) EnumerateNamespace(ns string) (result bool) {
	iv, err := _I.Get(651, "FileAttributeMatcher", "enumerate_namespace")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_ns := gi.CString(ns)
	arg_v := gi.NewPointerArgument(v.P)
	arg_ns := gi.NewStringArgument(c_ns)
	args := []gi.Argument{arg_v, arg_ns}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_ns)
	result = ret.Bool()
	return
}

// g_file_attribute_matcher_enumerate_next
// container is not nil, container is FileAttributeMatcher
// is method
func (v FileAttributeMatcher) EnumerateNext() (result string) {
	iv, err := _I.Get(652, "FileAttributeMatcher", "enumerate_next")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Take()
	return
}

// g_file_attribute_matcher_matches
// container is not nil, container is FileAttributeMatcher
// is method
func (v FileAttributeMatcher) Matches(attribute string) (result bool) {
	iv, err := _I.Get(653, "FileAttributeMatcher", "matches")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_attribute := gi.CString(attribute)
	arg_v := gi.NewPointerArgument(v.P)
	arg_attribute := gi.NewStringArgument(c_attribute)
	args := []gi.Argument{arg_v, arg_attribute}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_attribute)
	result = ret.Bool()
	return
}

// g_file_attribute_matcher_matches_only
// container is not nil, container is FileAttributeMatcher
// is method
func (v FileAttributeMatcher) MatchesOnly(attribute string) (result bool) {
	iv, err := _I.Get(654, "FileAttributeMatcher", "matches_only")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_attribute := gi.CString(attribute)
	arg_v := gi.NewPointerArgument(v.P)
	arg_attribute := gi.NewStringArgument(c_attribute)
	args := []gi.Argument{arg_v, arg_attribute}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_attribute)
	result = ret.Bool()
	return
}

// g_file_attribute_matcher_ref
// container is not nil, container is FileAttributeMatcher
// is method
func (v FileAttributeMatcher) Ref() (result FileAttributeMatcher) {
	iv, err := _I.Get(655, "FileAttributeMatcher", "ref")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_file_attribute_matcher_subtract
// container is not nil, container is FileAttributeMatcher
// is method
func (v FileAttributeMatcher) Subtract(subtract FileAttributeMatcher) (result FileAttributeMatcher) {
	iv, err := _I.Get(656, "FileAttributeMatcher", "subtract")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_subtract := gi.NewPointerArgument(subtract.P)
	args := []gi.Argument{arg_v, arg_subtract}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_file_attribute_matcher_to_string
// container is not nil, container is FileAttributeMatcher
// is method
func (v FileAttributeMatcher) ToString() (result string) {
	iv, err := _I.Get(657, "FileAttributeMatcher", "to_string")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Take()
	return
}

// g_file_attribute_matcher_unref
// container is not nil, container is FileAttributeMatcher
// is method
func (v FileAttributeMatcher) Unref() {
	iv, err := _I.Get(658, "FileAttributeMatcher", "unref")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	iv.Call(args, nil, nil)
}

// Enum FileAttributeStatus
type FileAttributeStatusEnum int

const (
	FileAttributeStatusUnset        FileAttributeStatusEnum = 0
	FileAttributeStatusSet          FileAttributeStatusEnum = 1
	FileAttributeStatusErrorSetting FileAttributeStatusEnum = 2
)

func FileAttributeStatusGetType() gi.GType {
	ret := _I.GetGType(109, "FileAttributeStatus")
	return ret
}

// Enum FileAttributeType
type FileAttributeTypeEnum int

const (
	FileAttributeTypeInvalid    FileAttributeTypeEnum = 0
	FileAttributeTypeString     FileAttributeTypeEnum = 1
	FileAttributeTypeByteString FileAttributeTypeEnum = 2
	FileAttributeTypeBoolean    FileAttributeTypeEnum = 3
	FileAttributeTypeUint32     FileAttributeTypeEnum = 4
	FileAttributeTypeInt32      FileAttributeTypeEnum = 5
	FileAttributeTypeUint64     FileAttributeTypeEnum = 6
	FileAttributeTypeInt64      FileAttributeTypeEnum = 7
	FileAttributeTypeObject     FileAttributeTypeEnum = 8
	FileAttributeTypeStringv    FileAttributeTypeEnum = 9
)

func FileAttributeTypeGetType() gi.GType {
	ret := _I.GetGType(110, "FileAttributeType")
	return ret
}

// Flags FileCopyFlags
type FileCopyFlags int

const (
	FileCopyFlagsNone               FileCopyFlags = 0
	FileCopyFlagsOverwrite          FileCopyFlags = 1
	FileCopyFlagsBackup             FileCopyFlags = 2
	FileCopyFlagsNofollowSymlinks   FileCopyFlags = 4
	FileCopyFlagsAllMetadata        FileCopyFlags = 8
	FileCopyFlagsNoFallbackForMove  FileCopyFlags = 16
	FileCopyFlagsTargetDefaultPerms FileCopyFlags = 32
)

func FileCopyFlagsGetType() gi.GType {
	ret := _I.GetGType(111, "FileCopyFlags")
	return ret
}

// Flags FileCreateFlags
type FileCreateFlags int

const (
	FileCreateFlagsNone               FileCreateFlags = 0
	FileCreateFlagsPrivate            FileCreateFlags = 1
	FileCreateFlagsReplaceDestination FileCreateFlags = 2
)

func FileCreateFlagsGetType() gi.GType {
	ret := _I.GetGType(112, "FileCreateFlags")
	return ret
}

// Interface FileDescriptorBased
type FileDescriptorBased struct {
	FileDescriptorBasedIfc
	P unsafe.Pointer
}
type FileDescriptorBasedIfc struct{}
type IFileDescriptorBased interface{ P_FileDescriptorBased() unsafe.Pointer }

func (v FileDescriptorBased) P_FileDescriptorBased() unsafe.Pointer { return v.P }
func FileDescriptorBasedGetType() gi.GType {
	ret := _I.GetGType(113, "FileDescriptorBased")
	return ret
}

// g_file_descriptor_based_get_fd
// container is not nil, container is FileDescriptorBased
// is method
func (v *FileDescriptorBasedIfc) GetFd() (result int32) {
	iv, err := _I.Get(659, "FileDescriptorBased", "get_fd")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Int32()
	return
}

// ignore GType struct FileDescriptorBasedIface
// Object FileEnumerator
type FileEnumerator struct {
	gobject.Object
}

func WrapFileEnumerator(p unsafe.Pointer) (r FileEnumerator) { r.P = p; return }

type IFileEnumerator interface{ P_FileEnumerator() unsafe.Pointer }

func (v FileEnumerator) P_FileEnumerator() unsafe.Pointer { return v.P }
func FileEnumeratorGetType() gi.GType {
	ret := _I.GetGType(114, "FileEnumerator")
	return ret
}

// g_file_enumerator_close
// container is not nil, container is FileEnumerator
// is method
func (v FileEnumerator) Close(cancellable ICancellable) (result bool, err error) {
	iv, err := _I.Get(660, "FileEnumerator", "close")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Bool()
	return
}

// g_file_enumerator_close_async
// container is not nil, container is FileEnumerator
// is method
func (v FileEnumerator) CloseAsync(io_priority int32, cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(661, "FileEnumerator", "close_async")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_io_priority := gi.NewInt32Argument(io_priority)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_v, arg_io_priority, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
}

// g_file_enumerator_close_finish
// container is not nil, container is FileEnumerator
// is method
func (v FileEnumerator) CloseFinish(result IAsyncResult) (result1 bool, err error) {
	iv, err := _I.Get(662, "FileEnumerator", "close_finish")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if result != nil {
		tmp = result.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_result := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_result, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result1 = ret.Bool()
	return
}

// g_file_enumerator_get_child
// container is not nil, container is FileEnumerator
// is method
func (v FileEnumerator) GetChild(info IFileInfo) (result File) {
	iv, err := _I.Get(663, "FileEnumerator", "get_child")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if info != nil {
		tmp = info.P_FileInfo()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_info := gi.NewPointerArgument(tmp)
	args := []gi.Argument{arg_v, arg_info}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_file_enumerator_get_container
// container is not nil, container is FileEnumerator
// is method
func (v FileEnumerator) GetContainer() (result File) {
	iv, err := _I.Get(664, "FileEnumerator", "get_container")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_file_enumerator_has_pending
// container is not nil, container is FileEnumerator
// is method
func (v FileEnumerator) HasPending() (result bool) {
	iv, err := _I.Get(665, "FileEnumerator", "has_pending")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_file_enumerator_is_closed
// container is not nil, container is FileEnumerator
// is method
func (v FileEnumerator) IsClosed() (result bool) {
	iv, err := _I.Get(666, "FileEnumerator", "is_closed")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_file_enumerator_iterate
// container is not nil, container is FileEnumerator
// is method
func (v FileEnumerator) Iterate(cancellable ICancellable) (result bool, out_info FileInfo, out_child File, err error) {
	iv, err := _I.Get(667, "FileEnumerator", "iterate")
	if err != nil {
		return
	}
	var outArgs [3]gi.Argument
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_out_info := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	arg_out_child := gi.NewPointerArgument(unsafe.Pointer(&outArgs[1]))
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[2]))
	args := []gi.Argument{arg_v, arg_out_info, arg_out_child, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[2].Pointer())
	out_info.P = outArgs[0].Pointer()
	out_child.P = outArgs[1].Pointer()
	result = ret.Bool()
	return
}

// g_file_enumerator_next_file
// container is not nil, container is FileEnumerator
// is method
func (v FileEnumerator) NextFile(cancellable ICancellable) (result FileInfo, err error) {
	iv, err := _I.Get(668, "FileEnumerator", "next_file")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// g_file_enumerator_next_files_async
// container is not nil, container is FileEnumerator
// is method
func (v FileEnumerator) NextFilesAsync(num_files int32, io_priority int32, cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(669, "FileEnumerator", "next_files_async")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_num_files := gi.NewInt32Argument(num_files)
	arg_io_priority := gi.NewInt32Argument(io_priority)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_v, arg_num_files, arg_io_priority, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
}

// g_file_enumerator_next_files_finish
// container is not nil, container is FileEnumerator
// is method
func (v FileEnumerator) NextFilesFinish(result IAsyncResult) (result1 glib.List, err error) {
	iv, err := _I.Get(670, "FileEnumerator", "next_files_finish")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if result != nil {
		tmp = result.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_result := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_result, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result1.P = ret.Pointer()
	return
}

// g_file_enumerator_set_pending
// container is not nil, container is FileEnumerator
// is method
func (v FileEnumerator) SetPending(pending bool) {
	iv, err := _I.Get(671, "FileEnumerator", "set_pending")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_pending := gi.NewBoolArgument(pending)
	args := []gi.Argument{arg_v, arg_pending}
	iv.Call(args, nil, nil)
}

// ignore GType struct FileEnumeratorClass
// Struct FileEnumeratorPrivate
type FileEnumeratorPrivate struct {
	P unsafe.Pointer
}

func FileEnumeratorPrivateGetType() gi.GType {
	ret := _I.GetGType(115, "FileEnumeratorPrivate")
	return ret
}

// Object FileIOStream
type FileIOStream struct {
	SeekableIfc
	IOStream
}

func WrapFileIOStream(p unsafe.Pointer) (r FileIOStream) { r.P = p; return }

type IFileIOStream interface{ P_FileIOStream() unsafe.Pointer }

func (v FileIOStream) P_FileIOStream() unsafe.Pointer { return v.P }
func (v FileIOStream) P_Seekable() unsafe.Pointer     { return v.P }
func FileIOStreamGetType() gi.GType {
	ret := _I.GetGType(116, "FileIOStream")
	return ret
}

// g_file_io_stream_get_etag
// container is not nil, container is FileIOStream
// is method
func (v FileIOStream) GetEtag() (result string) {
	iv, err := _I.Get(672, "FileIOStream", "get_etag")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Take()
	return
}

// g_file_io_stream_query_info
// container is not nil, container is FileIOStream
// is method
func (v FileIOStream) QueryInfo(attributes string, cancellable ICancellable) (result FileInfo, err error) {
	iv, err := _I.Get(673, "FileIOStream", "query_info")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	c_attributes := gi.CString(attributes)
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_attributes := gi.NewStringArgument(c_attributes)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_attributes, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	gi.Free(c_attributes)
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// g_file_io_stream_query_info_async
// container is not nil, container is FileIOStream
// is method
func (v FileIOStream) QueryInfoAsync(attributes string, io_priority int32, cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(674, "FileIOStream", "query_info_async")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_attributes := gi.CString(attributes)
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_attributes := gi.NewStringArgument(c_attributes)
	arg_io_priority := gi.NewInt32Argument(io_priority)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_v, arg_attributes, arg_io_priority, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
	gi.Free(c_attributes)
}

// g_file_io_stream_query_info_finish
// container is not nil, container is FileIOStream
// is method
func (v FileIOStream) QueryInfoFinish(result IAsyncResult) (result1 FileInfo, err error) {
	iv, err := _I.Get(675, "FileIOStream", "query_info_finish")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if result != nil {
		tmp = result.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_result := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_result, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result1.P = ret.Pointer()
	return
}

// ignore GType struct FileIOStreamClass
// Struct FileIOStreamPrivate
type FileIOStreamPrivate struct {
	P unsafe.Pointer
}

func FileIOStreamPrivateGetType() gi.GType {
	ret := _I.GetGType(117, "FileIOStreamPrivate")
	return ret
}

// Object FileIcon
type FileIcon struct {
	IconIfc
	LoadableIconIfc
	gobject.Object
}

func WrapFileIcon(p unsafe.Pointer) (r FileIcon) { r.P = p; return }

type IFileIcon interface{ P_FileIcon() unsafe.Pointer }

func (v FileIcon) P_FileIcon() unsafe.Pointer     { return v.P }
func (v FileIcon) P_Icon() unsafe.Pointer         { return v.P }
func (v FileIcon) P_LoadableIcon() unsafe.Pointer { return v.P }
func FileIconGetType() gi.GType {
	ret := _I.GetGType(118, "FileIcon")
	return ret
}

// g_file_icon_new
// container is not nil, container is FileIcon
// is constructor
func NewFileIcon(file IFile) (result FileIcon) {
	iv, err := _I.Get(676, "FileIcon", "new")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if file != nil {
		tmp = file.P_File()
	}
	arg_file := gi.NewPointerArgument(tmp)
	args := []gi.Argument{arg_file}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_file_icon_get_file
// container is not nil, container is FileIcon
// is method
func (v FileIcon) GetFile() (result File) {
	iv, err := _I.Get(677, "FileIcon", "get_file")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// ignore GType struct FileIconClass
// ignore GType struct FileIface
// Object FileInfo
type FileInfo struct {
	gobject.Object
}

func WrapFileInfo(p unsafe.Pointer) (r FileInfo) { r.P = p; return }

type IFileInfo interface{ P_FileInfo() unsafe.Pointer }

func (v FileInfo) P_FileInfo() unsafe.Pointer { return v.P }
func FileInfoGetType() gi.GType {
	ret := _I.GetGType(119, "FileInfo")
	return ret
}

// g_file_info_new
// container is not nil, container is FileInfo
// is constructor
func NewFileInfo() (result FileInfo) {
	iv, err := _I.Get(678, "FileInfo", "new")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var ret gi.Argument
	iv.Call(nil, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_file_info_clear_status
// container is not nil, container is FileInfo
// is method
func (v FileInfo) ClearStatus() {
	iv, err := _I.Get(679, "FileInfo", "clear_status")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	iv.Call(args, nil, nil)
}

// g_file_info_copy_into
// container is not nil, container is FileInfo
// is method
func (v FileInfo) CopyInto(dest_info IFileInfo) {
	iv, err := _I.Get(680, "FileInfo", "copy_into")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if dest_info != nil {
		tmp = dest_info.P_FileInfo()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_dest_info := gi.NewPointerArgument(tmp)
	args := []gi.Argument{arg_v, arg_dest_info}
	iv.Call(args, nil, nil)
}

// g_file_info_dup
// container is not nil, container is FileInfo
// is method
func (v FileInfo) Dup() (result FileInfo) {
	iv, err := _I.Get(681, "FileInfo", "dup")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_file_info_get_attribute_as_string
// container is not nil, container is FileInfo
// is method
func (v FileInfo) GetAttributeAsString(attribute string) (result string) {
	iv, err := _I.Get(682, "FileInfo", "get_attribute_as_string")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_attribute := gi.CString(attribute)
	arg_v := gi.NewPointerArgument(v.P)
	arg_attribute := gi.NewStringArgument(c_attribute)
	args := []gi.Argument{arg_v, arg_attribute}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_attribute)
	result = ret.String().Take()
	return
}

// g_file_info_get_attribute_boolean
// container is not nil, container is FileInfo
// is method
func (v FileInfo) GetAttributeBoolean(attribute string) (result bool) {
	iv, err := _I.Get(683, "FileInfo", "get_attribute_boolean")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_attribute := gi.CString(attribute)
	arg_v := gi.NewPointerArgument(v.P)
	arg_attribute := gi.NewStringArgument(c_attribute)
	args := []gi.Argument{arg_v, arg_attribute}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_attribute)
	result = ret.Bool()
	return
}

// g_file_info_get_attribute_byte_string
// container is not nil, container is FileInfo
// is method
func (v FileInfo) GetAttributeByteString(attribute string) (result string) {
	iv, err := _I.Get(684, "FileInfo", "get_attribute_byte_string")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_attribute := gi.CString(attribute)
	arg_v := gi.NewPointerArgument(v.P)
	arg_attribute := gi.NewStringArgument(c_attribute)
	args := []gi.Argument{arg_v, arg_attribute}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_attribute)
	result = ret.String().Take()
	return
}

// g_file_info_get_attribute_data
// container is not nil, container is FileInfo
// is method
func (v FileInfo) GetAttributeData(attribute string) (result bool, type1 FileAttributeTypeEnum, value_pp unsafe.Pointer, status FileAttributeStatusEnum) {
	iv, err := _I.Get(685, "FileInfo", "get_attribute_data")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var outArgs [3]gi.Argument
	c_attribute := gi.CString(attribute)
	arg_v := gi.NewPointerArgument(v.P)
	arg_attribute := gi.NewStringArgument(c_attribute)
	arg_type1 := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	arg_value_pp := gi.NewPointerArgument(unsafe.Pointer(&outArgs[1]))
	arg_status := gi.NewPointerArgument(unsafe.Pointer(&outArgs[2]))
	args := []gi.Argument{arg_v, arg_attribute, arg_type1, arg_value_pp, arg_status}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	gi.Free(c_attribute)
	type1 = FileAttributeTypeEnum(outArgs[0].Int())
	value_pp = outArgs[1].Pointer()
	status = FileAttributeStatusEnum(outArgs[2].Int())
	result = ret.Bool()
	return
}

// g_file_info_get_attribute_int32
// container is not nil, container is FileInfo
// is method
func (v FileInfo) GetAttributeInt32(attribute string) (result int32) {
	iv, err := _I.Get(686, "FileInfo", "get_attribute_int32")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_attribute := gi.CString(attribute)
	arg_v := gi.NewPointerArgument(v.P)
	arg_attribute := gi.NewStringArgument(c_attribute)
	args := []gi.Argument{arg_v, arg_attribute}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_attribute)
	result = ret.Int32()
	return
}

// g_file_info_get_attribute_int64
// container is not nil, container is FileInfo
// is method
func (v FileInfo) GetAttributeInt64(attribute string) (result int64) {
	iv, err := _I.Get(687, "FileInfo", "get_attribute_int64")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_attribute := gi.CString(attribute)
	arg_v := gi.NewPointerArgument(v.P)
	arg_attribute := gi.NewStringArgument(c_attribute)
	args := []gi.Argument{arg_v, arg_attribute}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_attribute)
	result = ret.Int64()
	return
}

// g_file_info_get_attribute_object
// container is not nil, container is FileInfo
// is method
func (v FileInfo) GetAttributeObject(attribute string) (result gobject.Object) {
	iv, err := _I.Get(688, "FileInfo", "get_attribute_object")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_attribute := gi.CString(attribute)
	arg_v := gi.NewPointerArgument(v.P)
	arg_attribute := gi.NewStringArgument(c_attribute)
	args := []gi.Argument{arg_v, arg_attribute}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_attribute)
	result.P = ret.Pointer()
	return
}

// g_file_info_get_attribute_status
// container is not nil, container is FileInfo
// is method
func (v FileInfo) GetAttributeStatus(attribute string) (result FileAttributeStatusEnum) {
	iv, err := _I.Get(689, "FileInfo", "get_attribute_status")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_attribute := gi.CString(attribute)
	arg_v := gi.NewPointerArgument(v.P)
	arg_attribute := gi.NewStringArgument(c_attribute)
	args := []gi.Argument{arg_v, arg_attribute}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_attribute)
	result = FileAttributeStatusEnum(ret.Int())
	return
}

// g_file_info_get_attribute_string
// container is not nil, container is FileInfo
// is method
func (v FileInfo) GetAttributeString(attribute string) (result string) {
	iv, err := _I.Get(690, "FileInfo", "get_attribute_string")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_attribute := gi.CString(attribute)
	arg_v := gi.NewPointerArgument(v.P)
	arg_attribute := gi.NewStringArgument(c_attribute)
	args := []gi.Argument{arg_v, arg_attribute}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_attribute)
	result = ret.String().Take()
	return
}

// g_file_info_get_attribute_stringv
// container is not nil, container is FileInfo
// is method
func (v FileInfo) GetAttributeStringv(attribute string) (result gi.CStrArray) {
	iv, err := _I.Get(691, "FileInfo", "get_attribute_stringv")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_attribute := gi.CString(attribute)
	arg_v := gi.NewPointerArgument(v.P)
	arg_attribute := gi.NewStringArgument(c_attribute)
	args := []gi.Argument{arg_v, arg_attribute}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_attribute)
	result = gi.CStrArray{P: ret.Pointer(), Len: -1}
	result.SetLenZT()
	return
}

// g_file_info_get_attribute_type
// container is not nil, container is FileInfo
// is method
func (v FileInfo) GetAttributeType(attribute string) (result FileAttributeTypeEnum) {
	iv, err := _I.Get(692, "FileInfo", "get_attribute_type")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_attribute := gi.CString(attribute)
	arg_v := gi.NewPointerArgument(v.P)
	arg_attribute := gi.NewStringArgument(c_attribute)
	args := []gi.Argument{arg_v, arg_attribute}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_attribute)
	result = FileAttributeTypeEnum(ret.Int())
	return
}

// g_file_info_get_attribute_uint32
// container is not nil, container is FileInfo
// is method
func (v FileInfo) GetAttributeUint32(attribute string) (result uint32) {
	iv, err := _I.Get(693, "FileInfo", "get_attribute_uint32")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_attribute := gi.CString(attribute)
	arg_v := gi.NewPointerArgument(v.P)
	arg_attribute := gi.NewStringArgument(c_attribute)
	args := []gi.Argument{arg_v, arg_attribute}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_attribute)
	result = ret.Uint32()
	return
}

// g_file_info_get_attribute_uint64
// container is not nil, container is FileInfo
// is method
func (v FileInfo) GetAttributeUint64(attribute string) (result uint64) {
	iv, err := _I.Get(694, "FileInfo", "get_attribute_uint64")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_attribute := gi.CString(attribute)
	arg_v := gi.NewPointerArgument(v.P)
	arg_attribute := gi.NewStringArgument(c_attribute)
	args := []gi.Argument{arg_v, arg_attribute}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_attribute)
	result = ret.Uint64()
	return
}

// g_file_info_get_content_type
// container is not nil, container is FileInfo
// is method
func (v FileInfo) GetContentType() (result string) {
	iv, err := _I.Get(695, "FileInfo", "get_content_type")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Take()
	return
}

// g_file_info_get_deletion_date
// container is not nil, container is FileInfo
// is method
func (v FileInfo) GetDeletionDate() (result glib.DateTime) {
	iv, err := _I.Get(696, "FileInfo", "get_deletion_date")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_file_info_get_display_name
// container is not nil, container is FileInfo
// is method
func (v FileInfo) GetDisplayName() (result string) {
	iv, err := _I.Get(697, "FileInfo", "get_display_name")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Take()
	return
}

// g_file_info_get_edit_name
// container is not nil, container is FileInfo
// is method
func (v FileInfo) GetEditName() (result string) {
	iv, err := _I.Get(698, "FileInfo", "get_edit_name")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Take()
	return
}

// g_file_info_get_etag
// container is not nil, container is FileInfo
// is method
func (v FileInfo) GetEtag() (result string) {
	iv, err := _I.Get(699, "FileInfo", "get_etag")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Take()
	return
}

// g_file_info_get_file_type
// container is not nil, container is FileInfo
// is method
func (v FileInfo) GetFileType() (result FileTypeEnum) {
	iv, err := _I.Get(700, "FileInfo", "get_file_type")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = FileTypeEnum(ret.Int())
	return
}

// g_file_info_get_icon
// container is not nil, container is FileInfo
// is method
func (v FileInfo) GetIcon() (result Icon) {
	iv, err := _I.Get(701, "FileInfo", "get_icon")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_file_info_get_is_backup
// container is not nil, container is FileInfo
// is method
func (v FileInfo) GetIsBackup() (result bool) {
	iv, err := _I.Get(702, "FileInfo", "get_is_backup")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_file_info_get_is_hidden
// container is not nil, container is FileInfo
// is method
func (v FileInfo) GetIsHidden() (result bool) {
	iv, err := _I.Get(703, "FileInfo", "get_is_hidden")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_file_info_get_is_symlink
// container is not nil, container is FileInfo
// is method
func (v FileInfo) GetIsSymlink() (result bool) {
	iv, err := _I.Get(704, "FileInfo", "get_is_symlink")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_file_info_get_modification_time
// container is not nil, container is FileInfo
// is method
func (v FileInfo) GetModificationTime(result glib.TimeVal) {
	iv, err := _I.Get(705, "FileInfo", "get_modification_time")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_result := gi.NewPointerArgument(result.P)
	args := []gi.Argument{arg_v, arg_result}
	iv.Call(args, nil, nil)
}

// g_file_info_get_name
// container is not nil, container is FileInfo
// is method
func (v FileInfo) GetName() (result string) {
	iv, err := _I.Get(706, "FileInfo", "get_name")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Take()
	return
}

// g_file_info_get_size
// container is not nil, container is FileInfo
// is method
func (v FileInfo) GetSize() (result int64) {
	iv, err := _I.Get(707, "FileInfo", "get_size")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Int64()
	return
}

// g_file_info_get_sort_order
// container is not nil, container is FileInfo
// is method
func (v FileInfo) GetSortOrder() (result int32) {
	iv, err := _I.Get(708, "FileInfo", "get_sort_order")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Int32()
	return
}

// g_file_info_get_symbolic_icon
// container is not nil, container is FileInfo
// is method
func (v FileInfo) GetSymbolicIcon() (result Icon) {
	iv, err := _I.Get(709, "FileInfo", "get_symbolic_icon")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_file_info_get_symlink_target
// container is not nil, container is FileInfo
// is method
func (v FileInfo) GetSymlinkTarget() (result string) {
	iv, err := _I.Get(710, "FileInfo", "get_symlink_target")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Take()
	return
}

// g_file_info_has_attribute
// container is not nil, container is FileInfo
// is method
func (v FileInfo) HasAttribute(attribute string) (result bool) {
	iv, err := _I.Get(711, "FileInfo", "has_attribute")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_attribute := gi.CString(attribute)
	arg_v := gi.NewPointerArgument(v.P)
	arg_attribute := gi.NewStringArgument(c_attribute)
	args := []gi.Argument{arg_v, arg_attribute}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_attribute)
	result = ret.Bool()
	return
}

// g_file_info_has_namespace
// container is not nil, container is FileInfo
// is method
func (v FileInfo) HasNamespace(name_space string) (result bool) {
	iv, err := _I.Get(712, "FileInfo", "has_namespace")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_name_space := gi.CString(name_space)
	arg_v := gi.NewPointerArgument(v.P)
	arg_name_space := gi.NewStringArgument(c_name_space)
	args := []gi.Argument{arg_v, arg_name_space}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_name_space)
	result = ret.Bool()
	return
}

// g_file_info_list_attributes
// container is not nil, container is FileInfo
// is method
func (v FileInfo) ListAttributes(name_space string) (result gi.CStrArray) {
	iv, err := _I.Get(713, "FileInfo", "list_attributes")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_name_space := gi.CString(name_space)
	arg_v := gi.NewPointerArgument(v.P)
	arg_name_space := gi.NewStringArgument(c_name_space)
	args := []gi.Argument{arg_v, arg_name_space}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_name_space)
	result = gi.CStrArray{P: ret.Pointer(), Len: -1}
	result.SetLenZT()
	return
}

// g_file_info_remove_attribute
// container is not nil, container is FileInfo
// is method
func (v FileInfo) RemoveAttribute(attribute string) {
	iv, err := _I.Get(714, "FileInfo", "remove_attribute")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_attribute := gi.CString(attribute)
	arg_v := gi.NewPointerArgument(v.P)
	arg_attribute := gi.NewStringArgument(c_attribute)
	args := []gi.Argument{arg_v, arg_attribute}
	iv.Call(args, nil, nil)
	gi.Free(c_attribute)
}

// g_file_info_set_attribute
// container is not nil, container is FileInfo
// is method
func (v FileInfo) SetAttribute(attribute string, type1 FileAttributeTypeEnum, value_p unsafe.Pointer) {
	iv, err := _I.Get(715, "FileInfo", "set_attribute")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_attribute := gi.CString(attribute)
	arg_v := gi.NewPointerArgument(v.P)
	arg_attribute := gi.NewStringArgument(c_attribute)
	arg_type1 := gi.NewIntArgument(int(type1))
	arg_value_p := gi.NewPointerArgument(value_p)
	args := []gi.Argument{arg_v, arg_attribute, arg_type1, arg_value_p}
	iv.Call(args, nil, nil)
	gi.Free(c_attribute)
}

// g_file_info_set_attribute_boolean
// container is not nil, container is FileInfo
// is method
func (v FileInfo) SetAttributeBoolean(attribute string, attr_value bool) {
	iv, err := _I.Get(716, "FileInfo", "set_attribute_boolean")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_attribute := gi.CString(attribute)
	arg_v := gi.NewPointerArgument(v.P)
	arg_attribute := gi.NewStringArgument(c_attribute)
	arg_attr_value := gi.NewBoolArgument(attr_value)
	args := []gi.Argument{arg_v, arg_attribute, arg_attr_value}
	iv.Call(args, nil, nil)
	gi.Free(c_attribute)
}

// g_file_info_set_attribute_byte_string
// container is not nil, container is FileInfo
// is method
func (v FileInfo) SetAttributeByteString(attribute string, attr_value string) {
	iv, err := _I.Get(717, "FileInfo", "set_attribute_byte_string")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_attribute := gi.CString(attribute)
	c_attr_value := gi.CString(attr_value)
	arg_v := gi.NewPointerArgument(v.P)
	arg_attribute := gi.NewStringArgument(c_attribute)
	arg_attr_value := gi.NewStringArgument(c_attr_value)
	args := []gi.Argument{arg_v, arg_attribute, arg_attr_value}
	iv.Call(args, nil, nil)
	gi.Free(c_attribute)
	gi.Free(c_attr_value)
}

// g_file_info_set_attribute_int32
// container is not nil, container is FileInfo
// is method
func (v FileInfo) SetAttributeInt32(attribute string, attr_value int32) {
	iv, err := _I.Get(718, "FileInfo", "set_attribute_int32")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_attribute := gi.CString(attribute)
	arg_v := gi.NewPointerArgument(v.P)
	arg_attribute := gi.NewStringArgument(c_attribute)
	arg_attr_value := gi.NewInt32Argument(attr_value)
	args := []gi.Argument{arg_v, arg_attribute, arg_attr_value}
	iv.Call(args, nil, nil)
	gi.Free(c_attribute)
}

// g_file_info_set_attribute_int64
// container is not nil, container is FileInfo
// is method
func (v FileInfo) SetAttributeInt64(attribute string, attr_value int64) {
	iv, err := _I.Get(719, "FileInfo", "set_attribute_int64")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_attribute := gi.CString(attribute)
	arg_v := gi.NewPointerArgument(v.P)
	arg_attribute := gi.NewStringArgument(c_attribute)
	arg_attr_value := gi.NewInt64Argument(attr_value)
	args := []gi.Argument{arg_v, arg_attribute, arg_attr_value}
	iv.Call(args, nil, nil)
	gi.Free(c_attribute)
}

// g_file_info_set_attribute_mask
// container is not nil, container is FileInfo
// is method
func (v FileInfo) SetAttributeMask(mask FileAttributeMatcher) {
	iv, err := _I.Get(720, "FileInfo", "set_attribute_mask")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_mask := gi.NewPointerArgument(mask.P)
	args := []gi.Argument{arg_v, arg_mask}
	iv.Call(args, nil, nil)
}

// g_file_info_set_attribute_object
// container is not nil, container is FileInfo
// is method
func (v FileInfo) SetAttributeObject(attribute string, attr_value gobject.IObject) {
	iv, err := _I.Get(721, "FileInfo", "set_attribute_object")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_attribute := gi.CString(attribute)
	var tmp unsafe.Pointer
	if attr_value != nil {
		tmp = attr_value.P_Object()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_attribute := gi.NewStringArgument(c_attribute)
	arg_attr_value := gi.NewPointerArgument(tmp)
	args := []gi.Argument{arg_v, arg_attribute, arg_attr_value}
	iv.Call(args, nil, nil)
	gi.Free(c_attribute)
}

// g_file_info_set_attribute_status
// container is not nil, container is FileInfo
// is method
func (v FileInfo) SetAttributeStatus(attribute string, status FileAttributeStatusEnum) (result bool) {
	iv, err := _I.Get(722, "FileInfo", "set_attribute_status")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_attribute := gi.CString(attribute)
	arg_v := gi.NewPointerArgument(v.P)
	arg_attribute := gi.NewStringArgument(c_attribute)
	arg_status := gi.NewIntArgument(int(status))
	args := []gi.Argument{arg_v, arg_attribute, arg_status}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_attribute)
	result = ret.Bool()
	return
}

// g_file_info_set_attribute_string
// container is not nil, container is FileInfo
// is method
func (v FileInfo) SetAttributeString(attribute string, attr_value string) {
	iv, err := _I.Get(723, "FileInfo", "set_attribute_string")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_attribute := gi.CString(attribute)
	c_attr_value := gi.CString(attr_value)
	arg_v := gi.NewPointerArgument(v.P)
	arg_attribute := gi.NewStringArgument(c_attribute)
	arg_attr_value := gi.NewStringArgument(c_attr_value)
	args := []gi.Argument{arg_v, arg_attribute, arg_attr_value}
	iv.Call(args, nil, nil)
	gi.Free(c_attribute)
	gi.Free(c_attr_value)
}

// g_file_info_set_attribute_stringv
// container is not nil, container is FileInfo
// is method
func (v FileInfo) SetAttributeStringv(attribute string, attr_value gi.CStrArray) {
	iv, err := _I.Get(724, "FileInfo", "set_attribute_stringv")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_attribute := gi.CString(attribute)
	arg_v := gi.NewPointerArgument(v.P)
	arg_attribute := gi.NewStringArgument(c_attribute)
	arg_attr_value := gi.NewPointerArgument(attr_value.P)
	args := []gi.Argument{arg_v, arg_attribute, arg_attr_value}
	iv.Call(args, nil, nil)
	gi.Free(c_attribute)
}

// g_file_info_set_attribute_uint32
// container is not nil, container is FileInfo
// is method
func (v FileInfo) SetAttributeUint32(attribute string, attr_value uint32) {
	iv, err := _I.Get(725, "FileInfo", "set_attribute_uint32")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_attribute := gi.CString(attribute)
	arg_v := gi.NewPointerArgument(v.P)
	arg_attribute := gi.NewStringArgument(c_attribute)
	arg_attr_value := gi.NewUint32Argument(attr_value)
	args := []gi.Argument{arg_v, arg_attribute, arg_attr_value}
	iv.Call(args, nil, nil)
	gi.Free(c_attribute)
}

// g_file_info_set_attribute_uint64
// container is not nil, container is FileInfo
// is method
func (v FileInfo) SetAttributeUint64(attribute string, attr_value uint64) {
	iv, err := _I.Get(726, "FileInfo", "set_attribute_uint64")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_attribute := gi.CString(attribute)
	arg_v := gi.NewPointerArgument(v.P)
	arg_attribute := gi.NewStringArgument(c_attribute)
	arg_attr_value := gi.NewUint64Argument(attr_value)
	args := []gi.Argument{arg_v, arg_attribute, arg_attr_value}
	iv.Call(args, nil, nil)
	gi.Free(c_attribute)
}

// g_file_info_set_content_type
// container is not nil, container is FileInfo
// is method
func (v FileInfo) SetContentType(content_type string) {
	iv, err := _I.Get(727, "FileInfo", "set_content_type")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_content_type := gi.CString(content_type)
	arg_v := gi.NewPointerArgument(v.P)
	arg_content_type := gi.NewStringArgument(c_content_type)
	args := []gi.Argument{arg_v, arg_content_type}
	iv.Call(args, nil, nil)
	gi.Free(c_content_type)
}

// g_file_info_set_display_name
// container is not nil, container is FileInfo
// is method
func (v FileInfo) SetDisplayName(display_name string) {
	iv, err := _I.Get(728, "FileInfo", "set_display_name")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_display_name := gi.CString(display_name)
	arg_v := gi.NewPointerArgument(v.P)
	arg_display_name := gi.NewStringArgument(c_display_name)
	args := []gi.Argument{arg_v, arg_display_name}
	iv.Call(args, nil, nil)
	gi.Free(c_display_name)
}

// g_file_info_set_edit_name
// container is not nil, container is FileInfo
// is method
func (v FileInfo) SetEditName(edit_name string) {
	iv, err := _I.Get(729, "FileInfo", "set_edit_name")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_edit_name := gi.CString(edit_name)
	arg_v := gi.NewPointerArgument(v.P)
	arg_edit_name := gi.NewStringArgument(c_edit_name)
	args := []gi.Argument{arg_v, arg_edit_name}
	iv.Call(args, nil, nil)
	gi.Free(c_edit_name)
}

// g_file_info_set_file_type
// container is not nil, container is FileInfo
// is method
func (v FileInfo) SetFileType(type1 FileTypeEnum) {
	iv, err := _I.Get(730, "FileInfo", "set_file_type")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_type1 := gi.NewIntArgument(int(type1))
	args := []gi.Argument{arg_v, arg_type1}
	iv.Call(args, nil, nil)
}

// g_file_info_set_icon
// container is not nil, container is FileInfo
// is method
func (v FileInfo) SetIcon(icon IIcon) {
	iv, err := _I.Get(731, "FileInfo", "set_icon")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if icon != nil {
		tmp = icon.P_Icon()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_icon := gi.NewPointerArgument(tmp)
	args := []gi.Argument{arg_v, arg_icon}
	iv.Call(args, nil, nil)
}

// g_file_info_set_is_hidden
// container is not nil, container is FileInfo
// is method
func (v FileInfo) SetIsHidden(is_hidden bool) {
	iv, err := _I.Get(732, "FileInfo", "set_is_hidden")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_is_hidden := gi.NewBoolArgument(is_hidden)
	args := []gi.Argument{arg_v, arg_is_hidden}
	iv.Call(args, nil, nil)
}

// g_file_info_set_is_symlink
// container is not nil, container is FileInfo
// is method
func (v FileInfo) SetIsSymlink(is_symlink bool) {
	iv, err := _I.Get(733, "FileInfo", "set_is_symlink")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_is_symlink := gi.NewBoolArgument(is_symlink)
	args := []gi.Argument{arg_v, arg_is_symlink}
	iv.Call(args, nil, nil)
}

// g_file_info_set_modification_time
// container is not nil, container is FileInfo
// is method
func (v FileInfo) SetModificationTime(mtime glib.TimeVal) {
	iv, err := _I.Get(734, "FileInfo", "set_modification_time")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_mtime := gi.NewPointerArgument(mtime.P)
	args := []gi.Argument{arg_v, arg_mtime}
	iv.Call(args, nil, nil)
}

// g_file_info_set_name
// container is not nil, container is FileInfo
// is method
func (v FileInfo) SetName(name string) {
	iv, err := _I.Get(735, "FileInfo", "set_name")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_name := gi.CString(name)
	arg_v := gi.NewPointerArgument(v.P)
	arg_name := gi.NewStringArgument(c_name)
	args := []gi.Argument{arg_v, arg_name}
	iv.Call(args, nil, nil)
	gi.Free(c_name)
}

// g_file_info_set_size
// container is not nil, container is FileInfo
// is method
func (v FileInfo) SetSize(size int64) {
	iv, err := _I.Get(736, "FileInfo", "set_size")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_size := gi.NewInt64Argument(size)
	args := []gi.Argument{arg_v, arg_size}
	iv.Call(args, nil, nil)
}

// g_file_info_set_sort_order
// container is not nil, container is FileInfo
// is method
func (v FileInfo) SetSortOrder(sort_order int32) {
	iv, err := _I.Get(737, "FileInfo", "set_sort_order")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_sort_order := gi.NewInt32Argument(sort_order)
	args := []gi.Argument{arg_v, arg_sort_order}
	iv.Call(args, nil, nil)
}

// g_file_info_set_symbolic_icon
// container is not nil, container is FileInfo
// is method
func (v FileInfo) SetSymbolicIcon(icon IIcon) {
	iv, err := _I.Get(738, "FileInfo", "set_symbolic_icon")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if icon != nil {
		tmp = icon.P_Icon()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_icon := gi.NewPointerArgument(tmp)
	args := []gi.Argument{arg_v, arg_icon}
	iv.Call(args, nil, nil)
}

// g_file_info_set_symlink_target
// container is not nil, container is FileInfo
// is method
func (v FileInfo) SetSymlinkTarget(symlink_target string) {
	iv, err := _I.Get(739, "FileInfo", "set_symlink_target")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_symlink_target := gi.CString(symlink_target)
	arg_v := gi.NewPointerArgument(v.P)
	arg_symlink_target := gi.NewStringArgument(c_symlink_target)
	args := []gi.Argument{arg_v, arg_symlink_target}
	iv.Call(args, nil, nil)
	gi.Free(c_symlink_target)
}

// g_file_info_unset_attribute_mask
// container is not nil, container is FileInfo
// is method
func (v FileInfo) UnsetAttributeMask() {
	iv, err := _I.Get(740, "FileInfo", "unset_attribute_mask")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	iv.Call(args, nil, nil)
}

// ignore GType struct FileInfoClass
// Object FileInputStream
type FileInputStream struct {
	SeekableIfc
	InputStream
}

func WrapFileInputStream(p unsafe.Pointer) (r FileInputStream) { r.P = p; return }

type IFileInputStream interface{ P_FileInputStream() unsafe.Pointer }

func (v FileInputStream) P_FileInputStream() unsafe.Pointer { return v.P }
func (v FileInputStream) P_Seekable() unsafe.Pointer        { return v.P }
func FileInputStreamGetType() gi.GType {
	ret := _I.GetGType(120, "FileInputStream")
	return ret
}

// g_file_input_stream_query_info
// container is not nil, container is FileInputStream
// is method
func (v FileInputStream) QueryInfo(attributes string, cancellable ICancellable) (result FileInfo, err error) {
	iv, err := _I.Get(741, "FileInputStream", "query_info")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	c_attributes := gi.CString(attributes)
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_attributes := gi.NewStringArgument(c_attributes)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_attributes, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	gi.Free(c_attributes)
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// g_file_input_stream_query_info_async
// container is not nil, container is FileInputStream
// is method
func (v FileInputStream) QueryInfoAsync(attributes string, io_priority int32, cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(742, "FileInputStream", "query_info_async")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_attributes := gi.CString(attributes)
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_attributes := gi.NewStringArgument(c_attributes)
	arg_io_priority := gi.NewInt32Argument(io_priority)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_v, arg_attributes, arg_io_priority, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
	gi.Free(c_attributes)
}

// g_file_input_stream_query_info_finish
// container is not nil, container is FileInputStream
// is method
func (v FileInputStream) QueryInfoFinish(result IAsyncResult) (result1 FileInfo, err error) {
	iv, err := _I.Get(743, "FileInputStream", "query_info_finish")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if result != nil {
		tmp = result.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_result := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_result, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result1.P = ret.Pointer()
	return
}

// ignore GType struct FileInputStreamClass
// Struct FileInputStreamPrivate
type FileInputStreamPrivate struct {
	P unsafe.Pointer
}

func FileInputStreamPrivateGetType() gi.GType {
	ret := _I.GetGType(121, "FileInputStreamPrivate")
	return ret
}

// Flags FileMeasureFlags
type FileMeasureFlags int

const (
	FileMeasureFlagsNone           FileMeasureFlags = 0
	FileMeasureFlagsReportAnyError FileMeasureFlags = 2
	FileMeasureFlagsApparentSize   FileMeasureFlags = 4
	FileMeasureFlagsNoXdev         FileMeasureFlags = 8
)

func FileMeasureFlagsGetType() gi.GType {
	ret := _I.GetGType(122, "FileMeasureFlags")
	return ret
}

type FileMeasureProgressCallbackStruct struct {
	F_reporting    bool
	F_current_size uint64
	F_num_dirs     uint64
	F_num_files    uint64
}

//export myFileMeasureProgressCallback
func myFileMeasureProgressCallback(reporting C.gboolean, current_size C.guint64, num_dirs C.guint64, num_files C.guint64, user_data C.gpointer) {
	fn := gi.GetFunc(uint(uintptr(user_data)))
	args := FileMeasureProgressCallbackStruct{
		F_reporting:    gi.Int2Bool(int(reporting)),
		F_current_size: uint64(current_size),
		F_num_dirs:     uint64(num_dirs),
		F_num_files:    uint64(num_files),
	}
	fn(args)
}

// Object FileMonitor
type FileMonitor struct {
	gobject.Object
}

func WrapFileMonitor(p unsafe.Pointer) (r FileMonitor) { r.P = p; return }

type IFileMonitor interface{ P_FileMonitor() unsafe.Pointer }

func (v FileMonitor) P_FileMonitor() unsafe.Pointer { return v.P }
func FileMonitorGetType() gi.GType {
	ret := _I.GetGType(123, "FileMonitor")
	return ret
}

// g_file_monitor_cancel
// container is not nil, container is FileMonitor
// is method
func (v FileMonitor) Cancel() (result bool) {
	iv, err := _I.Get(744, "FileMonitor", "cancel")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_file_monitor_emit_event
// container is not nil, container is FileMonitor
// is method
func (v FileMonitor) EmitEvent(child IFile, other_file IFile, event_type FileMonitorEventEnum) {
	iv, err := _I.Get(745, "FileMonitor", "emit_event")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if child != nil {
		tmp = child.P_File()
	}
	var tmp1 unsafe.Pointer
	if other_file != nil {
		tmp1 = other_file.P_File()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_child := gi.NewPointerArgument(tmp)
	arg_other_file := gi.NewPointerArgument(tmp1)
	arg_event_type := gi.NewIntArgument(int(event_type))
	args := []gi.Argument{arg_v, arg_child, arg_other_file, arg_event_type}
	iv.Call(args, nil, nil)
}

// g_file_monitor_is_cancelled
// container is not nil, container is FileMonitor
// is method
func (v FileMonitor) IsCancelled() (result bool) {
	iv, err := _I.Get(746, "FileMonitor", "is_cancelled")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_file_monitor_set_rate_limit
// container is not nil, container is FileMonitor
// is method
func (v FileMonitor) SetRateLimit(limit_msecs int32) {
	iv, err := _I.Get(747, "FileMonitor", "set_rate_limit")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_limit_msecs := gi.NewInt32Argument(limit_msecs)
	args := []gi.Argument{arg_v, arg_limit_msecs}
	iv.Call(args, nil, nil)
}

// ignore GType struct FileMonitorClass
// Enum FileMonitorEvent
type FileMonitorEventEnum int

const (
	FileMonitorEventChanged          FileMonitorEventEnum = 0
	FileMonitorEventChangesDoneHint  FileMonitorEventEnum = 1
	FileMonitorEventDeleted          FileMonitorEventEnum = 2
	FileMonitorEventCreated          FileMonitorEventEnum = 3
	FileMonitorEventAttributeChanged FileMonitorEventEnum = 4
	FileMonitorEventPreUnmount       FileMonitorEventEnum = 5
	FileMonitorEventUnmounted        FileMonitorEventEnum = 6
	FileMonitorEventMoved            FileMonitorEventEnum = 7
	FileMonitorEventRenamed          FileMonitorEventEnum = 8
	FileMonitorEventMovedIn          FileMonitorEventEnum = 9
	FileMonitorEventMovedOut         FileMonitorEventEnum = 10
)

func FileMonitorEventGetType() gi.GType {
	ret := _I.GetGType(124, "FileMonitorEvent")
	return ret
}

// Flags FileMonitorFlags
type FileMonitorFlags int

const (
	FileMonitorFlagsNone           FileMonitorFlags = 0
	FileMonitorFlagsWatchMounts    FileMonitorFlags = 1
	FileMonitorFlagsSendMoved      FileMonitorFlags = 2
	FileMonitorFlagsWatchHardLinks FileMonitorFlags = 4
	FileMonitorFlagsWatchMoves     FileMonitorFlags = 8
)

func FileMonitorFlagsGetType() gi.GType {
	ret := _I.GetGType(125, "FileMonitorFlags")
	return ret
}

// Struct FileMonitorPrivate
type FileMonitorPrivate struct {
	P unsafe.Pointer
}

func FileMonitorPrivateGetType() gi.GType {
	ret := _I.GetGType(126, "FileMonitorPrivate")
	return ret
}

// Object FileOutputStream
type FileOutputStream struct {
	SeekableIfc
	OutputStream
}

func WrapFileOutputStream(p unsafe.Pointer) (r FileOutputStream) { r.P = p; return }

type IFileOutputStream interface{ P_FileOutputStream() unsafe.Pointer }

func (v FileOutputStream) P_FileOutputStream() unsafe.Pointer { return v.P }
func (v FileOutputStream) P_Seekable() unsafe.Pointer         { return v.P }
func FileOutputStreamGetType() gi.GType {
	ret := _I.GetGType(127, "FileOutputStream")
	return ret
}

// g_file_output_stream_get_etag
// container is not nil, container is FileOutputStream
// is method
func (v FileOutputStream) GetEtag() (result string) {
	iv, err := _I.Get(748, "FileOutputStream", "get_etag")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Take()
	return
}

// g_file_output_stream_query_info
// container is not nil, container is FileOutputStream
// is method
func (v FileOutputStream) QueryInfo(attributes string, cancellable ICancellable) (result FileInfo, err error) {
	iv, err := _I.Get(749, "FileOutputStream", "query_info")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	c_attributes := gi.CString(attributes)
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_attributes := gi.NewStringArgument(c_attributes)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_attributes, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	gi.Free(c_attributes)
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// g_file_output_stream_query_info_async
// container is not nil, container is FileOutputStream
// is method
func (v FileOutputStream) QueryInfoAsync(attributes string, io_priority int32, cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(750, "FileOutputStream", "query_info_async")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_attributes := gi.CString(attributes)
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_attributes := gi.NewStringArgument(c_attributes)
	arg_io_priority := gi.NewInt32Argument(io_priority)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_v, arg_attributes, arg_io_priority, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
	gi.Free(c_attributes)
}

// g_file_output_stream_query_info_finish
// container is not nil, container is FileOutputStream
// is method
func (v FileOutputStream) QueryInfoFinish(result IAsyncResult) (result1 FileInfo, err error) {
	iv, err := _I.Get(751, "FileOutputStream", "query_info_finish")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if result != nil {
		tmp = result.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_result := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_result, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result1.P = ret.Pointer()
	return
}

// ignore GType struct FileOutputStreamClass
// Struct FileOutputStreamPrivate
type FileOutputStreamPrivate struct {
	P unsafe.Pointer
}

func FileOutputStreamPrivateGetType() gi.GType {
	ret := _I.GetGType(128, "FileOutputStreamPrivate")
	return ret
}

type FileProgressCallbackStruct struct {
	F_current_num_bytes int64
	F_total_num_bytes   int64
}

//export myFileProgressCallback
func myFileProgressCallback(current_num_bytes C.gint64, total_num_bytes C.gint64, user_data C.gpointer) {
	fn := gi.GetFunc(uint(uintptr(user_data)))
	args := FileProgressCallbackStruct{
		F_current_num_bytes: int64(current_num_bytes),
		F_total_num_bytes:   int64(total_num_bytes),
	}
	fn(args)
}

// Flags FileQueryInfoFlags
type FileQueryInfoFlags int

const (
	FileQueryInfoFlagsNone             FileQueryInfoFlags = 0
	FileQueryInfoFlagsNofollowSymlinks FileQueryInfoFlags = 1
)

func FileQueryInfoFlagsGetType() gi.GType {
	ret := _I.GetGType(129, "FileQueryInfoFlags")
	return ret
}

// ignore callback FileReadMoreCallback
// Enum FileType
type FileTypeEnum int

const (
	FileTypeUnknown      FileTypeEnum = 0
	FileTypeRegular      FileTypeEnum = 1
	FileTypeDirectory    FileTypeEnum = 2
	FileTypeSymbolicLink FileTypeEnum = 3
	FileTypeSpecial      FileTypeEnum = 4
	FileTypeShortcut     FileTypeEnum = 5
	FileTypeMountable    FileTypeEnum = 6
)

func FileTypeGetType() gi.GType {
	ret := _I.GetGType(130, "FileType")
	return ret
}

// Object FilenameCompleter
type FilenameCompleter struct {
	gobject.Object
}

func WrapFilenameCompleter(p unsafe.Pointer) (r FilenameCompleter) { r.P = p; return }

type IFilenameCompleter interface{ P_FilenameCompleter() unsafe.Pointer }

func (v FilenameCompleter) P_FilenameCompleter() unsafe.Pointer { return v.P }
func FilenameCompleterGetType() gi.GType {
	ret := _I.GetGType(131, "FilenameCompleter")
	return ret
}

// g_filename_completer_new
// container is not nil, container is FilenameCompleter
// is constructor
func NewFilenameCompleter() (result FilenameCompleter) {
	iv, err := _I.Get(752, "FilenameCompleter", "new")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var ret gi.Argument
	iv.Call(nil, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_filename_completer_get_completion_suffix
// container is not nil, container is FilenameCompleter
// is method
func (v FilenameCompleter) GetCompletionSuffix(initial_text string) (result string) {
	iv, err := _I.Get(753, "FilenameCompleter", "get_completion_suffix")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_initial_text := gi.CString(initial_text)
	arg_v := gi.NewPointerArgument(v.P)
	arg_initial_text := gi.NewStringArgument(c_initial_text)
	args := []gi.Argument{arg_v, arg_initial_text}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_initial_text)
	result = ret.String().Take()
	return
}

// g_filename_completer_get_completions
// container is not nil, container is FilenameCompleter
// is method
func (v FilenameCompleter) GetCompletions(initial_text string) (result gi.CStrArray) {
	iv, err := _I.Get(754, "FilenameCompleter", "get_completions")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_initial_text := gi.CString(initial_text)
	arg_v := gi.NewPointerArgument(v.P)
	arg_initial_text := gi.NewStringArgument(c_initial_text)
	args := []gi.Argument{arg_v, arg_initial_text}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_initial_text)
	result = gi.CStrArray{P: ret.Pointer(), Len: -1}
	result.SetLenZT()
	return
}

// g_filename_completer_set_dirs_only
// container is not nil, container is FilenameCompleter
// is method
func (v FilenameCompleter) SetDirsOnly(dirs_only bool) {
	iv, err := _I.Get(755, "FilenameCompleter", "set_dirs_only")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_dirs_only := gi.NewBoolArgument(dirs_only)
	args := []gi.Argument{arg_v, arg_dirs_only}
	iv.Call(args, nil, nil)
}

// ignore GType struct FilenameCompleterClass
// Enum FilesystemPreviewType
type FilesystemPreviewTypeEnum int

const (
	FilesystemPreviewTypeIfAlways FilesystemPreviewTypeEnum = 0
	FilesystemPreviewTypeIfLocal  FilesystemPreviewTypeEnum = 1
	FilesystemPreviewTypeNever    FilesystemPreviewTypeEnum = 2
)

func FilesystemPreviewTypeGetType() gi.GType {
	ret := _I.GetGType(132, "FilesystemPreviewType")
	return ret
}

// Object FilterInputStream
type FilterInputStream struct {
	InputStream
}

func WrapFilterInputStream(p unsafe.Pointer) (r FilterInputStream) { r.P = p; return }

type IFilterInputStream interface{ P_FilterInputStream() unsafe.Pointer }

func (v FilterInputStream) P_FilterInputStream() unsafe.Pointer { return v.P }
func FilterInputStreamGetType() gi.GType {
	ret := _I.GetGType(133, "FilterInputStream")
	return ret
}

// g_filter_input_stream_get_base_stream
// container is not nil, container is FilterInputStream
// is method
func (v FilterInputStream) GetBaseStream() (result InputStream) {
	iv, err := _I.Get(756, "FilterInputStream", "get_base_stream")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_filter_input_stream_get_close_base_stream
// container is not nil, container is FilterInputStream
// is method
func (v FilterInputStream) GetCloseBaseStream() (result bool) {
	iv, err := _I.Get(757, "FilterInputStream", "get_close_base_stream")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_filter_input_stream_set_close_base_stream
// container is not nil, container is FilterInputStream
// is method
func (v FilterInputStream) SetCloseBaseStream(close_base bool) {
	iv, err := _I.Get(758, "FilterInputStream", "set_close_base_stream")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_close_base := gi.NewBoolArgument(close_base)
	args := []gi.Argument{arg_v, arg_close_base}
	iv.Call(args, nil, nil)
}

// ignore GType struct FilterInputStreamClass
// Object FilterOutputStream
type FilterOutputStream struct {
	OutputStream
}

func WrapFilterOutputStream(p unsafe.Pointer) (r FilterOutputStream) { r.P = p; return }

type IFilterOutputStream interface{ P_FilterOutputStream() unsafe.Pointer }

func (v FilterOutputStream) P_FilterOutputStream() unsafe.Pointer { return v.P }
func FilterOutputStreamGetType() gi.GType {
	ret := _I.GetGType(134, "FilterOutputStream")
	return ret
}

// g_filter_output_stream_get_base_stream
// container is not nil, container is FilterOutputStream
// is method
func (v FilterOutputStream) GetBaseStream() (result OutputStream) {
	iv, err := _I.Get(759, "FilterOutputStream", "get_base_stream")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_filter_output_stream_get_close_base_stream
// container is not nil, container is FilterOutputStream
// is method
func (v FilterOutputStream) GetCloseBaseStream() (result bool) {
	iv, err := _I.Get(760, "FilterOutputStream", "get_close_base_stream")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_filter_output_stream_set_close_base_stream
// container is not nil, container is FilterOutputStream
// is method
func (v FilterOutputStream) SetCloseBaseStream(close_base bool) {
	iv, err := _I.Get(761, "FilterOutputStream", "set_close_base_stream")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_close_base := gi.NewBoolArgument(close_base)
	args := []gi.Argument{arg_v, arg_close_base}
	iv.Call(args, nil, nil)
}

// ignore GType struct FilterOutputStreamClass
// Enum IOErrorEnum
type IOErrorEnumEnum int

const (
	IOErrorEnumFailed             IOErrorEnumEnum = 0
	IOErrorEnumNotFound           IOErrorEnumEnum = 1
	IOErrorEnumExists             IOErrorEnumEnum = 2
	IOErrorEnumIsDirectory        IOErrorEnumEnum = 3
	IOErrorEnumNotDirectory       IOErrorEnumEnum = 4
	IOErrorEnumNotEmpty           IOErrorEnumEnum = 5
	IOErrorEnumNotRegularFile     IOErrorEnumEnum = 6
	IOErrorEnumNotSymbolicLink    IOErrorEnumEnum = 7
	IOErrorEnumNotMountableFile   IOErrorEnumEnum = 8
	IOErrorEnumFilenameTooLong    IOErrorEnumEnum = 9
	IOErrorEnumInvalidFilename    IOErrorEnumEnum = 10
	IOErrorEnumTooManyLinks       IOErrorEnumEnum = 11
	IOErrorEnumNoSpace            IOErrorEnumEnum = 12
	IOErrorEnumInvalidArgument    IOErrorEnumEnum = 13
	IOErrorEnumPermissionDenied   IOErrorEnumEnum = 14
	IOErrorEnumNotSupported       IOErrorEnumEnum = 15
	IOErrorEnumNotMounted         IOErrorEnumEnum = 16
	IOErrorEnumAlreadyMounted     IOErrorEnumEnum = 17
	IOErrorEnumClosed             IOErrorEnumEnum = 18
	IOErrorEnumCancelled          IOErrorEnumEnum = 19
	IOErrorEnumPending            IOErrorEnumEnum = 20
	IOErrorEnumReadOnly           IOErrorEnumEnum = 21
	IOErrorEnumCantCreateBackup   IOErrorEnumEnum = 22
	IOErrorEnumWrongEtag          IOErrorEnumEnum = 23
	IOErrorEnumTimedOut           IOErrorEnumEnum = 24
	IOErrorEnumWouldRecurse       IOErrorEnumEnum = 25
	IOErrorEnumBusy               IOErrorEnumEnum = 26
	IOErrorEnumWouldBlock         IOErrorEnumEnum = 27
	IOErrorEnumHostNotFound       IOErrorEnumEnum = 28
	IOErrorEnumWouldMerge         IOErrorEnumEnum = 29
	IOErrorEnumFailedHandled      IOErrorEnumEnum = 30
	IOErrorEnumTooManyOpenFiles   IOErrorEnumEnum = 31
	IOErrorEnumNotInitialized     IOErrorEnumEnum = 32
	IOErrorEnumAddressInUse       IOErrorEnumEnum = 33
	IOErrorEnumPartialInput       IOErrorEnumEnum = 34
	IOErrorEnumInvalidData        IOErrorEnumEnum = 35
	IOErrorEnumDbusError          IOErrorEnumEnum = 36
	IOErrorEnumHostUnreachable    IOErrorEnumEnum = 37
	IOErrorEnumNetworkUnreachable IOErrorEnumEnum = 38
	IOErrorEnumConnectionRefused  IOErrorEnumEnum = 39
	IOErrorEnumProxyFailed        IOErrorEnumEnum = 40
	IOErrorEnumProxyAuthFailed    IOErrorEnumEnum = 41
	IOErrorEnumProxyNeedAuth      IOErrorEnumEnum = 42
	IOErrorEnumProxyNotAllowed    IOErrorEnumEnum = 43
	IOErrorEnumBrokenPipe         IOErrorEnumEnum = 44
	IOErrorEnumConnectionClosed   IOErrorEnumEnum = 44
	IOErrorEnumNotConnected       IOErrorEnumEnum = 45
	IOErrorEnumMessageTooLarge    IOErrorEnumEnum = 46
)

func IOErrorEnumGetType() gi.GType {
	ret := _I.GetGType(135, "IOErrorEnum")
	return ret
}

// Struct IOExtension
type IOExtension struct {
	P unsafe.Pointer
}

func IOExtensionGetType() gi.GType {
	ret := _I.GetGType(136, "IOExtension")
	return ret
}

// g_io_extension_get_name
// container is not nil, container is IOExtension
// is method
func (v IOExtension) GetName() (result string) {
	iv, err := _I.Get(762, "IOExtension", "get_name")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Take()
	return
}

// g_io_extension_get_priority
// container is not nil, container is IOExtension
// is method
func (v IOExtension) GetPriority() (result int32) {
	iv, err := _I.Get(763, "IOExtension", "get_priority")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Int32()
	return
}

// g_io_extension_get_type
// container is not nil, container is IOExtension
// is method
func (v IOExtension) GetType() (result gi.GType) {
	iv, err := _I.Get(764, "IOExtension", "get_type")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = gi.GType(ret.Uint())
	return
}

// Struct IOExtensionPoint
type IOExtensionPoint struct {
	P unsafe.Pointer
}

func IOExtensionPointGetType() gi.GType {
	ret := _I.GetGType(137, "IOExtensionPoint")
	return ret
}

// g_io_extension_point_get_extension_by_name
// container is not nil, container is IOExtensionPoint
// is method
func (v IOExtensionPoint) GetExtensionByName(name string) (result IOExtension) {
	iv, err := _I.Get(765, "IOExtensionPoint", "get_extension_by_name")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_name := gi.CString(name)
	arg_v := gi.NewPointerArgument(v.P)
	arg_name := gi.NewStringArgument(c_name)
	args := []gi.Argument{arg_v, arg_name}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_name)
	result.P = ret.Pointer()
	return
}

// g_io_extension_point_get_extensions
// container is not nil, container is IOExtensionPoint
// is method
func (v IOExtensionPoint) GetExtensions() (result glib.List) {
	iv, err := _I.Get(766, "IOExtensionPoint", "get_extensions")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_io_extension_point_get_required_type
// container is not nil, container is IOExtensionPoint
// is method
func (v IOExtensionPoint) GetRequiredType() (result gi.GType) {
	iv, err := _I.Get(767, "IOExtensionPoint", "get_required_type")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = gi.GType(ret.Uint())
	return
}

// g_io_extension_point_set_required_type
// container is not nil, container is IOExtensionPoint
// is method
func (v IOExtensionPoint) SetRequiredType(type1 gi.GType) {
	iv, err := _I.Get(768, "IOExtensionPoint", "set_required_type")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_type1 := gi.NewUintArgument(uint(type1))
	args := []gi.Argument{arg_v, arg_type1}
	iv.Call(args, nil, nil)
}

// g_io_extension_point_implement
// container is not nil, container is IOExtensionPoint
// is method
// arg0Type tag: utf8, isPtr: true
func IOExtensionPointImplement1(extension_point_name string, type1 gi.GType, extension_name string, priority int32) (result IOExtension) {
	iv, err := _I.Get(769, "IOExtensionPoint", "implement")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_extension_point_name := gi.CString(extension_point_name)
	c_extension_name := gi.CString(extension_name)
	arg_extension_point_name := gi.NewStringArgument(c_extension_point_name)
	arg_type1 := gi.NewUintArgument(uint(type1))
	arg_extension_name := gi.NewStringArgument(c_extension_name)
	arg_priority := gi.NewInt32Argument(priority)
	args := []gi.Argument{arg_extension_point_name, arg_type1, arg_extension_name, arg_priority}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_extension_point_name)
	gi.Free(c_extension_name)
	result.P = ret.Pointer()
	return
}

// g_io_extension_point_lookup
// container is not nil, container is IOExtensionPoint
// is method
// arg0Type tag: utf8, isPtr: true
func IOExtensionPointLookup1(name string) (result IOExtensionPoint) {
	iv, err := _I.Get(770, "IOExtensionPoint", "lookup")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_name := gi.CString(name)
	arg_name := gi.NewStringArgument(c_name)
	args := []gi.Argument{arg_name}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_name)
	result.P = ret.Pointer()
	return
}

// g_io_extension_point_register
// container is not nil, container is IOExtensionPoint
// is method
// arg0Type tag: utf8, isPtr: true
func IOExtensionPointRegister1(name string) (result IOExtensionPoint) {
	iv, err := _I.Get(771, "IOExtensionPoint", "register")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_name := gi.CString(name)
	arg_name := gi.NewStringArgument(c_name)
	args := []gi.Argument{arg_name}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_name)
	result.P = ret.Pointer()
	return
}

// Object IOModule
type IOModule struct {
	gobject.TypePluginIfc
	gobject.TypeModule
}

func WrapIOModule(p unsafe.Pointer) (r IOModule) { r.P = p; return }

type IIOModule interface{ P_IOModule() unsafe.Pointer }

func (v IOModule) P_IOModule() unsafe.Pointer   { return v.P }
func (v IOModule) P_TypePlugin() unsafe.Pointer { return v.P }
func IOModuleGetType() gi.GType {
	ret := _I.GetGType(138, "IOModule")
	return ret
}

// g_io_module_new
// container is not nil, container is IOModule
// is constructor
func NewIOModule(filename string) (result IOModule) {
	iv, err := _I.Get(772, "IOModule", "new")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_filename := gi.CString(filename)
	arg_filename := gi.NewStringArgument(c_filename)
	args := []gi.Argument{arg_filename}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_filename)
	result.P = ret.Pointer()
	return
}

// g_io_module_load
// container is not nil, container is IOModule
// is method
func (v IOModule) Load() {
	iv, err := _I.Get(774, "IOModule", "load")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	iv.Call(args, nil, nil)
}

// g_io_module_unload
// container is not nil, container is IOModule
// is method
func (v IOModule) Unload() {
	iv, err := _I.Get(775, "IOModule", "unload")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	iv.Call(args, nil, nil)
}

// ignore GType struct IOModuleClass
// Struct IOModuleScope
type IOModuleScope struct {
	P unsafe.Pointer
}

func IOModuleScopeGetType() gi.GType {
	ret := _I.GetGType(139, "IOModuleScope")
	return ret
}

// g_io_module_scope_block
// container is not nil, container is IOModuleScope
// is method
func (v IOModuleScope) Block(basename string) {
	iv, err := _I.Get(776, "IOModuleScope", "block")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_basename := gi.CString(basename)
	arg_v := gi.NewPointerArgument(v.P)
	arg_basename := gi.NewStringArgument(c_basename)
	args := []gi.Argument{arg_v, arg_basename}
	iv.Call(args, nil, nil)
	gi.Free(c_basename)
}

// g_io_module_scope_free
// container is not nil, container is IOModuleScope
// is method
func (v IOModuleScope) Free() {
	iv, err := _I.Get(777, "IOModuleScope", "free")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	iv.Call(args, nil, nil)
}

// Enum IOModuleScopeFlags
type IOModuleScopeFlagsEnum int

const (
	IOModuleScopeFlagsNone            IOModuleScopeFlagsEnum = 0
	IOModuleScopeFlagsBlockDuplicates IOModuleScopeFlagsEnum = 1
)

func IOModuleScopeFlagsGetType() gi.GType {
	ret := _I.GetGType(140, "IOModuleScopeFlags")
	return ret
}

// Struct IOSchedulerJob
type IOSchedulerJob struct {
	P unsafe.Pointer
}

func IOSchedulerJobGetType() gi.GType {
	ret := _I.GetGType(141, "IOSchedulerJob")
	return ret
}

// g_io_scheduler_job_send_to_mainloop
// container is not nil, container is IOSchedulerJob
// is method
func (v IOSchedulerJob) SendToMainloop(func1 int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer, notify int /*TODO_TYPE isPtr: false, tag: interface*/) (result bool) {
	iv, err := _I.Get(778, "IOSchedulerJob", "send_to_mainloop")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_func1 := gi.NewIntArgument(func1) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	arg_notify := gi.NewIntArgument(notify) /*TODO*/
	args := []gi.Argument{arg_v, arg_func1, arg_user_data, arg_notify}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_io_scheduler_job_send_to_mainloop_async
// container is not nil, container is IOSchedulerJob
// is method
func (v IOSchedulerJob) SendToMainloopAsync(func1 int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer, notify int /*TODO_TYPE isPtr: false, tag: interface*/) {
	iv, err := _I.Get(779, "IOSchedulerJob", "send_to_mainloop_async")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_func1 := gi.NewIntArgument(func1) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	arg_notify := gi.NewIntArgument(notify) /*TODO*/
	args := []gi.Argument{arg_v, arg_func1, arg_user_data, arg_notify}
	iv.Call(args, nil, nil)
}

type IOSchedulerJobFuncStruct struct {
	F_job         IOSchedulerJob
	F_cancellable Cancellable
}

//export myIOSchedulerJobFunc
func myIOSchedulerJobFunc(job *C.GIOSchedulerJob, cancellable *C.GCancellable, user_data C.gpointer) {
	fn := gi.GetFunc(uint(uintptr(user_data)))
	args := IOSchedulerJobFuncStruct{
		F_job:         IOSchedulerJob{P: unsafe.Pointer(job)},
		F_cancellable: WrapCancellable(unsafe.Pointer(cancellable)),
	}
	fn(args)
}

// Object IOStream
type IOStream struct {
	gobject.Object
}

func WrapIOStream(p unsafe.Pointer) (r IOStream) { r.P = p; return }

type IIOStream interface{ P_IOStream() unsafe.Pointer }

func (v IOStream) P_IOStream() unsafe.Pointer { return v.P }
func IOStreamGetType() gi.GType {
	ret := _I.GetGType(142, "IOStream")
	return ret
}

// g_io_stream_splice_finish
// container is not nil, container is IOStream
// is method
// arg0Type tag: interface, isPtr: true
func IOStreamSpliceFinish1(result IAsyncResult) (result1 bool, err error) {
	iv, err := _I.Get(780, "IOStream", "splice_finish")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if result != nil {
		tmp = result.P_AsyncResult()
	}
	arg_result := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_result, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result1 = ret.Bool()
	return
}

// g_io_stream_clear_pending
// container is not nil, container is IOStream
// is method
func (v IOStream) ClearPending() {
	iv, err := _I.Get(781, "IOStream", "clear_pending")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	iv.Call(args, nil, nil)
}

// g_io_stream_close
// container is not nil, container is IOStream
// is method
func (v IOStream) Close(cancellable ICancellable) (result bool, err error) {
	iv, err := _I.Get(782, "IOStream", "close")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Bool()
	return
}

// g_io_stream_close_async
// container is not nil, container is IOStream
// is method
func (v IOStream) CloseAsync(io_priority int32, cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(783, "IOStream", "close_async")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_io_priority := gi.NewInt32Argument(io_priority)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_v, arg_io_priority, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
}

// g_io_stream_close_finish
// container is not nil, container is IOStream
// is method
func (v IOStream) CloseFinish(result IAsyncResult) (result1 bool, err error) {
	iv, err := _I.Get(784, "IOStream", "close_finish")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if result != nil {
		tmp = result.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_result := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_result, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result1 = ret.Bool()
	return
}

// g_io_stream_get_input_stream
// container is not nil, container is IOStream
// is method
func (v IOStream) GetInputStream() (result InputStream) {
	iv, err := _I.Get(785, "IOStream", "get_input_stream")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_io_stream_get_output_stream
// container is not nil, container is IOStream
// is method
func (v IOStream) GetOutputStream() (result OutputStream) {
	iv, err := _I.Get(786, "IOStream", "get_output_stream")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_io_stream_has_pending
// container is not nil, container is IOStream
// is method
func (v IOStream) HasPending() (result bool) {
	iv, err := _I.Get(787, "IOStream", "has_pending")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_io_stream_is_closed
// container is not nil, container is IOStream
// is method
func (v IOStream) IsClosed() (result bool) {
	iv, err := _I.Get(788, "IOStream", "is_closed")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_io_stream_set_pending
// container is not nil, container is IOStream
// is method
func (v IOStream) SetPending() (result bool, err error) {
	iv, err := _I.Get(789, "IOStream", "set_pending")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	arg_v := gi.NewPointerArgument(v.P)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Bool()
	return
}

// g_io_stream_splice_async
// container is not nil, container is IOStream
// is method
func (v IOStream) SpliceAsync(stream2 IIOStream, flags IOStreamSpliceFlags, io_priority int32, cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(790, "IOStream", "splice_async")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if stream2 != nil {
		tmp = stream2.P_IOStream()
	}
	var tmp1 unsafe.Pointer
	if cancellable != nil {
		tmp1 = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_stream2 := gi.NewPointerArgument(tmp)
	arg_flags := gi.NewIntArgument(int(flags))
	arg_io_priority := gi.NewInt32Argument(io_priority)
	arg_cancellable := gi.NewPointerArgument(tmp1)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_v, arg_stream2, arg_flags, arg_io_priority, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
}

// Struct IOStreamAdapter
type IOStreamAdapter struct {
	P unsafe.Pointer
}

func IOStreamAdapterGetType() gi.GType {
	ret := _I.GetGType(143, "IOStreamAdapter")
	return ret
}

// ignore GType struct IOStreamClass
// Struct IOStreamPrivate
type IOStreamPrivate struct {
	P unsafe.Pointer
}

func IOStreamPrivateGetType() gi.GType {
	ret := _I.GetGType(144, "IOStreamPrivate")
	return ret
}

// Flags IOStreamSpliceFlags
type IOStreamSpliceFlags int

const (
	IOStreamSpliceFlagsNone         IOStreamSpliceFlags = 0
	IOStreamSpliceFlagsCloseStream1 IOStreamSpliceFlags = 1
	IOStreamSpliceFlagsCloseStream2 IOStreamSpliceFlags = 2
	IOStreamSpliceFlagsWaitForBoth  IOStreamSpliceFlags = 4
)

func IOStreamSpliceFlagsGetType() gi.GType {
	ret := _I.GetGType(145, "IOStreamSpliceFlags")
	return ret
}

// Interface Icon
type Icon struct {
	IconIfc
	P unsafe.Pointer
}
type IconIfc struct{}
type IIcon interface{ P_Icon() unsafe.Pointer }

func (v Icon) P_Icon() unsafe.Pointer { return v.P }
func IconGetType() gi.GType {
	ret := _I.GetGType(146, "Icon")
	return ret
}

// g_icon_deserialize
// container is not nil, container is Icon
// is method
// arg0Type tag: interface, isPtr: true
func IconDeserialize1(value glib.Variant) (result Icon) {
	iv, err := _I.Get(791, "Icon", "deserialize")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_value := gi.NewPointerArgument(value.P)
	args := []gi.Argument{arg_value}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_icon_hash
// container is not nil, container is Icon
// is method
// arg0Type tag: void, isPtr: true
func IconHash1(icon unsafe.Pointer) (result uint32) {
	iv, err := _I.Get(792, "Icon", "hash")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_icon := gi.NewPointerArgument(icon)
	args := []gi.Argument{arg_icon}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Uint32()
	return
}

// g_icon_new_for_string
// container is not nil, container is Icon
// is method
// arg0Type tag: utf8, isPtr: true
func IconNewForString1(str string) (result Icon, err error) {
	iv, err := _I.Get(793, "Icon", "new_for_string")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	c_str := gi.CString(str)
	arg_str := gi.NewStringArgument(c_str)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_str, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	gi.Free(c_str)
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// g_icon_equal
// container is not nil, container is Icon
// is method
func (v *IconIfc) Equal(icon2 IIcon) (result bool) {
	iv, err := _I.Get(794, "Icon", "equal")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if icon2 != nil {
		tmp = icon2.P_Icon()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_icon2 := gi.NewPointerArgument(tmp)
	args := []gi.Argument{arg_v, arg_icon2}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_icon_serialize
// container is not nil, container is Icon
// is method
func (v *IconIfc) Serialize() (result glib.Variant) {
	iv, err := _I.Get(795, "Icon", "serialize")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_icon_to_string
// container is not nil, container is Icon
// is method
func (v *IconIfc) ToString() (result string) {
	iv, err := _I.Get(796, "Icon", "to_string")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Take()
	return
}

// ignore GType struct IconIface
// Object InetAddress
type InetAddress struct {
	gobject.Object
}

func WrapInetAddress(p unsafe.Pointer) (r InetAddress) { r.P = p; return }

type IInetAddress interface{ P_InetAddress() unsafe.Pointer }

func (v InetAddress) P_InetAddress() unsafe.Pointer { return v.P }
func InetAddressGetType() gi.GType {
	ret := _I.GetGType(147, "InetAddress")
	return ret
}

// g_inet_address_new_any
// container is not nil, container is InetAddress
// is constructor
func NewInetAddressAny(family SocketFamilyEnum) (result InetAddress) {
	iv, err := _I.Get(797, "InetAddress", "new_any")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_family := gi.NewIntArgument(int(family))
	args := []gi.Argument{arg_family}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_inet_address_new_from_bytes
// container is not nil, container is InetAddress
// is constructor
func NewInetAddressFromBytes(bytes gi.Uint8Array, family SocketFamilyEnum) (result InetAddress) {
	iv, err := _I.Get(798, "InetAddress", "new_from_bytes")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_bytes := gi.NewPointerArgument(bytes.P)
	arg_family := gi.NewIntArgument(int(family))
	args := []gi.Argument{arg_bytes, arg_family}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_inet_address_new_from_string
// container is not nil, container is InetAddress
// is constructor
func NewInetAddressFromString(string string) (result InetAddress) {
	iv, err := _I.Get(799, "InetAddress", "new_from_string")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_string := gi.CString(string)
	arg_string := gi.NewStringArgument(c_string)
	args := []gi.Argument{arg_string}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_string)
	result.P = ret.Pointer()
	return
}

// g_inet_address_new_loopback
// container is not nil, container is InetAddress
// is constructor
func NewInetAddressLoopback(family SocketFamilyEnum) (result InetAddress) {
	iv, err := _I.Get(800, "InetAddress", "new_loopback")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_family := gi.NewIntArgument(int(family))
	args := []gi.Argument{arg_family}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_inet_address_equal
// container is not nil, container is InetAddress
// is method
func (v InetAddress) Equal(other_address IInetAddress) (result bool) {
	iv, err := _I.Get(801, "InetAddress", "equal")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if other_address != nil {
		tmp = other_address.P_InetAddress()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_other_address := gi.NewPointerArgument(tmp)
	args := []gi.Argument{arg_v, arg_other_address}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_inet_address_get_family
// container is not nil, container is InetAddress
// is method
func (v InetAddress) GetFamily() (result SocketFamilyEnum) {
	iv, err := _I.Get(802, "InetAddress", "get_family")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = SocketFamilyEnum(ret.Int())
	return
}

// g_inet_address_get_is_any
// container is not nil, container is InetAddress
// is method
func (v InetAddress) GetIsAny() (result bool) {
	iv, err := _I.Get(803, "InetAddress", "get_is_any")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_inet_address_get_is_link_local
// container is not nil, container is InetAddress
// is method
func (v InetAddress) GetIsLinkLocal() (result bool) {
	iv, err := _I.Get(804, "InetAddress", "get_is_link_local")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_inet_address_get_is_loopback
// container is not nil, container is InetAddress
// is method
func (v InetAddress) GetIsLoopback() (result bool) {
	iv, err := _I.Get(805, "InetAddress", "get_is_loopback")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_inet_address_get_is_mc_global
// container is not nil, container is InetAddress
// is method
func (v InetAddress) GetIsMcGlobal() (result bool) {
	iv, err := _I.Get(806, "InetAddress", "get_is_mc_global")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_inet_address_get_is_mc_link_local
// container is not nil, container is InetAddress
// is method
func (v InetAddress) GetIsMcLinkLocal() (result bool) {
	iv, err := _I.Get(807, "InetAddress", "get_is_mc_link_local")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_inet_address_get_is_mc_node_local
// container is not nil, container is InetAddress
// is method
func (v InetAddress) GetIsMcNodeLocal() (result bool) {
	iv, err := _I.Get(808, "InetAddress", "get_is_mc_node_local")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_inet_address_get_is_mc_org_local
// container is not nil, container is InetAddress
// is method
func (v InetAddress) GetIsMcOrgLocal() (result bool) {
	iv, err := _I.Get(809, "InetAddress", "get_is_mc_org_local")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_inet_address_get_is_mc_site_local
// container is not nil, container is InetAddress
// is method
func (v InetAddress) GetIsMcSiteLocal() (result bool) {
	iv, err := _I.Get(810, "InetAddress", "get_is_mc_site_local")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_inet_address_get_is_multicast
// container is not nil, container is InetAddress
// is method
func (v InetAddress) GetIsMulticast() (result bool) {
	iv, err := _I.Get(811, "InetAddress", "get_is_multicast")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_inet_address_get_is_site_local
// container is not nil, container is InetAddress
// is method
func (v InetAddress) GetIsSiteLocal() (result bool) {
	iv, err := _I.Get(812, "InetAddress", "get_is_site_local")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_inet_address_get_native_size
// container is not nil, container is InetAddress
// is method
func (v InetAddress) GetNativeSize() (result uint64) {
	iv, err := _I.Get(813, "InetAddress", "get_native_size")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Uint64()
	return
}

// g_inet_address_to_string
// container is not nil, container is InetAddress
// is method
func (v InetAddress) ToString() (result string) {
	iv, err := _I.Get(814, "InetAddress", "to_string")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Take()
	return
}

// ignore GType struct InetAddressClass
// Object InetAddressMask
type InetAddressMask struct {
	InitableIfc
	gobject.Object
}

func WrapInetAddressMask(p unsafe.Pointer) (r InetAddressMask) { r.P = p; return }

type IInetAddressMask interface{ P_InetAddressMask() unsafe.Pointer }

func (v InetAddressMask) P_InetAddressMask() unsafe.Pointer { return v.P }
func (v InetAddressMask) P_Initable() unsafe.Pointer        { return v.P }
func InetAddressMaskGetType() gi.GType {
	ret := _I.GetGType(148, "InetAddressMask")
	return ret
}

// g_inet_address_mask_new
// container is not nil, container is InetAddressMask
// is constructor
func NewInetAddressMask(addr IInetAddress, length uint32) (result InetAddressMask, err error) {
	iv, err := _I.Get(815, "InetAddressMask", "new")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if addr != nil {
		tmp = addr.P_InetAddress()
	}
	arg_addr := gi.NewPointerArgument(tmp)
	arg_length := gi.NewUint32Argument(length)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_addr, arg_length, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// g_inet_address_mask_new_from_string
// container is not nil, container is InetAddressMask
// is constructor
func NewInetAddressMaskFromString(mask_string string) (result InetAddressMask, err error) {
	iv, err := _I.Get(816, "InetAddressMask", "new_from_string")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	c_mask_string := gi.CString(mask_string)
	arg_mask_string := gi.NewStringArgument(c_mask_string)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_mask_string, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	gi.Free(c_mask_string)
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// g_inet_address_mask_equal
// container is not nil, container is InetAddressMask
// is method
func (v InetAddressMask) Equal(mask2 IInetAddressMask) (result bool) {
	iv, err := _I.Get(817, "InetAddressMask", "equal")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if mask2 != nil {
		tmp = mask2.P_InetAddressMask()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_mask2 := gi.NewPointerArgument(tmp)
	args := []gi.Argument{arg_v, arg_mask2}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_inet_address_mask_get_address
// container is not nil, container is InetAddressMask
// is method
func (v InetAddressMask) GetAddress() (result InetAddress) {
	iv, err := _I.Get(818, "InetAddressMask", "get_address")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_inet_address_mask_get_family
// container is not nil, container is InetAddressMask
// is method
func (v InetAddressMask) GetFamily() (result SocketFamilyEnum) {
	iv, err := _I.Get(819, "InetAddressMask", "get_family")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = SocketFamilyEnum(ret.Int())
	return
}

// g_inet_address_mask_get_length
// container is not nil, container is InetAddressMask
// is method
func (v InetAddressMask) GetLength() (result uint32) {
	iv, err := _I.Get(820, "InetAddressMask", "get_length")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Uint32()
	return
}

// g_inet_address_mask_matches
// container is not nil, container is InetAddressMask
// is method
func (v InetAddressMask) Matches(address IInetAddress) (result bool) {
	iv, err := _I.Get(821, "InetAddressMask", "matches")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if address != nil {
		tmp = address.P_InetAddress()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_address := gi.NewPointerArgument(tmp)
	args := []gi.Argument{arg_v, arg_address}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_inet_address_mask_to_string
// container is not nil, container is InetAddressMask
// is method
func (v InetAddressMask) ToString() (result string) {
	iv, err := _I.Get(822, "InetAddressMask", "to_string")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Take()
	return
}

// ignore GType struct InetAddressMaskClass
// Struct InetAddressMaskPrivate
type InetAddressMaskPrivate struct {
	P unsafe.Pointer
}

func InetAddressMaskPrivateGetType() gi.GType {
	ret := _I.GetGType(149, "InetAddressMaskPrivate")
	return ret
}

// Struct InetAddressPrivate
type InetAddressPrivate struct {
	P unsafe.Pointer
}

func InetAddressPrivateGetType() gi.GType {
	ret := _I.GetGType(150, "InetAddressPrivate")
	return ret
}

// Object InetSocketAddress
type InetSocketAddress struct {
	SocketConnectableIfc
	SocketAddress
}

func WrapInetSocketAddress(p unsafe.Pointer) (r InetSocketAddress) { r.P = p; return }

type IInetSocketAddress interface{ P_InetSocketAddress() unsafe.Pointer }

func (v InetSocketAddress) P_InetSocketAddress() unsafe.Pointer { return v.P }
func (v InetSocketAddress) P_SocketConnectable() unsafe.Pointer { return v.P }
func InetSocketAddressGetType() gi.GType {
	ret := _I.GetGType(151, "InetSocketAddress")
	return ret
}

// g_inet_socket_address_new
// container is not nil, container is InetSocketAddress
// is constructor
func NewInetSocketAddress(address IInetAddress, port uint16) (result InetSocketAddress) {
	iv, err := _I.Get(823, "InetSocketAddress", "new")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if address != nil {
		tmp = address.P_InetAddress()
	}
	arg_address := gi.NewPointerArgument(tmp)
	arg_port := gi.NewUint16Argument(port)
	args := []gi.Argument{arg_address, arg_port}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_inet_socket_address_new_from_string
// container is not nil, container is InetSocketAddress
// is constructor
func NewInetSocketAddressFromString(address string, port uint32) (result InetSocketAddress) {
	iv, err := _I.Get(824, "InetSocketAddress", "new_from_string")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_address := gi.CString(address)
	arg_address := gi.NewStringArgument(c_address)
	arg_port := gi.NewUint32Argument(port)
	args := []gi.Argument{arg_address, arg_port}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_address)
	result.P = ret.Pointer()
	return
}

// g_inet_socket_address_get_address
// container is not nil, container is InetSocketAddress
// is method
func (v InetSocketAddress) GetAddress() (result InetAddress) {
	iv, err := _I.Get(825, "InetSocketAddress", "get_address")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_inet_socket_address_get_flowinfo
// container is not nil, container is InetSocketAddress
// is method
func (v InetSocketAddress) GetFlowinfo() (result uint32) {
	iv, err := _I.Get(826, "InetSocketAddress", "get_flowinfo")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Uint32()
	return
}

// g_inet_socket_address_get_port
// container is not nil, container is InetSocketAddress
// is method
func (v InetSocketAddress) GetPort() (result uint16) {
	iv, err := _I.Get(827, "InetSocketAddress", "get_port")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Uint16()
	return
}

// g_inet_socket_address_get_scope_id
// container is not nil, container is InetSocketAddress
// is method
func (v InetSocketAddress) GetScopeId() (result uint32) {
	iv, err := _I.Get(828, "InetSocketAddress", "get_scope_id")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Uint32()
	return
}

// ignore GType struct InetSocketAddressClass
// Struct InetSocketAddressPrivate
type InetSocketAddressPrivate struct {
	P unsafe.Pointer
}

func InetSocketAddressPrivateGetType() gi.GType {
	ret := _I.GetGType(152, "InetSocketAddressPrivate")
	return ret
}

// Interface Initable
type Initable struct {
	InitableIfc
	P unsafe.Pointer
}
type InitableIfc struct{}
type IInitable interface{ P_Initable() unsafe.Pointer }

func (v Initable) P_Initable() unsafe.Pointer { return v.P }
func InitableGetType() gi.GType {
	ret := _I.GetGType(153, "Initable")
	return ret
}

// g_initable_newv
// container is not nil, container is Initable
// is method
// arg0Type tag: GType, isPtr: false
// arg 2 parameters lenArgIdx 1
func InitableNewv1(object_type gi.GType, n_parameters uint32, parameters unsafe.Pointer, cancellable ICancellable) (result gobject.Object, err error) {
	iv, err := _I.Get(829, "Initable", "newv")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_object_type := gi.NewUintArgument(uint(object_type))
	arg_n_parameters := gi.NewUint32Argument(n_parameters)
	arg_parameters := gi.NewPointerArgument(parameters)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_object_type, arg_n_parameters, arg_parameters, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// g_initable_init
// container is not nil, container is Initable
// is method
func (v *InitableIfc) Init(cancellable ICancellable) (result bool, err error) {
	iv, err := _I.Get(830, "Initable", "init")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Bool()
	return
}

// ignore GType struct InitableIface
// Struct InputMessage
type InputMessage struct {
	P unsafe.Pointer
}

const SizeOfStructInputMessage = 56

func InputMessageGetType() gi.GType {
	ret := _I.GetGType(154, "InputMessage")
	return ret
}

// Object InputStream
type InputStream struct {
	gobject.Object
}

func WrapInputStream(p unsafe.Pointer) (r InputStream) { r.P = p; return }

type IInputStream interface{ P_InputStream() unsafe.Pointer }

func (v InputStream) P_InputStream() unsafe.Pointer { return v.P }
func InputStreamGetType() gi.GType {
	ret := _I.GetGType(155, "InputStream")
	return ret
}

// g_input_stream_clear_pending
// container is not nil, container is InputStream
// is method
func (v InputStream) ClearPending() {
	iv, err := _I.Get(831, "InputStream", "clear_pending")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	iv.Call(args, nil, nil)
}

// g_input_stream_close
// container is not nil, container is InputStream
// is method
func (v InputStream) Close(cancellable ICancellable) (result bool, err error) {
	iv, err := _I.Get(832, "InputStream", "close")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Bool()
	return
}

// g_input_stream_close_async
// container is not nil, container is InputStream
// is method
func (v InputStream) CloseAsync(io_priority int32, cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(833, "InputStream", "close_async")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_io_priority := gi.NewInt32Argument(io_priority)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_v, arg_io_priority, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
}

// g_input_stream_close_finish
// container is not nil, container is InputStream
// is method
func (v InputStream) CloseFinish(result IAsyncResult) (result1 bool, err error) {
	iv, err := _I.Get(834, "InputStream", "close_finish")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if result != nil {
		tmp = result.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_result := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_result, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result1 = ret.Bool()
	return
}

// g_input_stream_has_pending
// container is not nil, container is InputStream
// is method
func (v InputStream) HasPending() (result bool) {
	iv, err := _I.Get(835, "InputStream", "has_pending")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_input_stream_is_closed
// container is not nil, container is InputStream
// is method
func (v InputStream) IsClosed() (result bool) {
	iv, err := _I.Get(836, "InputStream", "is_closed")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_input_stream_read
// container is not nil, container is InputStream
// is method
// arg 0 buffer lenArgIdx 1
func (v InputStream) Read(buffer gi.Uint8Array, count uint64, cancellable ICancellable) (result int64, err error) {
	iv, err := _I.Get(837, "InputStream", "read")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_buffer := gi.NewPointerArgument(buffer.P)
	arg_count := gi.NewUint64Argument(count)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_buffer, arg_count, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Int64()
	return
}

// g_input_stream_read_all
// container is not nil, container is InputStream
// is method
// arg 0 buffer lenArgIdx 1
func (v InputStream) ReadAll(buffer gi.Uint8Array, count uint64, cancellable ICancellable) (result bool, bytes_read uint64, err error) {
	iv, err := _I.Get(838, "InputStream", "read_all")
	if err != nil {
		return
	}
	var outArgs [2]gi.Argument
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_buffer := gi.NewPointerArgument(buffer.P)
	arg_count := gi.NewUint64Argument(count)
	arg_bytes_read := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[1]))
	args := []gi.Argument{arg_v, arg_buffer, arg_count, arg_bytes_read, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[1].Pointer())
	bytes_read = outArgs[0].Uint64()
	result = ret.Bool()
	return
}

// g_input_stream_read_all_async
// container is not nil, container is InputStream
// is method
// arg 0 buffer lenArgIdx 1
func (v InputStream) ReadAllAsync(buffer gi.Uint8Array, count uint64, io_priority int32, cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(839, "InputStream", "read_all_async")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_buffer := gi.NewPointerArgument(buffer.P)
	arg_count := gi.NewUint64Argument(count)
	arg_io_priority := gi.NewInt32Argument(io_priority)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_v, arg_buffer, arg_count, arg_io_priority, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
}

// g_input_stream_read_all_finish
// container is not nil, container is InputStream
// is method
func (v InputStream) ReadAllFinish(result IAsyncResult) (result1 bool, bytes_read uint64, err error) {
	iv, err := _I.Get(840, "InputStream", "read_all_finish")
	if err != nil {
		return
	}
	var outArgs [2]gi.Argument
	var tmp unsafe.Pointer
	if result != nil {
		tmp = result.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_result := gi.NewPointerArgument(tmp)
	arg_bytes_read := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[1]))
	args := []gi.Argument{arg_v, arg_result, arg_bytes_read, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[1].Pointer())
	bytes_read = outArgs[0].Uint64()
	result1 = ret.Bool()
	return
}

// g_input_stream_read_async
// container is not nil, container is InputStream
// is method
// arg 0 buffer lenArgIdx 1
func (v InputStream) ReadAsync(buffer gi.Uint8Array, count uint64, io_priority int32, cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(841, "InputStream", "read_async")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_buffer := gi.NewPointerArgument(buffer.P)
	arg_count := gi.NewUint64Argument(count)
	arg_io_priority := gi.NewInt32Argument(io_priority)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_v, arg_buffer, arg_count, arg_io_priority, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
}

// g_input_stream_read_bytes
// container is not nil, container is InputStream
// is method
func (v InputStream) ReadBytes(count uint64, cancellable ICancellable) (result glib.Bytes, err error) {
	iv, err := _I.Get(842, "InputStream", "read_bytes")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_count := gi.NewUint64Argument(count)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_count, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// g_input_stream_read_bytes_async
// container is not nil, container is InputStream
// is method
func (v InputStream) ReadBytesAsync(count uint64, io_priority int32, cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(843, "InputStream", "read_bytes_async")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_count := gi.NewUint64Argument(count)
	arg_io_priority := gi.NewInt32Argument(io_priority)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_v, arg_count, arg_io_priority, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
}

// g_input_stream_read_bytes_finish
// container is not nil, container is InputStream
// is method
func (v InputStream) ReadBytesFinish(result IAsyncResult) (result1 glib.Bytes, err error) {
	iv, err := _I.Get(844, "InputStream", "read_bytes_finish")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if result != nil {
		tmp = result.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_result := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_result, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result1.P = ret.Pointer()
	return
}

// g_input_stream_read_finish
// container is not nil, container is InputStream
// is method
func (v InputStream) ReadFinish(result IAsyncResult) (result1 int64, err error) {
	iv, err := _I.Get(845, "InputStream", "read_finish")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if result != nil {
		tmp = result.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_result := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_result, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result1 = ret.Int64()
	return
}

// g_input_stream_set_pending
// container is not nil, container is InputStream
// is method
func (v InputStream) SetPending() (result bool, err error) {
	iv, err := _I.Get(846, "InputStream", "set_pending")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	arg_v := gi.NewPointerArgument(v.P)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Bool()
	return
}

// g_input_stream_skip
// container is not nil, container is InputStream
// is method
func (v InputStream) Skip(count uint64, cancellable ICancellable) (result int64, err error) {
	iv, err := _I.Get(847, "InputStream", "skip")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_count := gi.NewUint64Argument(count)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_count, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Int64()
	return
}

// g_input_stream_skip_async
// container is not nil, container is InputStream
// is method
func (v InputStream) SkipAsync(count uint64, io_priority int32, cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(848, "InputStream", "skip_async")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_count := gi.NewUint64Argument(count)
	arg_io_priority := gi.NewInt32Argument(io_priority)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_v, arg_count, arg_io_priority, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
}

// g_input_stream_skip_finish
// container is not nil, container is InputStream
// is method
func (v InputStream) SkipFinish(result IAsyncResult) (result1 int64, err error) {
	iv, err := _I.Get(849, "InputStream", "skip_finish")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if result != nil {
		tmp = result.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_result := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_result, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result1 = ret.Int64()
	return
}

// ignore GType struct InputStreamClass
// Struct InputStreamPrivate
type InputStreamPrivate struct {
	P unsafe.Pointer
}

func InputStreamPrivateGetType() gi.GType {
	ret := _I.GetGType(156, "InputStreamPrivate")
	return ret
}

// Struct InputVector
type InputVector struct {
	P unsafe.Pointer
}

const SizeOfStructInputVector = 16

func InputVectorGetType() gi.GType {
	ret := _I.GetGType(157, "InputVector")
	return ret
}

// Interface ListModel
type ListModel struct {
	ListModelIfc
	P unsafe.Pointer
}
type ListModelIfc struct{}
type IListModel interface{ P_ListModel() unsafe.Pointer }

func (v ListModel) P_ListModel() unsafe.Pointer { return v.P }
func ListModelGetType() gi.GType {
	ret := _I.GetGType(158, "ListModel")
	return ret
}

// g_list_model_get_item_type
// container is not nil, container is ListModel
// is method
func (v *ListModelIfc) GetItemType() (result gi.GType) {
	iv, err := _I.Get(850, "ListModel", "get_item_type")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = gi.GType(ret.Uint())
	return
}

// g_list_model_get_n_items
// container is not nil, container is ListModel
// is method
func (v *ListModelIfc) GetNItems() (result uint32) {
	iv, err := _I.Get(851, "ListModel", "get_n_items")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Uint32()
	return
}

// g_list_model_get_object
// container is not nil, container is ListModel
// is method
func (v *ListModelIfc) GetItem(position uint32) (result gobject.Object) {
	iv, err := _I.Get(852, "ListModel", "get_item")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_position := gi.NewUint32Argument(position)
	args := []gi.Argument{arg_v, arg_position}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_list_model_items_changed
// container is not nil, container is ListModel
// is method
func (v *ListModelIfc) ItemsChanged(position uint32, removed uint32, added uint32) {
	iv, err := _I.Get(853, "ListModel", "items_changed")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_position := gi.NewUint32Argument(position)
	arg_removed := gi.NewUint32Argument(removed)
	arg_added := gi.NewUint32Argument(added)
	args := []gi.Argument{arg_v, arg_position, arg_removed, arg_added}
	iv.Call(args, nil, nil)
}

// ignore GType struct ListModelInterface
// Object ListStore
type ListStore struct {
	ListModelIfc
	gobject.Object
}

func WrapListStore(p unsafe.Pointer) (r ListStore) { r.P = p; return }

type IListStore interface{ P_ListStore() unsafe.Pointer }

func (v ListStore) P_ListStore() unsafe.Pointer { return v.P }
func (v ListStore) P_ListModel() unsafe.Pointer { return v.P }
func ListStoreGetType() gi.GType {
	ret := _I.GetGType(159, "ListStore")
	return ret
}

// g_list_store_new
// container is not nil, container is ListStore
// is constructor
func NewListStore(item_type gi.GType) (result ListStore) {
	iv, err := _I.Get(854, "ListStore", "new")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_item_type := gi.NewUintArgument(uint(item_type))
	args := []gi.Argument{arg_item_type}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_list_store_append
// container is not nil, container is ListStore
// is method
func (v ListStore) Append(item gobject.IObject) {
	iv, err := _I.Get(855, "ListStore", "append")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if item != nil {
		tmp = item.P_Object()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_item := gi.NewPointerArgument(tmp)
	args := []gi.Argument{arg_v, arg_item}
	iv.Call(args, nil, nil)
}

// g_list_store_insert
// container is not nil, container is ListStore
// is method
func (v ListStore) Insert(position uint32, item gobject.IObject) {
	iv, err := _I.Get(856, "ListStore", "insert")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if item != nil {
		tmp = item.P_Object()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_position := gi.NewUint32Argument(position)
	arg_item := gi.NewPointerArgument(tmp)
	args := []gi.Argument{arg_v, arg_position, arg_item}
	iv.Call(args, nil, nil)
}

// g_list_store_insert_sorted
// container is not nil, container is ListStore
// is method
func (v ListStore) InsertSorted(item gobject.IObject, compare_func int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) (result uint32) {
	iv, err := _I.Get(857, "ListStore", "insert_sorted")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if item != nil {
		tmp = item.P_Object()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_item := gi.NewPointerArgument(tmp)
	arg_compare_func := gi.NewIntArgument(compare_func) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_v, arg_item, arg_compare_func, arg_user_data}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Uint32()
	return
}

// g_list_store_remove
// container is not nil, container is ListStore
// is method
func (v ListStore) Remove(position uint32) {
	iv, err := _I.Get(858, "ListStore", "remove")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_position := gi.NewUint32Argument(position)
	args := []gi.Argument{arg_v, arg_position}
	iv.Call(args, nil, nil)
}

// g_list_store_remove_all
// container is not nil, container is ListStore
// is method
func (v ListStore) RemoveAll() {
	iv, err := _I.Get(859, "ListStore", "remove_all")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	iv.Call(args, nil, nil)
}

// g_list_store_sort
// container is not nil, container is ListStore
// is method
func (v ListStore) Sort(compare_func int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(860, "ListStore", "sort")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_compare_func := gi.NewIntArgument(compare_func) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_v, arg_compare_func, arg_user_data}
	iv.Call(args, nil, nil)
}

// g_list_store_splice
// container is not nil, container is ListStore
// is method
// arg 2 additions lenArgIdx 3
func (v ListStore) Splice(position uint32, n_removals uint32, additions unsafe.Pointer, n_additions uint32) {
	iv, err := _I.Get(861, "ListStore", "splice")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_position := gi.NewUint32Argument(position)
	arg_n_removals := gi.NewUint32Argument(n_removals)
	arg_additions := gi.NewPointerArgument(additions)
	arg_n_additions := gi.NewUint32Argument(n_additions)
	args := []gi.Argument{arg_v, arg_position, arg_n_removals, arg_additions, arg_n_additions}
	iv.Call(args, nil, nil)
}

// ignore GType struct ListStoreClass
// Interface LoadableIcon
type LoadableIcon struct {
	LoadableIconIfc
	P unsafe.Pointer
}
type LoadableIconIfc struct{}
type ILoadableIcon interface{ P_LoadableIcon() unsafe.Pointer }

func (v LoadableIcon) P_LoadableIcon() unsafe.Pointer { return v.P }
func LoadableIconGetType() gi.GType {
	ret := _I.GetGType(160, "LoadableIcon")
	return ret
}

// g_loadable_icon_load
// container is not nil, container is LoadableIcon
// is method
func (v *LoadableIconIfc) Load(size int32, cancellable ICancellable) (result InputStream, type1 string, err error) {
	iv, err := _I.Get(862, "LoadableIcon", "load")
	if err != nil {
		return
	}
	var outArgs [2]gi.Argument
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_size := gi.NewInt32Argument(size)
	arg_type1 := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[1]))
	args := []gi.Argument{arg_v, arg_size, arg_type1, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[1].Pointer())
	type1 = outArgs[0].String().Take()
	result.P = ret.Pointer()
	return
}

// g_loadable_icon_load_async
// container is not nil, container is LoadableIcon
// is method
func (v *LoadableIconIfc) LoadAsync(size int32, cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(863, "LoadableIcon", "load_async")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_size := gi.NewInt32Argument(size)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_v, arg_size, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
}

// g_loadable_icon_load_finish
// container is not nil, container is LoadableIcon
// is method
func (v *LoadableIconIfc) LoadFinish(res IAsyncResult) (result InputStream, type1 string, err error) {
	iv, err := _I.Get(864, "LoadableIcon", "load_finish")
	if err != nil {
		return
	}
	var outArgs [2]gi.Argument
	var tmp unsafe.Pointer
	if res != nil {
		tmp = res.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_res := gi.NewPointerArgument(tmp)
	arg_type1 := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[1]))
	args := []gi.Argument{arg_v, arg_res, arg_type1, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[1].Pointer())
	type1 = outArgs[0].String().Take()
	result.P = ret.Pointer()
	return
}

// ignore GType struct LoadableIconIface
// Object MemoryInputStream
type MemoryInputStream struct {
	PollableInputStreamIfc
	SeekableIfc
	InputStream
}

func WrapMemoryInputStream(p unsafe.Pointer) (r MemoryInputStream) { r.P = p; return }

type IMemoryInputStream interface{ P_MemoryInputStream() unsafe.Pointer }

func (v MemoryInputStream) P_MemoryInputStream() unsafe.Pointer   { return v.P }
func (v MemoryInputStream) P_PollableInputStream() unsafe.Pointer { return v.P }
func (v MemoryInputStream) P_Seekable() unsafe.Pointer            { return v.P }
func MemoryInputStreamGetType() gi.GType {
	ret := _I.GetGType(161, "MemoryInputStream")
	return ret
}

// g_memory_input_stream_new
// container is not nil, container is MemoryInputStream
// is constructor
func NewMemoryInputStream() (result MemoryInputStream) {
	iv, err := _I.Get(865, "MemoryInputStream", "new")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var ret gi.Argument
	iv.Call(nil, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_memory_input_stream_new_from_bytes
// container is not nil, container is MemoryInputStream
// is constructor
func NewMemoryInputStreamFromBytes(bytes glib.Bytes) (result MemoryInputStream) {
	iv, err := _I.Get(866, "MemoryInputStream", "new_from_bytes")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_bytes := gi.NewPointerArgument(bytes.P)
	args := []gi.Argument{arg_bytes}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_memory_input_stream_new_from_data
// container is not nil, container is MemoryInputStream
// is constructor
// arg 0 data lenArgIdx 1
func NewMemoryInputStreamFromData(data gi.Uint8Array, len1 int64, destroy int /*TODO_TYPE isPtr: false, tag: interface*/) (result MemoryInputStream) {
	iv, err := _I.Get(867, "MemoryInputStream", "new_from_data")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_data := gi.NewPointerArgument(data.P)
	arg_len1 := gi.NewInt64Argument(len1)
	arg_destroy := gi.NewIntArgument(destroy) /*TODO*/
	args := []gi.Argument{arg_data, arg_len1, arg_destroy}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_memory_input_stream_add_bytes
// container is not nil, container is MemoryInputStream
// is method
func (v MemoryInputStream) AddBytes(bytes glib.Bytes) {
	iv, err := _I.Get(868, "MemoryInputStream", "add_bytes")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_bytes := gi.NewPointerArgument(bytes.P)
	args := []gi.Argument{arg_v, arg_bytes}
	iv.Call(args, nil, nil)
}

// g_memory_input_stream_add_data
// container is not nil, container is MemoryInputStream
// is method
// arg 0 data lenArgIdx 1
func (v MemoryInputStream) AddData(data gi.Uint8Array, len1 int64, destroy int /*TODO_TYPE isPtr: false, tag: interface*/) {
	iv, err := _I.Get(869, "MemoryInputStream", "add_data")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_data := gi.NewPointerArgument(data.P)
	arg_len1 := gi.NewInt64Argument(len1)
	arg_destroy := gi.NewIntArgument(destroy) /*TODO*/
	args := []gi.Argument{arg_v, arg_data, arg_len1, arg_destroy}
	iv.Call(args, nil, nil)
}

// ignore GType struct MemoryInputStreamClass
// Struct MemoryInputStreamPrivate
type MemoryInputStreamPrivate struct {
	P unsafe.Pointer
}

func MemoryInputStreamPrivateGetType() gi.GType {
	ret := _I.GetGType(162, "MemoryInputStreamPrivate")
	return ret
}

// Object MemoryOutputStream
type MemoryOutputStream struct {
	PollableOutputStreamIfc
	SeekableIfc
	OutputStream
}

func WrapMemoryOutputStream(p unsafe.Pointer) (r MemoryOutputStream) { r.P = p; return }

type IMemoryOutputStream interface{ P_MemoryOutputStream() unsafe.Pointer }

func (v MemoryOutputStream) P_MemoryOutputStream() unsafe.Pointer   { return v.P }
func (v MemoryOutputStream) P_PollableOutputStream() unsafe.Pointer { return v.P }
func (v MemoryOutputStream) P_Seekable() unsafe.Pointer             { return v.P }
func MemoryOutputStreamGetType() gi.GType {
	ret := _I.GetGType(163, "MemoryOutputStream")
	return ret
}

// g_memory_output_stream_new_resizable
// container is not nil, container is MemoryOutputStream
// is constructor
func NewMemoryOutputStreamResizable() (result MemoryOutputStream) {
	iv, err := _I.Get(870, "MemoryOutputStream", "new_resizable")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var ret gi.Argument
	iv.Call(nil, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_memory_output_stream_get_data
// container is not nil, container is MemoryOutputStream
// is method
func (v MemoryOutputStream) GetData() (result unsafe.Pointer) {
	iv, err := _I.Get(871, "MemoryOutputStream", "get_data")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Pointer()
	return
}

// g_memory_output_stream_get_data_size
// container is not nil, container is MemoryOutputStream
// is method
func (v MemoryOutputStream) GetDataSize() (result uint64) {
	iv, err := _I.Get(872, "MemoryOutputStream", "get_data_size")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Uint64()
	return
}

// g_memory_output_stream_get_size
// container is not nil, container is MemoryOutputStream
// is method
func (v MemoryOutputStream) GetSize() (result uint64) {
	iv, err := _I.Get(873, "MemoryOutputStream", "get_size")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Uint64()
	return
}

// g_memory_output_stream_steal_as_bytes
// container is not nil, container is MemoryOutputStream
// is method
func (v MemoryOutputStream) StealAsBytes() (result glib.Bytes) {
	iv, err := _I.Get(874, "MemoryOutputStream", "steal_as_bytes")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_memory_output_stream_steal_data
// container is not nil, container is MemoryOutputStream
// is method
func (v MemoryOutputStream) StealData() (result unsafe.Pointer) {
	iv, err := _I.Get(875, "MemoryOutputStream", "steal_data")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Pointer()
	return
}

// ignore GType struct MemoryOutputStreamClass
// Struct MemoryOutputStreamPrivate
type MemoryOutputStreamPrivate struct {
	P unsafe.Pointer
}

func MemoryOutputStreamPrivateGetType() gi.GType {
	ret := _I.GetGType(164, "MemoryOutputStreamPrivate")
	return ret
}

// Object Menu
type Menu struct {
	MenuModel
}

func WrapMenu(p unsafe.Pointer) (r Menu) { r.P = p; return }

type IMenu interface{ P_Menu() unsafe.Pointer }

func (v Menu) P_Menu() unsafe.Pointer { return v.P }
func MenuGetType() gi.GType {
	ret := _I.GetGType(165, "Menu")
	return ret
}

// g_menu_new
// container is not nil, container is Menu
// is constructor
func NewMenu() (result Menu) {
	iv, err := _I.Get(876, "Menu", "new")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var ret gi.Argument
	iv.Call(nil, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_menu_append
// container is not nil, container is Menu
// is method
func (v Menu) Append(label string, detailed_action string) {
	iv, err := _I.Get(877, "Menu", "append")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_label := gi.CString(label)
	c_detailed_action := gi.CString(detailed_action)
	arg_v := gi.NewPointerArgument(v.P)
	arg_label := gi.NewStringArgument(c_label)
	arg_detailed_action := gi.NewStringArgument(c_detailed_action)
	args := []gi.Argument{arg_v, arg_label, arg_detailed_action}
	iv.Call(args, nil, nil)
	gi.Free(c_label)
	gi.Free(c_detailed_action)
}

// g_menu_append_item
// container is not nil, container is Menu
// is method
func (v Menu) AppendItem(item IMenuItem) {
	iv, err := _I.Get(878, "Menu", "append_item")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if item != nil {
		tmp = item.P_MenuItem()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_item := gi.NewPointerArgument(tmp)
	args := []gi.Argument{arg_v, arg_item}
	iv.Call(args, nil, nil)
}

// g_menu_append_section
// container is not nil, container is Menu
// is method
func (v Menu) AppendSection(label string, section IMenuModel) {
	iv, err := _I.Get(879, "Menu", "append_section")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_label := gi.CString(label)
	var tmp unsafe.Pointer
	if section != nil {
		tmp = section.P_MenuModel()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_label := gi.NewStringArgument(c_label)
	arg_section := gi.NewPointerArgument(tmp)
	args := []gi.Argument{arg_v, arg_label, arg_section}
	iv.Call(args, nil, nil)
	gi.Free(c_label)
}

// g_menu_append_submenu
// container is not nil, container is Menu
// is method
func (v Menu) AppendSubmenu(label string, submenu IMenuModel) {
	iv, err := _I.Get(880, "Menu", "append_submenu")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_label := gi.CString(label)
	var tmp unsafe.Pointer
	if submenu != nil {
		tmp = submenu.P_MenuModel()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_label := gi.NewStringArgument(c_label)
	arg_submenu := gi.NewPointerArgument(tmp)
	args := []gi.Argument{arg_v, arg_label, arg_submenu}
	iv.Call(args, nil, nil)
	gi.Free(c_label)
}

// g_menu_freeze
// container is not nil, container is Menu
// is method
func (v Menu) Freeze() {
	iv, err := _I.Get(881, "Menu", "freeze")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	iv.Call(args, nil, nil)
}

// g_menu_insert
// container is not nil, container is Menu
// is method
func (v Menu) Insert(position int32, label string, detailed_action string) {
	iv, err := _I.Get(882, "Menu", "insert")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_label := gi.CString(label)
	c_detailed_action := gi.CString(detailed_action)
	arg_v := gi.NewPointerArgument(v.P)
	arg_position := gi.NewInt32Argument(position)
	arg_label := gi.NewStringArgument(c_label)
	arg_detailed_action := gi.NewStringArgument(c_detailed_action)
	args := []gi.Argument{arg_v, arg_position, arg_label, arg_detailed_action}
	iv.Call(args, nil, nil)
	gi.Free(c_label)
	gi.Free(c_detailed_action)
}

// g_menu_insert_item
// container is not nil, container is Menu
// is method
func (v Menu) InsertItem(position int32, item IMenuItem) {
	iv, err := _I.Get(883, "Menu", "insert_item")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if item != nil {
		tmp = item.P_MenuItem()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_position := gi.NewInt32Argument(position)
	arg_item := gi.NewPointerArgument(tmp)
	args := []gi.Argument{arg_v, arg_position, arg_item}
	iv.Call(args, nil, nil)
}

// g_menu_insert_section
// container is not nil, container is Menu
// is method
func (v Menu) InsertSection(position int32, label string, section IMenuModel) {
	iv, err := _I.Get(884, "Menu", "insert_section")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_label := gi.CString(label)
	var tmp unsafe.Pointer
	if section != nil {
		tmp = section.P_MenuModel()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_position := gi.NewInt32Argument(position)
	arg_label := gi.NewStringArgument(c_label)
	arg_section := gi.NewPointerArgument(tmp)
	args := []gi.Argument{arg_v, arg_position, arg_label, arg_section}
	iv.Call(args, nil, nil)
	gi.Free(c_label)
}

// g_menu_insert_submenu
// container is not nil, container is Menu
// is method
func (v Menu) InsertSubmenu(position int32, label string, submenu IMenuModel) {
	iv, err := _I.Get(885, "Menu", "insert_submenu")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_label := gi.CString(label)
	var tmp unsafe.Pointer
	if submenu != nil {
		tmp = submenu.P_MenuModel()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_position := gi.NewInt32Argument(position)
	arg_label := gi.NewStringArgument(c_label)
	arg_submenu := gi.NewPointerArgument(tmp)
	args := []gi.Argument{arg_v, arg_position, arg_label, arg_submenu}
	iv.Call(args, nil, nil)
	gi.Free(c_label)
}

// g_menu_prepend
// container is not nil, container is Menu
// is method
func (v Menu) Prepend(label string, detailed_action string) {
	iv, err := _I.Get(886, "Menu", "prepend")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_label := gi.CString(label)
	c_detailed_action := gi.CString(detailed_action)
	arg_v := gi.NewPointerArgument(v.P)
	arg_label := gi.NewStringArgument(c_label)
	arg_detailed_action := gi.NewStringArgument(c_detailed_action)
	args := []gi.Argument{arg_v, arg_label, arg_detailed_action}
	iv.Call(args, nil, nil)
	gi.Free(c_label)
	gi.Free(c_detailed_action)
}

// g_menu_prepend_item
// container is not nil, container is Menu
// is method
func (v Menu) PrependItem(item IMenuItem) {
	iv, err := _I.Get(887, "Menu", "prepend_item")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if item != nil {
		tmp = item.P_MenuItem()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_item := gi.NewPointerArgument(tmp)
	args := []gi.Argument{arg_v, arg_item}
	iv.Call(args, nil, nil)
}

// g_menu_prepend_section
// container is not nil, container is Menu
// is method
func (v Menu) PrependSection(label string, section IMenuModel) {
	iv, err := _I.Get(888, "Menu", "prepend_section")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_label := gi.CString(label)
	var tmp unsafe.Pointer
	if section != nil {
		tmp = section.P_MenuModel()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_label := gi.NewStringArgument(c_label)
	arg_section := gi.NewPointerArgument(tmp)
	args := []gi.Argument{arg_v, arg_label, arg_section}
	iv.Call(args, nil, nil)
	gi.Free(c_label)
}

// g_menu_prepend_submenu
// container is not nil, container is Menu
// is method
func (v Menu) PrependSubmenu(label string, submenu IMenuModel) {
	iv, err := _I.Get(889, "Menu", "prepend_submenu")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_label := gi.CString(label)
	var tmp unsafe.Pointer
	if submenu != nil {
		tmp = submenu.P_MenuModel()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_label := gi.NewStringArgument(c_label)
	arg_submenu := gi.NewPointerArgument(tmp)
	args := []gi.Argument{arg_v, arg_label, arg_submenu}
	iv.Call(args, nil, nil)
	gi.Free(c_label)
}

// g_menu_remove
// container is not nil, container is Menu
// is method
func (v Menu) Remove(position int32) {
	iv, err := _I.Get(890, "Menu", "remove")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_position := gi.NewInt32Argument(position)
	args := []gi.Argument{arg_v, arg_position}
	iv.Call(args, nil, nil)
}

// g_menu_remove_all
// container is not nil, container is Menu
// is method
func (v Menu) RemoveAll() {
	iv, err := _I.Get(891, "Menu", "remove_all")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	iv.Call(args, nil, nil)
}

// Object MenuAttributeIter
type MenuAttributeIter struct {
	gobject.Object
}

func WrapMenuAttributeIter(p unsafe.Pointer) (r MenuAttributeIter) { r.P = p; return }

type IMenuAttributeIter interface{ P_MenuAttributeIter() unsafe.Pointer }

func (v MenuAttributeIter) P_MenuAttributeIter() unsafe.Pointer { return v.P }
func MenuAttributeIterGetType() gi.GType {
	ret := _I.GetGType(166, "MenuAttributeIter")
	return ret
}

// g_menu_attribute_iter_get_name
// container is not nil, container is MenuAttributeIter
// is method
func (v MenuAttributeIter) GetName() (result string) {
	iv, err := _I.Get(892, "MenuAttributeIter", "get_name")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Take()
	return
}

// g_menu_attribute_iter_get_next
// container is not nil, container is MenuAttributeIter
// is method
func (v MenuAttributeIter) GetNext() (result bool, out_name string, value glib.Variant) {
	iv, err := _I.Get(893, "MenuAttributeIter", "get_next")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var outArgs [2]gi.Argument
	arg_v := gi.NewPointerArgument(v.P)
	arg_out_name := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	arg_value := gi.NewPointerArgument(unsafe.Pointer(&outArgs[1]))
	args := []gi.Argument{arg_v, arg_out_name, arg_value}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	out_name = outArgs[0].String().Take()
	value.P = outArgs[1].Pointer()
	result = ret.Bool()
	return
}

// g_menu_attribute_iter_get_value
// container is not nil, container is MenuAttributeIter
// is method
func (v MenuAttributeIter) GetValue() (result glib.Variant) {
	iv, err := _I.Get(894, "MenuAttributeIter", "get_value")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_menu_attribute_iter_next
// container is not nil, container is MenuAttributeIter
// is method
func (v MenuAttributeIter) Next() (result bool) {
	iv, err := _I.Get(895, "MenuAttributeIter", "next")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// ignore GType struct MenuAttributeIterClass
// Struct MenuAttributeIterPrivate
type MenuAttributeIterPrivate struct {
	P unsafe.Pointer
}

func MenuAttributeIterPrivateGetType() gi.GType {
	ret := _I.GetGType(167, "MenuAttributeIterPrivate")
	return ret
}

// Object MenuItem
type MenuItem struct {
	gobject.Object
}

func WrapMenuItem(p unsafe.Pointer) (r MenuItem) { r.P = p; return }

type IMenuItem interface{ P_MenuItem() unsafe.Pointer }

func (v MenuItem) P_MenuItem() unsafe.Pointer { return v.P }
func MenuItemGetType() gi.GType {
	ret := _I.GetGType(168, "MenuItem")
	return ret
}

// g_menu_item_new
// container is not nil, container is MenuItem
// is constructor
func NewMenuItem(label string, detailed_action string) (result MenuItem) {
	iv, err := _I.Get(896, "MenuItem", "new")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_label := gi.CString(label)
	c_detailed_action := gi.CString(detailed_action)
	arg_label := gi.NewStringArgument(c_label)
	arg_detailed_action := gi.NewStringArgument(c_detailed_action)
	args := []gi.Argument{arg_label, arg_detailed_action}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_label)
	gi.Free(c_detailed_action)
	result.P = ret.Pointer()
	return
}

// g_menu_item_new_from_model
// container is not nil, container is MenuItem
// is constructor
func NewMenuItemFromModel(model IMenuModel, item_index int32) (result MenuItem) {
	iv, err := _I.Get(897, "MenuItem", "new_from_model")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if model != nil {
		tmp = model.P_MenuModel()
	}
	arg_model := gi.NewPointerArgument(tmp)
	arg_item_index := gi.NewInt32Argument(item_index)
	args := []gi.Argument{arg_model, arg_item_index}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_menu_item_new_section
// container is not nil, container is MenuItem
// is constructor
func NewMenuItemSection(label string, section IMenuModel) (result MenuItem) {
	iv, err := _I.Get(898, "MenuItem", "new_section")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_label := gi.CString(label)
	var tmp unsafe.Pointer
	if section != nil {
		tmp = section.P_MenuModel()
	}
	arg_label := gi.NewStringArgument(c_label)
	arg_section := gi.NewPointerArgument(tmp)
	args := []gi.Argument{arg_label, arg_section}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_label)
	result.P = ret.Pointer()
	return
}

// g_menu_item_new_submenu
// container is not nil, container is MenuItem
// is constructor
func NewMenuItemSubmenu(label string, submenu IMenuModel) (result MenuItem) {
	iv, err := _I.Get(899, "MenuItem", "new_submenu")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_label := gi.CString(label)
	var tmp unsafe.Pointer
	if submenu != nil {
		tmp = submenu.P_MenuModel()
	}
	arg_label := gi.NewStringArgument(c_label)
	arg_submenu := gi.NewPointerArgument(tmp)
	args := []gi.Argument{arg_label, arg_submenu}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_label)
	result.P = ret.Pointer()
	return
}

// g_menu_item_get_attribute_value
// container is not nil, container is MenuItem
// is method
func (v MenuItem) GetAttributeValue(attribute string, expected_type glib.VariantType) (result glib.Variant) {
	iv, err := _I.Get(900, "MenuItem", "get_attribute_value")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_attribute := gi.CString(attribute)
	arg_v := gi.NewPointerArgument(v.P)
	arg_attribute := gi.NewStringArgument(c_attribute)
	arg_expected_type := gi.NewPointerArgument(expected_type.P)
	args := []gi.Argument{arg_v, arg_attribute, arg_expected_type}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_attribute)
	result.P = ret.Pointer()
	return
}

// g_menu_item_get_link
// container is not nil, container is MenuItem
// is method
func (v MenuItem) GetLink(link string) (result MenuModel) {
	iv, err := _I.Get(901, "MenuItem", "get_link")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_link := gi.CString(link)
	arg_v := gi.NewPointerArgument(v.P)
	arg_link := gi.NewStringArgument(c_link)
	args := []gi.Argument{arg_v, arg_link}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_link)
	result.P = ret.Pointer()
	return
}

// g_menu_item_set_action_and_target_value
// container is not nil, container is MenuItem
// is method
func (v MenuItem) SetActionAndTargetValue(action string, target_value glib.Variant) {
	iv, err := _I.Get(902, "MenuItem", "set_action_and_target_value")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_action := gi.CString(action)
	arg_v := gi.NewPointerArgument(v.P)
	arg_action := gi.NewStringArgument(c_action)
	arg_target_value := gi.NewPointerArgument(target_value.P)
	args := []gi.Argument{arg_v, arg_action, arg_target_value}
	iv.Call(args, nil, nil)
	gi.Free(c_action)
}

// g_menu_item_set_attribute_value
// container is not nil, container is MenuItem
// is method
func (v MenuItem) SetAttributeValue(attribute string, value glib.Variant) {
	iv, err := _I.Get(903, "MenuItem", "set_attribute_value")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_attribute := gi.CString(attribute)
	arg_v := gi.NewPointerArgument(v.P)
	arg_attribute := gi.NewStringArgument(c_attribute)
	arg_value := gi.NewPointerArgument(value.P)
	args := []gi.Argument{arg_v, arg_attribute, arg_value}
	iv.Call(args, nil, nil)
	gi.Free(c_attribute)
}

// g_menu_item_set_detailed_action
// container is not nil, container is MenuItem
// is method
func (v MenuItem) SetDetailedAction(detailed_action string) {
	iv, err := _I.Get(904, "MenuItem", "set_detailed_action")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_detailed_action := gi.CString(detailed_action)
	arg_v := gi.NewPointerArgument(v.P)
	arg_detailed_action := gi.NewStringArgument(c_detailed_action)
	args := []gi.Argument{arg_v, arg_detailed_action}
	iv.Call(args, nil, nil)
	gi.Free(c_detailed_action)
}

// g_menu_item_set_icon
// container is not nil, container is MenuItem
// is method
func (v MenuItem) SetIcon(icon IIcon) {
	iv, err := _I.Get(905, "MenuItem", "set_icon")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if icon != nil {
		tmp = icon.P_Icon()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_icon := gi.NewPointerArgument(tmp)
	args := []gi.Argument{arg_v, arg_icon}
	iv.Call(args, nil, nil)
}

// g_menu_item_set_label
// container is not nil, container is MenuItem
// is method
func (v MenuItem) SetLabel(label string) {
	iv, err := _I.Get(906, "MenuItem", "set_label")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_label := gi.CString(label)
	arg_v := gi.NewPointerArgument(v.P)
	arg_label := gi.NewStringArgument(c_label)
	args := []gi.Argument{arg_v, arg_label}
	iv.Call(args, nil, nil)
	gi.Free(c_label)
}

// g_menu_item_set_link
// container is not nil, container is MenuItem
// is method
func (v MenuItem) SetLink(link string, model IMenuModel) {
	iv, err := _I.Get(907, "MenuItem", "set_link")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_link := gi.CString(link)
	var tmp unsafe.Pointer
	if model != nil {
		tmp = model.P_MenuModel()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_link := gi.NewStringArgument(c_link)
	arg_model := gi.NewPointerArgument(tmp)
	args := []gi.Argument{arg_v, arg_link, arg_model}
	iv.Call(args, nil, nil)
	gi.Free(c_link)
}

// g_menu_item_set_section
// container is not nil, container is MenuItem
// is method
func (v MenuItem) SetSection(section IMenuModel) {
	iv, err := _I.Get(908, "MenuItem", "set_section")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if section != nil {
		tmp = section.P_MenuModel()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_section := gi.NewPointerArgument(tmp)
	args := []gi.Argument{arg_v, arg_section}
	iv.Call(args, nil, nil)
}

// g_menu_item_set_submenu
// container is not nil, container is MenuItem
// is method
func (v MenuItem) SetSubmenu(submenu IMenuModel) {
	iv, err := _I.Get(909, "MenuItem", "set_submenu")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if submenu != nil {
		tmp = submenu.P_MenuModel()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_submenu := gi.NewPointerArgument(tmp)
	args := []gi.Argument{arg_v, arg_submenu}
	iv.Call(args, nil, nil)
}

// Object MenuLinkIter
type MenuLinkIter struct {
	gobject.Object
}

func WrapMenuLinkIter(p unsafe.Pointer) (r MenuLinkIter) { r.P = p; return }

type IMenuLinkIter interface{ P_MenuLinkIter() unsafe.Pointer }

func (v MenuLinkIter) P_MenuLinkIter() unsafe.Pointer { return v.P }
func MenuLinkIterGetType() gi.GType {
	ret := _I.GetGType(169, "MenuLinkIter")
	return ret
}

// g_menu_link_iter_get_name
// container is not nil, container is MenuLinkIter
// is method
func (v MenuLinkIter) GetName() (result string) {
	iv, err := _I.Get(910, "MenuLinkIter", "get_name")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Take()
	return
}

// g_menu_link_iter_get_next
// container is not nil, container is MenuLinkIter
// is method
func (v MenuLinkIter) GetNext() (result bool, out_link string, value MenuModel) {
	iv, err := _I.Get(911, "MenuLinkIter", "get_next")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var outArgs [2]gi.Argument
	arg_v := gi.NewPointerArgument(v.P)
	arg_out_link := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	arg_value := gi.NewPointerArgument(unsafe.Pointer(&outArgs[1]))
	args := []gi.Argument{arg_v, arg_out_link, arg_value}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	out_link = outArgs[0].String().Take()
	value.P = outArgs[1].Pointer()
	result = ret.Bool()
	return
}

// g_menu_link_iter_get_value
// container is not nil, container is MenuLinkIter
// is method
func (v MenuLinkIter) GetValue() (result MenuModel) {
	iv, err := _I.Get(912, "MenuLinkIter", "get_value")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_menu_link_iter_next
// container is not nil, container is MenuLinkIter
// is method
func (v MenuLinkIter) Next() (result bool) {
	iv, err := _I.Get(913, "MenuLinkIter", "next")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// ignore GType struct MenuLinkIterClass
// Struct MenuLinkIterPrivate
type MenuLinkIterPrivate struct {
	P unsafe.Pointer
}

func MenuLinkIterPrivateGetType() gi.GType {
	ret := _I.GetGType(170, "MenuLinkIterPrivate")
	return ret
}

// Object MenuModel
type MenuModel struct {
	gobject.Object
}

func WrapMenuModel(p unsafe.Pointer) (r MenuModel) { r.P = p; return }

type IMenuModel interface{ P_MenuModel() unsafe.Pointer }

func (v MenuModel) P_MenuModel() unsafe.Pointer { return v.P }
func MenuModelGetType() gi.GType {
	ret := _I.GetGType(171, "MenuModel")
	return ret
}

// g_menu_model_get_item_attribute_value
// container is not nil, container is MenuModel
// is method
func (v MenuModel) GetItemAttributeValue(item_index int32, attribute string, expected_type glib.VariantType) (result glib.Variant) {
	iv, err := _I.Get(914, "MenuModel", "get_item_attribute_value")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_attribute := gi.CString(attribute)
	arg_v := gi.NewPointerArgument(v.P)
	arg_item_index := gi.NewInt32Argument(item_index)
	arg_attribute := gi.NewStringArgument(c_attribute)
	arg_expected_type := gi.NewPointerArgument(expected_type.P)
	args := []gi.Argument{arg_v, arg_item_index, arg_attribute, arg_expected_type}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_attribute)
	result.P = ret.Pointer()
	return
}

// g_menu_model_get_item_link
// container is not nil, container is MenuModel
// is method
func (v MenuModel) GetItemLink(item_index int32, link string) (result MenuModel) {
	iv, err := _I.Get(915, "MenuModel", "get_item_link")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_link := gi.CString(link)
	arg_v := gi.NewPointerArgument(v.P)
	arg_item_index := gi.NewInt32Argument(item_index)
	arg_link := gi.NewStringArgument(c_link)
	args := []gi.Argument{arg_v, arg_item_index, arg_link}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_link)
	result.P = ret.Pointer()
	return
}

// g_menu_model_get_n_items
// container is not nil, container is MenuModel
// is method
func (v MenuModel) GetNItems() (result int32) {
	iv, err := _I.Get(916, "MenuModel", "get_n_items")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Int32()
	return
}

// g_menu_model_is_mutable
// container is not nil, container is MenuModel
// is method
func (v MenuModel) IsMutable() (result bool) {
	iv, err := _I.Get(917, "MenuModel", "is_mutable")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_menu_model_items_changed
// container is not nil, container is MenuModel
// is method
func (v MenuModel) ItemsChanged(position int32, removed int32, added int32) {
	iv, err := _I.Get(918, "MenuModel", "items_changed")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_position := gi.NewInt32Argument(position)
	arg_removed := gi.NewInt32Argument(removed)
	arg_added := gi.NewInt32Argument(added)
	args := []gi.Argument{arg_v, arg_position, arg_removed, arg_added}
	iv.Call(args, nil, nil)
}

// g_menu_model_iterate_item_attributes
// container is not nil, container is MenuModel
// is method
func (v MenuModel) IterateItemAttributes(item_index int32) (result MenuAttributeIter) {
	iv, err := _I.Get(919, "MenuModel", "iterate_item_attributes")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_item_index := gi.NewInt32Argument(item_index)
	args := []gi.Argument{arg_v, arg_item_index}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_menu_model_iterate_item_links
// container is not nil, container is MenuModel
// is method
func (v MenuModel) IterateItemLinks(item_index int32) (result MenuLinkIter) {
	iv, err := _I.Get(920, "MenuModel", "iterate_item_links")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_item_index := gi.NewInt32Argument(item_index)
	args := []gi.Argument{arg_v, arg_item_index}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// ignore GType struct MenuModelClass
// Struct MenuModelPrivate
type MenuModelPrivate struct {
	P unsafe.Pointer
}

func MenuModelPrivateGetType() gi.GType {
	ret := _I.GetGType(172, "MenuModelPrivate")
	return ret
}

// Interface Mount
type Mount struct {
	MountIfc
	P unsafe.Pointer
}
type MountIfc struct{}
type IMount interface{ P_Mount() unsafe.Pointer }

func (v Mount) P_Mount() unsafe.Pointer { return v.P }
func MountGetType() gi.GType {
	ret := _I.GetGType(173, "Mount")
	return ret
}

// g_mount_can_eject
// container is not nil, container is Mount
// is method
func (v *MountIfc) CanEject() (result bool) {
	iv, err := _I.Get(921, "Mount", "can_eject")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_mount_can_unmount
// container is not nil, container is Mount
// is method
func (v *MountIfc) CanUnmount() (result bool) {
	iv, err := _I.Get(922, "Mount", "can_unmount")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_mount_eject
// container is not nil, container is Mount
// is method
func (v *MountIfc) Eject(flags MountUnmountFlags, cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(923, "Mount", "eject")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_flags := gi.NewIntArgument(int(flags))
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_v, arg_flags, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
}

// g_mount_eject_finish
// container is not nil, container is Mount
// is method
func (v *MountIfc) EjectFinish(result IAsyncResult) (result1 bool, err error) {
	iv, err := _I.Get(924, "Mount", "eject_finish")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if result != nil {
		tmp = result.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_result := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_result, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result1 = ret.Bool()
	return
}

// g_mount_eject_with_operation
// container is not nil, container is Mount
// is method
func (v *MountIfc) EjectWithOperation(flags MountUnmountFlags, mount_operation IMountOperation, cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(925, "Mount", "eject_with_operation")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if mount_operation != nil {
		tmp = mount_operation.P_MountOperation()
	}
	var tmp1 unsafe.Pointer
	if cancellable != nil {
		tmp1 = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_flags := gi.NewIntArgument(int(flags))
	arg_mount_operation := gi.NewPointerArgument(tmp)
	arg_cancellable := gi.NewPointerArgument(tmp1)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_v, arg_flags, arg_mount_operation, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
}

// g_mount_eject_with_operation_finish
// container is not nil, container is Mount
// is method
func (v *MountIfc) EjectWithOperationFinish(result IAsyncResult) (result1 bool, err error) {
	iv, err := _I.Get(926, "Mount", "eject_with_operation_finish")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if result != nil {
		tmp = result.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_result := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_result, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result1 = ret.Bool()
	return
}

// g_mount_get_default_location
// container is not nil, container is Mount
// is method
func (v *MountIfc) GetDefaultLocation() (result File) {
	iv, err := _I.Get(927, "Mount", "get_default_location")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_mount_get_drive
// container is not nil, container is Mount
// is method
func (v *MountIfc) GetDrive() (result Drive) {
	iv, err := _I.Get(928, "Mount", "get_drive")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_mount_get_icon
// container is not nil, container is Mount
// is method
func (v *MountIfc) GetIcon() (result Icon) {
	iv, err := _I.Get(929, "Mount", "get_icon")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_mount_get_name
// container is not nil, container is Mount
// is method
func (v *MountIfc) GetName() (result string) {
	iv, err := _I.Get(930, "Mount", "get_name")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Take()
	return
}

// g_mount_get_root
// container is not nil, container is Mount
// is method
func (v *MountIfc) GetRoot() (result File) {
	iv, err := _I.Get(931, "Mount", "get_root")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_mount_get_sort_key
// container is not nil, container is Mount
// is method
func (v *MountIfc) GetSortKey() (result string) {
	iv, err := _I.Get(932, "Mount", "get_sort_key")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Take()
	return
}

// g_mount_get_symbolic_icon
// container is not nil, container is Mount
// is method
func (v *MountIfc) GetSymbolicIcon() (result Icon) {
	iv, err := _I.Get(933, "Mount", "get_symbolic_icon")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_mount_get_uuid
// container is not nil, container is Mount
// is method
func (v *MountIfc) GetUuid() (result string) {
	iv, err := _I.Get(934, "Mount", "get_uuid")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Take()
	return
}

// g_mount_get_volume
// container is not nil, container is Mount
// is method
func (v *MountIfc) GetVolume() (result Volume) {
	iv, err := _I.Get(935, "Mount", "get_volume")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_mount_guess_content_type
// container is not nil, container is Mount
// is method
func (v *MountIfc) GuessContentType(force_rescan bool, cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(936, "Mount", "guess_content_type")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_force_rescan := gi.NewBoolArgument(force_rescan)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_v, arg_force_rescan, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
}

// g_mount_guess_content_type_finish
// container is not nil, container is Mount
// is method
func (v *MountIfc) GuessContentTypeFinish(result IAsyncResult) (result1 gi.CStrArray, err error) {
	iv, err := _I.Get(937, "Mount", "guess_content_type_finish")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if result != nil {
		tmp = result.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_result := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_result, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result1 = gi.CStrArray{P: ret.Pointer(), Len: -1}
	result1.SetLenZT()
	return
}

// g_mount_guess_content_type_sync
// container is not nil, container is Mount
// is method
func (v *MountIfc) GuessContentTypeSync(force_rescan bool, cancellable ICancellable) (result gi.CStrArray, err error) {
	iv, err := _I.Get(938, "Mount", "guess_content_type_sync")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_force_rescan := gi.NewBoolArgument(force_rescan)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_force_rescan, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = gi.CStrArray{P: ret.Pointer(), Len: -1}
	result.SetLenZT()
	return
}

// g_mount_is_shadowed
// container is not nil, container is Mount
// is method
func (v *MountIfc) IsShadowed() (result bool) {
	iv, err := _I.Get(939, "Mount", "is_shadowed")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_mount_remount
// container is not nil, container is Mount
// is method
func (v *MountIfc) Remount(flags MountMountFlags, mount_operation IMountOperation, cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(940, "Mount", "remount")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if mount_operation != nil {
		tmp = mount_operation.P_MountOperation()
	}
	var tmp1 unsafe.Pointer
	if cancellable != nil {
		tmp1 = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_flags := gi.NewIntArgument(int(flags))
	arg_mount_operation := gi.NewPointerArgument(tmp)
	arg_cancellable := gi.NewPointerArgument(tmp1)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_v, arg_flags, arg_mount_operation, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
}

// g_mount_remount_finish
// container is not nil, container is Mount
// is method
func (v *MountIfc) RemountFinish(result IAsyncResult) (result1 bool, err error) {
	iv, err := _I.Get(941, "Mount", "remount_finish")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if result != nil {
		tmp = result.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_result := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_result, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result1 = ret.Bool()
	return
}

// g_mount_shadow
// container is not nil, container is Mount
// is method
func (v *MountIfc) Shadow() {
	iv, err := _I.Get(942, "Mount", "shadow")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	iv.Call(args, nil, nil)
}

// g_mount_unmount
// container is not nil, container is Mount
// is method
func (v *MountIfc) Unmount(flags MountUnmountFlags, cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(943, "Mount", "unmount")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_flags := gi.NewIntArgument(int(flags))
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_v, arg_flags, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
}

// g_mount_unmount_finish
// container is not nil, container is Mount
// is method
func (v *MountIfc) UnmountFinish(result IAsyncResult) (result1 bool, err error) {
	iv, err := _I.Get(944, "Mount", "unmount_finish")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if result != nil {
		tmp = result.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_result := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_result, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result1 = ret.Bool()
	return
}

// g_mount_unmount_with_operation
// container is not nil, container is Mount
// is method
func (v *MountIfc) UnmountWithOperation(flags MountUnmountFlags, mount_operation IMountOperation, cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(945, "Mount", "unmount_with_operation")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if mount_operation != nil {
		tmp = mount_operation.P_MountOperation()
	}
	var tmp1 unsafe.Pointer
	if cancellable != nil {
		tmp1 = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_flags := gi.NewIntArgument(int(flags))
	arg_mount_operation := gi.NewPointerArgument(tmp)
	arg_cancellable := gi.NewPointerArgument(tmp1)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_v, arg_flags, arg_mount_operation, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
}

// g_mount_unmount_with_operation_finish
// container is not nil, container is Mount
// is method
func (v *MountIfc) UnmountWithOperationFinish(result IAsyncResult) (result1 bool, err error) {
	iv, err := _I.Get(946, "Mount", "unmount_with_operation_finish")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if result != nil {
		tmp = result.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_result := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_result, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result1 = ret.Bool()
	return
}

// g_mount_unshadow
// container is not nil, container is Mount
// is method
func (v *MountIfc) Unshadow() {
	iv, err := _I.Get(947, "Mount", "unshadow")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	iv.Call(args, nil, nil)
}

// ignore GType struct MountIface
// Flags MountMountFlags
type MountMountFlags int

const (
	MountMountFlagsNone MountMountFlags = 0
)

func MountMountFlagsGetType() gi.GType {
	ret := _I.GetGType(174, "MountMountFlags")
	return ret
}

// Object MountOperation
type MountOperation struct {
	gobject.Object
}

func WrapMountOperation(p unsafe.Pointer) (r MountOperation) { r.P = p; return }

type IMountOperation interface{ P_MountOperation() unsafe.Pointer }

func (v MountOperation) P_MountOperation() unsafe.Pointer { return v.P }
func MountOperationGetType() gi.GType {
	ret := _I.GetGType(175, "MountOperation")
	return ret
}

// g_mount_operation_new
// container is not nil, container is MountOperation
// is constructor
func NewMountOperation() (result MountOperation) {
	iv, err := _I.Get(948, "MountOperation", "new")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var ret gi.Argument
	iv.Call(nil, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_mount_operation_get_anonymous
// container is not nil, container is MountOperation
// is method
func (v MountOperation) GetAnonymous() (result bool) {
	iv, err := _I.Get(949, "MountOperation", "get_anonymous")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_mount_operation_get_choice
// container is not nil, container is MountOperation
// is method
func (v MountOperation) GetChoice() (result int32) {
	iv, err := _I.Get(950, "MountOperation", "get_choice")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Int32()
	return
}

// g_mount_operation_get_domain
// container is not nil, container is MountOperation
// is method
func (v MountOperation) GetDomain() (result string) {
	iv, err := _I.Get(951, "MountOperation", "get_domain")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Take()
	return
}

// g_mount_operation_get_is_tcrypt_hidden_volume
// container is not nil, container is MountOperation
// is method
func (v MountOperation) GetIsTcryptHiddenVolume() (result bool) {
	iv, err := _I.Get(952, "MountOperation", "get_is_tcrypt_hidden_volume")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_mount_operation_get_is_tcrypt_system_volume
// container is not nil, container is MountOperation
// is method
func (v MountOperation) GetIsTcryptSystemVolume() (result bool) {
	iv, err := _I.Get(953, "MountOperation", "get_is_tcrypt_system_volume")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_mount_operation_get_password
// container is not nil, container is MountOperation
// is method
func (v MountOperation) GetPassword() (result string) {
	iv, err := _I.Get(954, "MountOperation", "get_password")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Take()
	return
}

// g_mount_operation_get_password_save
// container is not nil, container is MountOperation
// is method
func (v MountOperation) GetPasswordSave() (result PasswordSaveEnum) {
	iv, err := _I.Get(955, "MountOperation", "get_password_save")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = PasswordSaveEnum(ret.Int())
	return
}

// g_mount_operation_get_pim
// container is not nil, container is MountOperation
// is method
func (v MountOperation) GetPim() (result uint32) {
	iv, err := _I.Get(956, "MountOperation", "get_pim")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Uint32()
	return
}

// g_mount_operation_get_username
// container is not nil, container is MountOperation
// is method
func (v MountOperation) GetUsername() (result string) {
	iv, err := _I.Get(957, "MountOperation", "get_username")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Take()
	return
}

// g_mount_operation_reply
// container is not nil, container is MountOperation
// is method
func (v MountOperation) Reply(result MountOperationResultEnum) {
	iv, err := _I.Get(958, "MountOperation", "reply")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_result := gi.NewIntArgument(int(result))
	args := []gi.Argument{arg_v, arg_result}
	iv.Call(args, nil, nil)
}

// g_mount_operation_set_anonymous
// container is not nil, container is MountOperation
// is method
func (v MountOperation) SetAnonymous(anonymous bool) {
	iv, err := _I.Get(959, "MountOperation", "set_anonymous")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_anonymous := gi.NewBoolArgument(anonymous)
	args := []gi.Argument{arg_v, arg_anonymous}
	iv.Call(args, nil, nil)
}

// g_mount_operation_set_choice
// container is not nil, container is MountOperation
// is method
func (v MountOperation) SetChoice(choice int32) {
	iv, err := _I.Get(960, "MountOperation", "set_choice")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_choice := gi.NewInt32Argument(choice)
	args := []gi.Argument{arg_v, arg_choice}
	iv.Call(args, nil, nil)
}

// g_mount_operation_set_domain
// container is not nil, container is MountOperation
// is method
func (v MountOperation) SetDomain(domain string) {
	iv, err := _I.Get(961, "MountOperation", "set_domain")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_domain := gi.CString(domain)
	arg_v := gi.NewPointerArgument(v.P)
	arg_domain := gi.NewStringArgument(c_domain)
	args := []gi.Argument{arg_v, arg_domain}
	iv.Call(args, nil, nil)
	gi.Free(c_domain)
}

// g_mount_operation_set_is_tcrypt_hidden_volume
// container is not nil, container is MountOperation
// is method
func (v MountOperation) SetIsTcryptHiddenVolume(hidden_volume bool) {
	iv, err := _I.Get(962, "MountOperation", "set_is_tcrypt_hidden_volume")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_hidden_volume := gi.NewBoolArgument(hidden_volume)
	args := []gi.Argument{arg_v, arg_hidden_volume}
	iv.Call(args, nil, nil)
}

// g_mount_operation_set_is_tcrypt_system_volume
// container is not nil, container is MountOperation
// is method
func (v MountOperation) SetIsTcryptSystemVolume(system_volume bool) {
	iv, err := _I.Get(963, "MountOperation", "set_is_tcrypt_system_volume")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_system_volume := gi.NewBoolArgument(system_volume)
	args := []gi.Argument{arg_v, arg_system_volume}
	iv.Call(args, nil, nil)
}

// g_mount_operation_set_password
// container is not nil, container is MountOperation
// is method
func (v MountOperation) SetPassword(password string) {
	iv, err := _I.Get(964, "MountOperation", "set_password")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_password := gi.CString(password)
	arg_v := gi.NewPointerArgument(v.P)
	arg_password := gi.NewStringArgument(c_password)
	args := []gi.Argument{arg_v, arg_password}
	iv.Call(args, nil, nil)
	gi.Free(c_password)
}

// g_mount_operation_set_password_save
// container is not nil, container is MountOperation
// is method
func (v MountOperation) SetPasswordSave(save PasswordSaveEnum) {
	iv, err := _I.Get(965, "MountOperation", "set_password_save")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_save := gi.NewIntArgument(int(save))
	args := []gi.Argument{arg_v, arg_save}
	iv.Call(args, nil, nil)
}

// g_mount_operation_set_pim
// container is not nil, container is MountOperation
// is method
func (v MountOperation) SetPim(pim uint32) {
	iv, err := _I.Get(966, "MountOperation", "set_pim")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_pim := gi.NewUint32Argument(pim)
	args := []gi.Argument{arg_v, arg_pim}
	iv.Call(args, nil, nil)
}

// g_mount_operation_set_username
// container is not nil, container is MountOperation
// is method
func (v MountOperation) SetUsername(username string) {
	iv, err := _I.Get(967, "MountOperation", "set_username")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_username := gi.CString(username)
	arg_v := gi.NewPointerArgument(v.P)
	arg_username := gi.NewStringArgument(c_username)
	args := []gi.Argument{arg_v, arg_username}
	iv.Call(args, nil, nil)
	gi.Free(c_username)
}

// ignore GType struct MountOperationClass
// Struct MountOperationPrivate
type MountOperationPrivate struct {
	P unsafe.Pointer
}

func MountOperationPrivateGetType() gi.GType {
	ret := _I.GetGType(176, "MountOperationPrivate")
	return ret
}

// Enum MountOperationResult
type MountOperationResultEnum int

const (
	MountOperationResultHandled   MountOperationResultEnum = 0
	MountOperationResultAborted   MountOperationResultEnum = 1
	MountOperationResultUnhandled MountOperationResultEnum = 2
)

func MountOperationResultGetType() gi.GType {
	ret := _I.GetGType(177, "MountOperationResult")
	return ret
}

// Flags MountUnmountFlags
type MountUnmountFlags int

const (
	MountUnmountFlagsNone  MountUnmountFlags = 0
	MountUnmountFlagsForce MountUnmountFlags = 1
)

func MountUnmountFlagsGetType() gi.GType {
	ret := _I.GetGType(178, "MountUnmountFlags")
	return ret
}

// Struct NativeSocketAddress
type NativeSocketAddress struct {
	P unsafe.Pointer
}

func NativeSocketAddressGetType() gi.GType {
	ret := _I.GetGType(179, "NativeSocketAddress")
	return ret
}

// Object NativeVolumeMonitor
type NativeVolumeMonitor struct {
	VolumeMonitor
}

func WrapNativeVolumeMonitor(p unsafe.Pointer) (r NativeVolumeMonitor) { r.P = p; return }

type INativeVolumeMonitor interface{ P_NativeVolumeMonitor() unsafe.Pointer }

func (v NativeVolumeMonitor) P_NativeVolumeMonitor() unsafe.Pointer { return v.P }
func NativeVolumeMonitorGetType() gi.GType {
	ret := _I.GetGType(180, "NativeVolumeMonitor")
	return ret
}

// ignore GType struct NativeVolumeMonitorClass
// Object NetworkAddress
type NetworkAddress struct {
	SocketConnectableIfc
	gobject.Object
}

func WrapNetworkAddress(p unsafe.Pointer) (r NetworkAddress) { r.P = p; return }

type INetworkAddress interface{ P_NetworkAddress() unsafe.Pointer }

func (v NetworkAddress) P_NetworkAddress() unsafe.Pointer    { return v.P }
func (v NetworkAddress) P_SocketConnectable() unsafe.Pointer { return v.P }
func NetworkAddressGetType() gi.GType {
	ret := _I.GetGType(181, "NetworkAddress")
	return ret
}

// g_network_address_new
// container is not nil, container is NetworkAddress
// is constructor
func NewNetworkAddress(hostname string, port uint16) (result NetworkAddress) {
	iv, err := _I.Get(968, "NetworkAddress", "new")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_hostname := gi.CString(hostname)
	arg_hostname := gi.NewStringArgument(c_hostname)
	arg_port := gi.NewUint16Argument(port)
	args := []gi.Argument{arg_hostname, arg_port}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_hostname)
	result.P = ret.Pointer()
	return
}

// g_network_address_new_loopback
// container is not nil, container is NetworkAddress
// is constructor
func NewNetworkAddressLoopback(port uint16) (result NetworkAddress) {
	iv, err := _I.Get(969, "NetworkAddress", "new_loopback")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_port := gi.NewUint16Argument(port)
	args := []gi.Argument{arg_port}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_network_address_parse
// container is not nil, container is NetworkAddress
// is method
// arg0Type tag: utf8, isPtr: true
func NetworkAddressParse1(host_and_port string, default_port uint16) (result NetworkAddress, err error) {
	iv, err := _I.Get(970, "NetworkAddress", "parse")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	c_host_and_port := gi.CString(host_and_port)
	arg_host_and_port := gi.NewStringArgument(c_host_and_port)
	arg_default_port := gi.NewUint16Argument(default_port)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_host_and_port, arg_default_port, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	gi.Free(c_host_and_port)
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// g_network_address_parse_uri
// container is not nil, container is NetworkAddress
// is method
// arg0Type tag: utf8, isPtr: true
func NetworkAddressParseUri1(uri string, default_port uint16) (result NetworkAddress, err error) {
	iv, err := _I.Get(971, "NetworkAddress", "parse_uri")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	c_uri := gi.CString(uri)
	arg_uri := gi.NewStringArgument(c_uri)
	arg_default_port := gi.NewUint16Argument(default_port)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_uri, arg_default_port, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	gi.Free(c_uri)
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// g_network_address_get_hostname
// container is not nil, container is NetworkAddress
// is method
func (v NetworkAddress) GetHostname() (result string) {
	iv, err := _I.Get(972, "NetworkAddress", "get_hostname")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Take()
	return
}

// g_network_address_get_port
// container is not nil, container is NetworkAddress
// is method
func (v NetworkAddress) GetPort() (result uint16) {
	iv, err := _I.Get(973, "NetworkAddress", "get_port")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Uint16()
	return
}

// g_network_address_get_scheme
// container is not nil, container is NetworkAddress
// is method
func (v NetworkAddress) GetScheme() (result string) {
	iv, err := _I.Get(974, "NetworkAddress", "get_scheme")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Take()
	return
}

// ignore GType struct NetworkAddressClass
// Struct NetworkAddressPrivate
type NetworkAddressPrivate struct {
	P unsafe.Pointer
}

func NetworkAddressPrivateGetType() gi.GType {
	ret := _I.GetGType(182, "NetworkAddressPrivate")
	return ret
}

// Enum NetworkConnectivity
type NetworkConnectivityEnum int

const (
	NetworkConnectivityLocal   NetworkConnectivityEnum = 1
	NetworkConnectivityLimited NetworkConnectivityEnum = 2
	NetworkConnectivityPortal  NetworkConnectivityEnum = 3
	NetworkConnectivityFull    NetworkConnectivityEnum = 4
)

func NetworkConnectivityGetType() gi.GType {
	ret := _I.GetGType(183, "NetworkConnectivity")
	return ret
}

// Interface NetworkMonitor
type NetworkMonitor struct {
	NetworkMonitorIfc
	P unsafe.Pointer
}
type NetworkMonitorIfc struct{}
type INetworkMonitor interface{ P_NetworkMonitor() unsafe.Pointer }

func (v NetworkMonitor) P_NetworkMonitor() unsafe.Pointer { return v.P }
func NetworkMonitorGetType() gi.GType {
	ret := _I.GetGType(184, "NetworkMonitor")
	return ret
}

// g_network_monitor_can_reach
// container is not nil, container is NetworkMonitor
// is method
func (v *NetworkMonitorIfc) CanReach(connectable ISocketConnectable, cancellable ICancellable) (result bool, err error) {
	iv, err := _I.Get(976, "NetworkMonitor", "can_reach")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if connectable != nil {
		tmp = connectable.P_SocketConnectable()
	}
	var tmp1 unsafe.Pointer
	if cancellable != nil {
		tmp1 = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_connectable := gi.NewPointerArgument(tmp)
	arg_cancellable := gi.NewPointerArgument(tmp1)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_connectable, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Bool()
	return
}

// g_network_monitor_can_reach_async
// container is not nil, container is NetworkMonitor
// is method
func (v *NetworkMonitorIfc) CanReachAsync(connectable ISocketConnectable, cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(977, "NetworkMonitor", "can_reach_async")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if connectable != nil {
		tmp = connectable.P_SocketConnectable()
	}
	var tmp1 unsafe.Pointer
	if cancellable != nil {
		tmp1 = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_connectable := gi.NewPointerArgument(tmp)
	arg_cancellable := gi.NewPointerArgument(tmp1)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_v, arg_connectable, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
}

// g_network_monitor_can_reach_finish
// container is not nil, container is NetworkMonitor
// is method
func (v *NetworkMonitorIfc) CanReachFinish(result IAsyncResult) (result1 bool, err error) {
	iv, err := _I.Get(978, "NetworkMonitor", "can_reach_finish")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if result != nil {
		tmp = result.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_result := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_result, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result1 = ret.Bool()
	return
}

// g_network_monitor_get_connectivity
// container is not nil, container is NetworkMonitor
// is method
func (v *NetworkMonitorIfc) GetConnectivity() (result NetworkConnectivityEnum) {
	iv, err := _I.Get(979, "NetworkMonitor", "get_connectivity")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = NetworkConnectivityEnum(ret.Int())
	return
}

// g_network_monitor_get_network_available
// container is not nil, container is NetworkMonitor
// is method
func (v *NetworkMonitorIfc) GetNetworkAvailable() (result bool) {
	iv, err := _I.Get(980, "NetworkMonitor", "get_network_available")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_network_monitor_get_network_metered
// container is not nil, container is NetworkMonitor
// is method
func (v *NetworkMonitorIfc) GetNetworkMetered() (result bool) {
	iv, err := _I.Get(981, "NetworkMonitor", "get_network_metered")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// ignore GType struct NetworkMonitorInterface
// Object NetworkService
type NetworkService struct {
	SocketConnectableIfc
	gobject.Object
}

func WrapNetworkService(p unsafe.Pointer) (r NetworkService) { r.P = p; return }

type INetworkService interface{ P_NetworkService() unsafe.Pointer }

func (v NetworkService) P_NetworkService() unsafe.Pointer    { return v.P }
func (v NetworkService) P_SocketConnectable() unsafe.Pointer { return v.P }
func NetworkServiceGetType() gi.GType {
	ret := _I.GetGType(185, "NetworkService")
	return ret
}

// g_network_service_new
// container is not nil, container is NetworkService
// is constructor
func NewNetworkService(service string, protocol string, domain string) (result NetworkService) {
	iv, err := _I.Get(982, "NetworkService", "new")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_service := gi.CString(service)
	c_protocol := gi.CString(protocol)
	c_domain := gi.CString(domain)
	arg_service := gi.NewStringArgument(c_service)
	arg_protocol := gi.NewStringArgument(c_protocol)
	arg_domain := gi.NewStringArgument(c_domain)
	args := []gi.Argument{arg_service, arg_protocol, arg_domain}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_service)
	gi.Free(c_protocol)
	gi.Free(c_domain)
	result.P = ret.Pointer()
	return
}

// g_network_service_get_domain
// container is not nil, container is NetworkService
// is method
func (v NetworkService) GetDomain() (result string) {
	iv, err := _I.Get(983, "NetworkService", "get_domain")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Take()
	return
}

// g_network_service_get_protocol
// container is not nil, container is NetworkService
// is method
func (v NetworkService) GetProtocol() (result string) {
	iv, err := _I.Get(984, "NetworkService", "get_protocol")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Take()
	return
}

// g_network_service_get_scheme
// container is not nil, container is NetworkService
// is method
func (v NetworkService) GetScheme() (result string) {
	iv, err := _I.Get(985, "NetworkService", "get_scheme")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Take()
	return
}

// g_network_service_get_service
// container is not nil, container is NetworkService
// is method
func (v NetworkService) GetService() (result string) {
	iv, err := _I.Get(986, "NetworkService", "get_service")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Take()
	return
}

// g_network_service_set_scheme
// container is not nil, container is NetworkService
// is method
func (v NetworkService) SetScheme(scheme string) {
	iv, err := _I.Get(987, "NetworkService", "set_scheme")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_scheme := gi.CString(scheme)
	arg_v := gi.NewPointerArgument(v.P)
	arg_scheme := gi.NewStringArgument(c_scheme)
	args := []gi.Argument{arg_v, arg_scheme}
	iv.Call(args, nil, nil)
	gi.Free(c_scheme)
}

// ignore GType struct NetworkServiceClass
// Struct NetworkServicePrivate
type NetworkServicePrivate struct {
	P unsafe.Pointer
}

func NetworkServicePrivateGetType() gi.GType {
	ret := _I.GetGType(186, "NetworkServicePrivate")
	return ret
}

// Object Notification
type Notification struct {
	gobject.Object
}

func WrapNotification(p unsafe.Pointer) (r Notification) { r.P = p; return }

type INotification interface{ P_Notification() unsafe.Pointer }

func (v Notification) P_Notification() unsafe.Pointer { return v.P }
func NotificationGetType() gi.GType {
	ret := _I.GetGType(187, "Notification")
	return ret
}

// g_notification_new
// container is not nil, container is Notification
// is constructor
func NewNotification(title string) (result Notification) {
	iv, err := _I.Get(988, "Notification", "new")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_title := gi.CString(title)
	arg_title := gi.NewStringArgument(c_title)
	args := []gi.Argument{arg_title}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_title)
	result.P = ret.Pointer()
	return
}

// g_notification_add_button
// container is not nil, container is Notification
// is method
func (v Notification) AddButton(label string, detailed_action string) {
	iv, err := _I.Get(989, "Notification", "add_button")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_label := gi.CString(label)
	c_detailed_action := gi.CString(detailed_action)
	arg_v := gi.NewPointerArgument(v.P)
	arg_label := gi.NewStringArgument(c_label)
	arg_detailed_action := gi.NewStringArgument(c_detailed_action)
	args := []gi.Argument{arg_v, arg_label, arg_detailed_action}
	iv.Call(args, nil, nil)
	gi.Free(c_label)
	gi.Free(c_detailed_action)
}

// g_notification_add_button_with_target_value
// container is not nil, container is Notification
// is method
func (v Notification) AddButtonWithTarget(label string, action string, target glib.Variant) {
	iv, err := _I.Get(990, "Notification", "add_button_with_target")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_label := gi.CString(label)
	c_action := gi.CString(action)
	arg_v := gi.NewPointerArgument(v.P)
	arg_label := gi.NewStringArgument(c_label)
	arg_action := gi.NewStringArgument(c_action)
	arg_target := gi.NewPointerArgument(target.P)
	args := []gi.Argument{arg_v, arg_label, arg_action, arg_target}
	iv.Call(args, nil, nil)
	gi.Free(c_label)
	gi.Free(c_action)
}

// g_notification_set_body
// container is not nil, container is Notification
// is method
func (v Notification) SetBody(body string) {
	iv, err := _I.Get(991, "Notification", "set_body")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_body := gi.CString(body)
	arg_v := gi.NewPointerArgument(v.P)
	arg_body := gi.NewStringArgument(c_body)
	args := []gi.Argument{arg_v, arg_body}
	iv.Call(args, nil, nil)
	gi.Free(c_body)
}

// g_notification_set_default_action
// container is not nil, container is Notification
// is method
func (v Notification) SetDefaultAction(detailed_action string) {
	iv, err := _I.Get(992, "Notification", "set_default_action")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_detailed_action := gi.CString(detailed_action)
	arg_v := gi.NewPointerArgument(v.P)
	arg_detailed_action := gi.NewStringArgument(c_detailed_action)
	args := []gi.Argument{arg_v, arg_detailed_action}
	iv.Call(args, nil, nil)
	gi.Free(c_detailed_action)
}

// g_notification_set_default_action_and_target_value
// container is not nil, container is Notification
// is method
func (v Notification) SetDefaultActionAndTarget(action string, target glib.Variant) {
	iv, err := _I.Get(993, "Notification", "set_default_action_and_target")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_action := gi.CString(action)
	arg_v := gi.NewPointerArgument(v.P)
	arg_action := gi.NewStringArgument(c_action)
	arg_target := gi.NewPointerArgument(target.P)
	args := []gi.Argument{arg_v, arg_action, arg_target}
	iv.Call(args, nil, nil)
	gi.Free(c_action)
}

// g_notification_set_icon
// container is not nil, container is Notification
// is method
func (v Notification) SetIcon(icon IIcon) {
	iv, err := _I.Get(994, "Notification", "set_icon")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if icon != nil {
		tmp = icon.P_Icon()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_icon := gi.NewPointerArgument(tmp)
	args := []gi.Argument{arg_v, arg_icon}
	iv.Call(args, nil, nil)
}

// g_notification_set_priority
// container is not nil, container is Notification
// is method
func (v Notification) SetPriority(priority NotificationPriorityEnum) {
	iv, err := _I.Get(995, "Notification", "set_priority")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_priority := gi.NewIntArgument(int(priority))
	args := []gi.Argument{arg_v, arg_priority}
	iv.Call(args, nil, nil)
}

// g_notification_set_title
// container is not nil, container is Notification
// is method
func (v Notification) SetTitle(title string) {
	iv, err := _I.Get(996, "Notification", "set_title")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_title := gi.CString(title)
	arg_v := gi.NewPointerArgument(v.P)
	arg_title := gi.NewStringArgument(c_title)
	args := []gi.Argument{arg_v, arg_title}
	iv.Call(args, nil, nil)
	gi.Free(c_title)
}

// g_notification_set_urgent
// container is not nil, container is Notification
// is method
func (v Notification) SetUrgent(urgent bool) {
	iv, err := _I.Get(997, "Notification", "set_urgent")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_urgent := gi.NewBoolArgument(urgent)
	args := []gi.Argument{arg_v, arg_urgent}
	iv.Call(args, nil, nil)
}

// Enum NotificationPriority
type NotificationPriorityEnum int

const (
	NotificationPriorityNormal NotificationPriorityEnum = 0
	NotificationPriorityLow    NotificationPriorityEnum = 1
	NotificationPriorityHigh   NotificationPriorityEnum = 2
	NotificationPriorityUrgent NotificationPriorityEnum = 3
)

func NotificationPriorityGetType() gi.GType {
	ret := _I.GetGType(188, "NotificationPriority")
	return ret
}

// Struct OutputMessage
type OutputMessage struct {
	P unsafe.Pointer
}

const SizeOfStructOutputMessage = 40

func OutputMessageGetType() gi.GType {
	ret := _I.GetGType(189, "OutputMessage")
	return ret
}

// Object OutputStream
type OutputStream struct {
	gobject.Object
}

func WrapOutputStream(p unsafe.Pointer) (r OutputStream) { r.P = p; return }

type IOutputStream interface{ P_OutputStream() unsafe.Pointer }

func (v OutputStream) P_OutputStream() unsafe.Pointer { return v.P }
func OutputStreamGetType() gi.GType {
	ret := _I.GetGType(190, "OutputStream")
	return ret
}

// g_output_stream_clear_pending
// container is not nil, container is OutputStream
// is method
func (v OutputStream) ClearPending() {
	iv, err := _I.Get(998, "OutputStream", "clear_pending")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	iv.Call(args, nil, nil)
}

// g_output_stream_close
// container is not nil, container is OutputStream
// is method
func (v OutputStream) Close(cancellable ICancellable) (result bool, err error) {
	iv, err := _I.Get(999, "OutputStream", "close")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Bool()
	return
}

// g_output_stream_close_async
// container is not nil, container is OutputStream
// is method
func (v OutputStream) CloseAsync(io_priority int32, cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(1000, "OutputStream", "close_async")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_io_priority := gi.NewInt32Argument(io_priority)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_v, arg_io_priority, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
}

// g_output_stream_close_finish
// container is not nil, container is OutputStream
// is method
func (v OutputStream) CloseFinish(result IAsyncResult) (result1 bool, err error) {
	iv, err := _I.Get(1001, "OutputStream", "close_finish")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if result != nil {
		tmp = result.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_result := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_result, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result1 = ret.Bool()
	return
}

// g_output_stream_flush
// container is not nil, container is OutputStream
// is method
func (v OutputStream) Flush(cancellable ICancellable) (result bool, err error) {
	iv, err := _I.Get(1002, "OutputStream", "flush")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Bool()
	return
}

// g_output_stream_flush_async
// container is not nil, container is OutputStream
// is method
func (v OutputStream) FlushAsync(io_priority int32, cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(1003, "OutputStream", "flush_async")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_io_priority := gi.NewInt32Argument(io_priority)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_v, arg_io_priority, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
}

// g_output_stream_flush_finish
// container is not nil, container is OutputStream
// is method
func (v OutputStream) FlushFinish(result IAsyncResult) (result1 bool, err error) {
	iv, err := _I.Get(1004, "OutputStream", "flush_finish")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if result != nil {
		tmp = result.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_result := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_result, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result1 = ret.Bool()
	return
}

// g_output_stream_has_pending
// container is not nil, container is OutputStream
// is method
func (v OutputStream) HasPending() (result bool) {
	iv, err := _I.Get(1005, "OutputStream", "has_pending")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_output_stream_is_closed
// container is not nil, container is OutputStream
// is method
func (v OutputStream) IsClosed() (result bool) {
	iv, err := _I.Get(1006, "OutputStream", "is_closed")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_output_stream_is_closing
// container is not nil, container is OutputStream
// is method
func (v OutputStream) IsClosing() (result bool) {
	iv, err := _I.Get(1007, "OutputStream", "is_closing")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_output_stream_set_pending
// container is not nil, container is OutputStream
// is method
func (v OutputStream) SetPending() (result bool, err error) {
	iv, err := _I.Get(1008, "OutputStream", "set_pending")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	arg_v := gi.NewPointerArgument(v.P)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Bool()
	return
}

// g_output_stream_splice
// container is not nil, container is OutputStream
// is method
func (v OutputStream) Splice(source IInputStream, flags OutputStreamSpliceFlags, cancellable ICancellable) (result int64, err error) {
	iv, err := _I.Get(1009, "OutputStream", "splice")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if source != nil {
		tmp = source.P_InputStream()
	}
	var tmp1 unsafe.Pointer
	if cancellable != nil {
		tmp1 = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_source := gi.NewPointerArgument(tmp)
	arg_flags := gi.NewIntArgument(int(flags))
	arg_cancellable := gi.NewPointerArgument(tmp1)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_source, arg_flags, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Int64()
	return
}

// g_output_stream_splice_async
// container is not nil, container is OutputStream
// is method
func (v OutputStream) SpliceAsync(source IInputStream, flags OutputStreamSpliceFlags, io_priority int32, cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(1010, "OutputStream", "splice_async")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if source != nil {
		tmp = source.P_InputStream()
	}
	var tmp1 unsafe.Pointer
	if cancellable != nil {
		tmp1 = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_source := gi.NewPointerArgument(tmp)
	arg_flags := gi.NewIntArgument(int(flags))
	arg_io_priority := gi.NewInt32Argument(io_priority)
	arg_cancellable := gi.NewPointerArgument(tmp1)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_v, arg_source, arg_flags, arg_io_priority, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
}

// g_output_stream_splice_finish
// container is not nil, container is OutputStream
// is method
func (v OutputStream) SpliceFinish(result IAsyncResult) (result1 int64, err error) {
	iv, err := _I.Get(1011, "OutputStream", "splice_finish")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if result != nil {
		tmp = result.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_result := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_result, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result1 = ret.Int64()
	return
}

// g_output_stream_write
// container is not nil, container is OutputStream
// is method
// arg 0 buffer lenArgIdx 1
func (v OutputStream) Write(buffer gi.Uint8Array, count uint64, cancellable ICancellable) (result int64, err error) {
	iv, err := _I.Get(1012, "OutputStream", "write")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_buffer := gi.NewPointerArgument(buffer.P)
	arg_count := gi.NewUint64Argument(count)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_buffer, arg_count, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Int64()
	return
}

// g_output_stream_write_all
// container is not nil, container is OutputStream
// is method
// arg 0 buffer lenArgIdx 1
func (v OutputStream) WriteAll(buffer gi.Uint8Array, count uint64, cancellable ICancellable) (result bool, bytes_written uint64, err error) {
	iv, err := _I.Get(1013, "OutputStream", "write_all")
	if err != nil {
		return
	}
	var outArgs [2]gi.Argument
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_buffer := gi.NewPointerArgument(buffer.P)
	arg_count := gi.NewUint64Argument(count)
	arg_bytes_written := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[1]))
	args := []gi.Argument{arg_v, arg_buffer, arg_count, arg_bytes_written, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[1].Pointer())
	bytes_written = outArgs[0].Uint64()
	result = ret.Bool()
	return
}

// g_output_stream_write_all_async
// container is not nil, container is OutputStream
// is method
// arg 0 buffer lenArgIdx 1
func (v OutputStream) WriteAllAsync(buffer gi.Uint8Array, count uint64, io_priority int32, cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(1014, "OutputStream", "write_all_async")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_buffer := gi.NewPointerArgument(buffer.P)
	arg_count := gi.NewUint64Argument(count)
	arg_io_priority := gi.NewInt32Argument(io_priority)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_v, arg_buffer, arg_count, arg_io_priority, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
}

// g_output_stream_write_all_finish
// container is not nil, container is OutputStream
// is method
func (v OutputStream) WriteAllFinish(result IAsyncResult) (result1 bool, bytes_written uint64, err error) {
	iv, err := _I.Get(1015, "OutputStream", "write_all_finish")
	if err != nil {
		return
	}
	var outArgs [2]gi.Argument
	var tmp unsafe.Pointer
	if result != nil {
		tmp = result.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_result := gi.NewPointerArgument(tmp)
	arg_bytes_written := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[1]))
	args := []gi.Argument{arg_v, arg_result, arg_bytes_written, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[1].Pointer())
	bytes_written = outArgs[0].Uint64()
	result1 = ret.Bool()
	return
}

// g_output_stream_write_async
// container is not nil, container is OutputStream
// is method
// arg 0 buffer lenArgIdx 1
func (v OutputStream) WriteAsync(buffer gi.Uint8Array, count uint64, io_priority int32, cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(1016, "OutputStream", "write_async")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_buffer := gi.NewPointerArgument(buffer.P)
	arg_count := gi.NewUint64Argument(count)
	arg_io_priority := gi.NewInt32Argument(io_priority)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_v, arg_buffer, arg_count, arg_io_priority, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
}

// g_output_stream_write_bytes
// container is not nil, container is OutputStream
// is method
func (v OutputStream) WriteBytes(bytes glib.Bytes, cancellable ICancellable) (result int64, err error) {
	iv, err := _I.Get(1017, "OutputStream", "write_bytes")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_bytes := gi.NewPointerArgument(bytes.P)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_bytes, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Int64()
	return
}

// g_output_stream_write_bytes_async
// container is not nil, container is OutputStream
// is method
func (v OutputStream) WriteBytesAsync(bytes glib.Bytes, io_priority int32, cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(1018, "OutputStream", "write_bytes_async")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_bytes := gi.NewPointerArgument(bytes.P)
	arg_io_priority := gi.NewInt32Argument(io_priority)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_v, arg_bytes, arg_io_priority, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
}

// g_output_stream_write_bytes_finish
// container is not nil, container is OutputStream
// is method
func (v OutputStream) WriteBytesFinish(result IAsyncResult) (result1 int64, err error) {
	iv, err := _I.Get(1019, "OutputStream", "write_bytes_finish")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if result != nil {
		tmp = result.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_result := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_result, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result1 = ret.Int64()
	return
}

// g_output_stream_write_finish
// container is not nil, container is OutputStream
// is method
func (v OutputStream) WriteFinish(result IAsyncResult) (result1 int64, err error) {
	iv, err := _I.Get(1020, "OutputStream", "write_finish")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if result != nil {
		tmp = result.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_result := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_result, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result1 = ret.Int64()
	return
}

// ignore GType struct OutputStreamClass
// Struct OutputStreamPrivate
type OutputStreamPrivate struct {
	P unsafe.Pointer
}

func OutputStreamPrivateGetType() gi.GType {
	ret := _I.GetGType(191, "OutputStreamPrivate")
	return ret
}

// Flags OutputStreamSpliceFlags
type OutputStreamSpliceFlags int

const (
	OutputStreamSpliceFlagsNone        OutputStreamSpliceFlags = 0
	OutputStreamSpliceFlagsCloseSource OutputStreamSpliceFlags = 1
	OutputStreamSpliceFlagsCloseTarget OutputStreamSpliceFlags = 2
)

func OutputStreamSpliceFlagsGetType() gi.GType {
	ret := _I.GetGType(192, "OutputStreamSpliceFlags")
	return ret
}

// Struct OutputVector
type OutputVector struct {
	P unsafe.Pointer
}

const SizeOfStructOutputVector = 16

func OutputVectorGetType() gi.GType {
	ret := _I.GetGType(193, "OutputVector")
	return ret
}

// Enum PasswordSave
type PasswordSaveEnum int

const (
	PasswordSaveNever       PasswordSaveEnum = 0
	PasswordSaveForSession  PasswordSaveEnum = 1
	PasswordSavePermanently PasswordSaveEnum = 2
)

func PasswordSaveGetType() gi.GType {
	ret := _I.GetGType(194, "PasswordSave")
	return ret
}

// Object Permission
type Permission struct {
	gobject.Object
}

func WrapPermission(p unsafe.Pointer) (r Permission) { r.P = p; return }

type IPermission interface{ P_Permission() unsafe.Pointer }

func (v Permission) P_Permission() unsafe.Pointer { return v.P }
func PermissionGetType() gi.GType {
	ret := _I.GetGType(195, "Permission")
	return ret
}

// g_permission_acquire
// container is not nil, container is Permission
// is method
func (v Permission) Acquire(cancellable ICancellable) (result bool, err error) {
	iv, err := _I.Get(1021, "Permission", "acquire")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Bool()
	return
}

// g_permission_acquire_async
// container is not nil, container is Permission
// is method
func (v Permission) AcquireAsync(cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(1022, "Permission", "acquire_async")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_v, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
}

// g_permission_acquire_finish
// container is not nil, container is Permission
// is method
func (v Permission) AcquireFinish(result IAsyncResult) (result1 bool, err error) {
	iv, err := _I.Get(1023, "Permission", "acquire_finish")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if result != nil {
		tmp = result.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_result := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_result, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result1 = ret.Bool()
	return
}

// g_permission_get_allowed
// container is not nil, container is Permission
// is method
func (v Permission) GetAllowed() (result bool) {
	iv, err := _I.Get(1024, "Permission", "get_allowed")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_permission_get_can_acquire
// container is not nil, container is Permission
// is method
func (v Permission) GetCanAcquire() (result bool) {
	iv, err := _I.Get(1025, "Permission", "get_can_acquire")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_permission_get_can_release
// container is not nil, container is Permission
// is method
func (v Permission) GetCanRelease() (result bool) {
	iv, err := _I.Get(1026, "Permission", "get_can_release")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_permission_impl_update
// container is not nil, container is Permission
// is method
func (v Permission) ImplUpdate(allowed bool, can_acquire bool, can_release bool) {
	iv, err := _I.Get(1027, "Permission", "impl_update")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_allowed := gi.NewBoolArgument(allowed)
	arg_can_acquire := gi.NewBoolArgument(can_acquire)
	arg_can_release := gi.NewBoolArgument(can_release)
	args := []gi.Argument{arg_v, arg_allowed, arg_can_acquire, arg_can_release}
	iv.Call(args, nil, nil)
}

// g_permission_release
// container is not nil, container is Permission
// is method
func (v Permission) Release(cancellable ICancellable) (result bool, err error) {
	iv, err := _I.Get(1028, "Permission", "release")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Bool()
	return
}

// g_permission_release_async
// container is not nil, container is Permission
// is method
func (v Permission) ReleaseAsync(cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(1029, "Permission", "release_async")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_v, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
}

// g_permission_release_finish
// container is not nil, container is Permission
// is method
func (v Permission) ReleaseFinish(result IAsyncResult) (result1 bool, err error) {
	iv, err := _I.Get(1030, "Permission", "release_finish")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if result != nil {
		tmp = result.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_result := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_result, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result1 = ret.Bool()
	return
}

// ignore GType struct PermissionClass
// Struct PermissionPrivate
type PermissionPrivate struct {
	P unsafe.Pointer
}

func PermissionPrivateGetType() gi.GType {
	ret := _I.GetGType(196, "PermissionPrivate")
	return ret
}

// Interface PollableInputStream
type PollableInputStream struct {
	PollableInputStreamIfc
	P unsafe.Pointer
}
type PollableInputStreamIfc struct{}
type IPollableInputStream interface{ P_PollableInputStream() unsafe.Pointer }

func (v PollableInputStream) P_PollableInputStream() unsafe.Pointer { return v.P }
func PollableInputStreamGetType() gi.GType {
	ret := _I.GetGType(197, "PollableInputStream")
	return ret
}

// g_pollable_input_stream_can_poll
// container is not nil, container is PollableInputStream
// is method
func (v *PollableInputStreamIfc) CanPoll() (result bool) {
	iv, err := _I.Get(1031, "PollableInputStream", "can_poll")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_pollable_input_stream_create_source
// container is not nil, container is PollableInputStream
// is method
func (v *PollableInputStreamIfc) CreateSource(cancellable ICancellable) (result glib.Source) {
	iv, err := _I.Get(1032, "PollableInputStream", "create_source")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_cancellable := gi.NewPointerArgument(tmp)
	args := []gi.Argument{arg_v, arg_cancellable}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_pollable_input_stream_is_readable
// container is not nil, container is PollableInputStream
// is method
func (v *PollableInputStreamIfc) IsReadable() (result bool) {
	iv, err := _I.Get(1033, "PollableInputStream", "is_readable")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_pollable_input_stream_read_nonblocking
// container is not nil, container is PollableInputStream
// is method
// arg 0 buffer lenArgIdx 1
func (v *PollableInputStreamIfc) ReadNonblocking(buffer gi.Uint8Array, count uint64, cancellable ICancellable) (result int64, err error) {
	iv, err := _I.Get(1034, "PollableInputStream", "read_nonblocking")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_buffer := gi.NewPointerArgument(buffer.P)
	arg_count := gi.NewUint64Argument(count)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_buffer, arg_count, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Int64()
	return
}

// ignore GType struct PollableInputStreamInterface
// Interface PollableOutputStream
type PollableOutputStream struct {
	PollableOutputStreamIfc
	P unsafe.Pointer
}
type PollableOutputStreamIfc struct{}
type IPollableOutputStream interface{ P_PollableOutputStream() unsafe.Pointer }

func (v PollableOutputStream) P_PollableOutputStream() unsafe.Pointer { return v.P }
func PollableOutputStreamGetType() gi.GType {
	ret := _I.GetGType(198, "PollableOutputStream")
	return ret
}

// g_pollable_output_stream_can_poll
// container is not nil, container is PollableOutputStream
// is method
func (v *PollableOutputStreamIfc) CanPoll() (result bool) {
	iv, err := _I.Get(1035, "PollableOutputStream", "can_poll")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_pollable_output_stream_create_source
// container is not nil, container is PollableOutputStream
// is method
func (v *PollableOutputStreamIfc) CreateSource(cancellable ICancellable) (result glib.Source) {
	iv, err := _I.Get(1036, "PollableOutputStream", "create_source")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_cancellable := gi.NewPointerArgument(tmp)
	args := []gi.Argument{arg_v, arg_cancellable}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_pollable_output_stream_is_writable
// container is not nil, container is PollableOutputStream
// is method
func (v *PollableOutputStreamIfc) IsWritable() (result bool) {
	iv, err := _I.Get(1037, "PollableOutputStream", "is_writable")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_pollable_output_stream_write_nonblocking
// container is not nil, container is PollableOutputStream
// is method
// arg 0 buffer lenArgIdx 1
func (v *PollableOutputStreamIfc) WriteNonblocking(buffer gi.Uint8Array, count uint64, cancellable ICancellable) (result int64, err error) {
	iv, err := _I.Get(1038, "PollableOutputStream", "write_nonblocking")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_buffer := gi.NewPointerArgument(buffer.P)
	arg_count := gi.NewUint64Argument(count)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_buffer, arg_count, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Int64()
	return
}

// ignore GType struct PollableOutputStreamInterface
type PollableSourceFuncStruct struct {
	F_pollable_stream gobject.Object
}

//export myPollableSourceFunc
func myPollableSourceFunc(pollable_stream *C.GObject, user_data C.gpointer) {
	fn := gi.GetFunc(uint(uintptr(user_data)))
	args := PollableSourceFuncStruct{
		F_pollable_stream: gobject.WrapObject(unsafe.Pointer(pollable_stream)),
	}
	fn(args)
}

// Object PropertyAction
type PropertyAction struct {
	ActionIfc
	gobject.Object
}

func WrapPropertyAction(p unsafe.Pointer) (r PropertyAction) { r.P = p; return }

type IPropertyAction interface{ P_PropertyAction() unsafe.Pointer }

func (v PropertyAction) P_PropertyAction() unsafe.Pointer { return v.P }
func (v PropertyAction) P_Action() unsafe.Pointer         { return v.P }
func PropertyActionGetType() gi.GType {
	ret := _I.GetGType(199, "PropertyAction")
	return ret
}

// g_property_action_new
// container is not nil, container is PropertyAction
// is constructor
func NewPropertyAction(name string, object gobject.IObject, property_name string) (result PropertyAction) {
	iv, err := _I.Get(1039, "PropertyAction", "new")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_name := gi.CString(name)
	var tmp unsafe.Pointer
	if object != nil {
		tmp = object.P_Object()
	}
	c_property_name := gi.CString(property_name)
	arg_name := gi.NewStringArgument(c_name)
	arg_object := gi.NewPointerArgument(tmp)
	arg_property_name := gi.NewStringArgument(c_property_name)
	args := []gi.Argument{arg_name, arg_object, arg_property_name}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_name)
	gi.Free(c_property_name)
	result.P = ret.Pointer()
	return
}

// Interface Proxy
type Proxy struct {
	ProxyIfc
	P unsafe.Pointer
}
type ProxyIfc struct{}
type IProxy interface{ P_Proxy() unsafe.Pointer }

func (v Proxy) P_Proxy() unsafe.Pointer { return v.P }
func ProxyGetType() gi.GType {
	ret := _I.GetGType(200, "Proxy")
	return ret
}

// g_proxy_get_default_for_protocol
// container is not nil, container is Proxy
// is method
// arg0Type tag: utf8, isPtr: true
func ProxyGetDefaultForProtocol1(protocol string) (result Proxy) {
	iv, err := _I.Get(1040, "Proxy", "get_default_for_protocol")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_protocol := gi.CString(protocol)
	arg_protocol := gi.NewStringArgument(c_protocol)
	args := []gi.Argument{arg_protocol}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_protocol)
	result.P = ret.Pointer()
	return
}

// g_proxy_connect
// container is not nil, container is Proxy
// is method
func (v *ProxyIfc) Connect(connection IIOStream, proxy_address IProxyAddress, cancellable ICancellable) (result IOStream, err error) {
	iv, err := _I.Get(1041, "Proxy", "connect")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if connection != nil {
		tmp = connection.P_IOStream()
	}
	var tmp1 unsafe.Pointer
	if proxy_address != nil {
		tmp1 = proxy_address.P_ProxyAddress()
	}
	var tmp2 unsafe.Pointer
	if cancellable != nil {
		tmp2 = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_connection := gi.NewPointerArgument(tmp)
	arg_proxy_address := gi.NewPointerArgument(tmp1)
	arg_cancellable := gi.NewPointerArgument(tmp2)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_connection, arg_proxy_address, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// g_proxy_connect_async
// container is not nil, container is Proxy
// is method
func (v *ProxyIfc) ConnectAsync(connection IIOStream, proxy_address IProxyAddress, cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(1042, "Proxy", "connect_async")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if connection != nil {
		tmp = connection.P_IOStream()
	}
	var tmp1 unsafe.Pointer
	if proxy_address != nil {
		tmp1 = proxy_address.P_ProxyAddress()
	}
	var tmp2 unsafe.Pointer
	if cancellable != nil {
		tmp2 = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_connection := gi.NewPointerArgument(tmp)
	arg_proxy_address := gi.NewPointerArgument(tmp1)
	arg_cancellable := gi.NewPointerArgument(tmp2)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_v, arg_connection, arg_proxy_address, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
}

// g_proxy_connect_finish
// container is not nil, container is Proxy
// is method
func (v *ProxyIfc) ConnectFinish(result IAsyncResult) (result1 IOStream, err error) {
	iv, err := _I.Get(1043, "Proxy", "connect_finish")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if result != nil {
		tmp = result.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_result := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_result, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result1.P = ret.Pointer()
	return
}

// g_proxy_supports_hostname
// container is not nil, container is Proxy
// is method
func (v *ProxyIfc) SupportsHostname() (result bool) {
	iv, err := _I.Get(1044, "Proxy", "supports_hostname")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// Object ProxyAddress
type ProxyAddress struct {
	SocketConnectableIfc
	InetSocketAddress
}

func WrapProxyAddress(p unsafe.Pointer) (r ProxyAddress) { r.P = p; return }

type IProxyAddress interface{ P_ProxyAddress() unsafe.Pointer }

func (v ProxyAddress) P_ProxyAddress() unsafe.Pointer      { return v.P }
func (v ProxyAddress) P_SocketConnectable() unsafe.Pointer { return v.P }
func ProxyAddressGetType() gi.GType {
	ret := _I.GetGType(201, "ProxyAddress")
	return ret
}

// g_proxy_address_new
// container is not nil, container is ProxyAddress
// is constructor
func NewProxyAddress(inetaddr IInetAddress, port uint16, protocol string, dest_hostname string, dest_port uint16, username string, password string) (result ProxyAddress) {
	iv, err := _I.Get(1045, "ProxyAddress", "new")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if inetaddr != nil {
		tmp = inetaddr.P_InetAddress()
	}
	c_protocol := gi.CString(protocol)
	c_dest_hostname := gi.CString(dest_hostname)
	c_username := gi.CString(username)
	c_password := gi.CString(password)
	arg_inetaddr := gi.NewPointerArgument(tmp)
	arg_port := gi.NewUint16Argument(port)
	arg_protocol := gi.NewStringArgument(c_protocol)
	arg_dest_hostname := gi.NewStringArgument(c_dest_hostname)
	arg_dest_port := gi.NewUint16Argument(dest_port)
	arg_username := gi.NewStringArgument(c_username)
	arg_password := gi.NewStringArgument(c_password)
	args := []gi.Argument{arg_inetaddr, arg_port, arg_protocol, arg_dest_hostname, arg_dest_port, arg_username, arg_password}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_protocol)
	gi.Free(c_dest_hostname)
	gi.Free(c_username)
	gi.Free(c_password)
	result.P = ret.Pointer()
	return
}

// g_proxy_address_get_destination_hostname
// container is not nil, container is ProxyAddress
// is method
func (v ProxyAddress) GetDestinationHostname() (result string) {
	iv, err := _I.Get(1046, "ProxyAddress", "get_destination_hostname")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Take()
	return
}

// g_proxy_address_get_destination_port
// container is not nil, container is ProxyAddress
// is method
func (v ProxyAddress) GetDestinationPort() (result uint16) {
	iv, err := _I.Get(1047, "ProxyAddress", "get_destination_port")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Uint16()
	return
}

// g_proxy_address_get_destination_protocol
// container is not nil, container is ProxyAddress
// is method
func (v ProxyAddress) GetDestinationProtocol() (result string) {
	iv, err := _I.Get(1048, "ProxyAddress", "get_destination_protocol")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Take()
	return
}

// g_proxy_address_get_password
// container is not nil, container is ProxyAddress
// is method
func (v ProxyAddress) GetPassword() (result string) {
	iv, err := _I.Get(1049, "ProxyAddress", "get_password")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Take()
	return
}

// g_proxy_address_get_protocol
// container is not nil, container is ProxyAddress
// is method
func (v ProxyAddress) GetProtocol() (result string) {
	iv, err := _I.Get(1050, "ProxyAddress", "get_protocol")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Take()
	return
}

// g_proxy_address_get_uri
// container is not nil, container is ProxyAddress
// is method
func (v ProxyAddress) GetUri() (result string) {
	iv, err := _I.Get(1051, "ProxyAddress", "get_uri")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Take()
	return
}

// g_proxy_address_get_username
// container is not nil, container is ProxyAddress
// is method
func (v ProxyAddress) GetUsername() (result string) {
	iv, err := _I.Get(1052, "ProxyAddress", "get_username")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Take()
	return
}

// ignore GType struct ProxyAddressClass
// Object ProxyAddressEnumerator
type ProxyAddressEnumerator struct {
	SocketAddressEnumerator
}

func WrapProxyAddressEnumerator(p unsafe.Pointer) (r ProxyAddressEnumerator) { r.P = p; return }

type IProxyAddressEnumerator interface{ P_ProxyAddressEnumerator() unsafe.Pointer }

func (v ProxyAddressEnumerator) P_ProxyAddressEnumerator() unsafe.Pointer { return v.P }
func ProxyAddressEnumeratorGetType() gi.GType {
	ret := _I.GetGType(202, "ProxyAddressEnumerator")
	return ret
}

// ignore GType struct ProxyAddressEnumeratorClass
// Struct ProxyAddressEnumeratorPrivate
type ProxyAddressEnumeratorPrivate struct {
	P unsafe.Pointer
}

func ProxyAddressEnumeratorPrivateGetType() gi.GType {
	ret := _I.GetGType(203, "ProxyAddressEnumeratorPrivate")
	return ret
}

// Struct ProxyAddressPrivate
type ProxyAddressPrivate struct {
	P unsafe.Pointer
}

func ProxyAddressPrivateGetType() gi.GType {
	ret := _I.GetGType(204, "ProxyAddressPrivate")
	return ret
}

// ignore GType struct ProxyInterface
// Interface ProxyResolver
type ProxyResolver struct {
	ProxyResolverIfc
	P unsafe.Pointer
}
type ProxyResolverIfc struct{}
type IProxyResolver interface{ P_ProxyResolver() unsafe.Pointer }

func (v ProxyResolver) P_ProxyResolver() unsafe.Pointer { return v.P }
func ProxyResolverGetType() gi.GType {
	ret := _I.GetGType(205, "ProxyResolver")
	return ret
}

// g_proxy_resolver_is_supported
// container is not nil, container is ProxyResolver
// is method
func (v *ProxyResolverIfc) IsSupported() (result bool) {
	iv, err := _I.Get(1054, "ProxyResolver", "is_supported")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_proxy_resolver_lookup
// container is not nil, container is ProxyResolver
// is method
func (v *ProxyResolverIfc) Lookup(uri string, cancellable ICancellable) (result gi.CStrArray, err error) {
	iv, err := _I.Get(1055, "ProxyResolver", "lookup")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	c_uri := gi.CString(uri)
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_uri := gi.NewStringArgument(c_uri)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_uri, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	gi.Free(c_uri)
	err = gi.ToError(outArgs[0].Pointer())
	result = gi.CStrArray{P: ret.Pointer(), Len: -1}
	result.SetLenZT()
	return
}

// g_proxy_resolver_lookup_async
// container is not nil, container is ProxyResolver
// is method
func (v *ProxyResolverIfc) LookupAsync(uri string, cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(1056, "ProxyResolver", "lookup_async")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_uri := gi.CString(uri)
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_uri := gi.NewStringArgument(c_uri)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_v, arg_uri, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
	gi.Free(c_uri)
}

// g_proxy_resolver_lookup_finish
// container is not nil, container is ProxyResolver
// is method
func (v *ProxyResolverIfc) LookupFinish(result IAsyncResult) (result1 gi.CStrArray, err error) {
	iv, err := _I.Get(1057, "ProxyResolver", "lookup_finish")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if result != nil {
		tmp = result.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_result := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_result, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result1 = gi.CStrArray{P: ret.Pointer(), Len: -1}
	result1.SetLenZT()
	return
}

// ignore GType struct ProxyResolverInterface
// ignore callback ReallocFunc
// Interface RemoteActionGroup
type RemoteActionGroup struct {
	RemoteActionGroupIfc
	P unsafe.Pointer
}
type RemoteActionGroupIfc struct{}
type IRemoteActionGroup interface{ P_RemoteActionGroup() unsafe.Pointer }

func (v RemoteActionGroup) P_RemoteActionGroup() unsafe.Pointer { return v.P }
func RemoteActionGroupGetType() gi.GType {
	ret := _I.GetGType(206, "RemoteActionGroup")
	return ret
}

// g_remote_action_group_activate_action_full
// container is not nil, container is RemoteActionGroup
// is method
func (v *RemoteActionGroupIfc) ActivateActionFull(action_name string, parameter glib.Variant, platform_data glib.Variant) {
	iv, err := _I.Get(1058, "RemoteActionGroup", "activate_action_full")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_action_name := gi.CString(action_name)
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_action_name := gi.NewStringArgument(c_action_name)
	arg_parameter := gi.NewPointerArgument(parameter.P)
	arg_platform_data := gi.NewPointerArgument(platform_data.P)
	args := []gi.Argument{arg_v, arg_action_name, arg_parameter, arg_platform_data}
	iv.Call(args, nil, nil)
	gi.Free(c_action_name)
}

// g_remote_action_group_change_action_state_full
// container is not nil, container is RemoteActionGroup
// is method
func (v *RemoteActionGroupIfc) ChangeActionStateFull(action_name string, value glib.Variant, platform_data glib.Variant) {
	iv, err := _I.Get(1059, "RemoteActionGroup", "change_action_state_full")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_action_name := gi.CString(action_name)
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_action_name := gi.NewStringArgument(c_action_name)
	arg_value := gi.NewPointerArgument(value.P)
	arg_platform_data := gi.NewPointerArgument(platform_data.P)
	args := []gi.Argument{arg_v, arg_action_name, arg_value, arg_platform_data}
	iv.Call(args, nil, nil)
	gi.Free(c_action_name)
}

// ignore GType struct RemoteActionGroupInterface
// Object Resolver
type Resolver struct {
	gobject.Object
}

func WrapResolver(p unsafe.Pointer) (r Resolver) { r.P = p; return }

type IResolver interface{ P_Resolver() unsafe.Pointer }

func (v Resolver) P_Resolver() unsafe.Pointer { return v.P }
func ResolverGetType() gi.GType {
	ret := _I.GetGType(207, "Resolver")
	return ret
}

// g_resolver_lookup_by_address
// container is not nil, container is Resolver
// is method
func (v Resolver) LookupByAddress(address IInetAddress, cancellable ICancellable) (result string, err error) {
	iv, err := _I.Get(1061, "Resolver", "lookup_by_address")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if address != nil {
		tmp = address.P_InetAddress()
	}
	var tmp1 unsafe.Pointer
	if cancellable != nil {
		tmp1 = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_address := gi.NewPointerArgument(tmp)
	arg_cancellable := gi.NewPointerArgument(tmp1)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_address, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.String().Take()
	return
}

// g_resolver_lookup_by_address_async
// container is not nil, container is Resolver
// is method
func (v Resolver) LookupByAddressAsync(address IInetAddress, cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(1062, "Resolver", "lookup_by_address_async")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if address != nil {
		tmp = address.P_InetAddress()
	}
	var tmp1 unsafe.Pointer
	if cancellable != nil {
		tmp1 = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_address := gi.NewPointerArgument(tmp)
	arg_cancellable := gi.NewPointerArgument(tmp1)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_v, arg_address, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
}

// g_resolver_lookup_by_address_finish
// container is not nil, container is Resolver
// is method
func (v Resolver) LookupByAddressFinish(result IAsyncResult) (result1 string, err error) {
	iv, err := _I.Get(1063, "Resolver", "lookup_by_address_finish")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if result != nil {
		tmp = result.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_result := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_result, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result1 = ret.String().Take()
	return
}

// g_resolver_lookup_by_name
// container is not nil, container is Resolver
// is method
func (v Resolver) LookupByName(hostname string, cancellable ICancellable) (result glib.List, err error) {
	iv, err := _I.Get(1064, "Resolver", "lookup_by_name")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	c_hostname := gi.CString(hostname)
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_hostname := gi.NewStringArgument(c_hostname)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_hostname, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	gi.Free(c_hostname)
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// g_resolver_lookup_by_name_async
// container is not nil, container is Resolver
// is method
func (v Resolver) LookupByNameAsync(hostname string, cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(1065, "Resolver", "lookup_by_name_async")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_hostname := gi.CString(hostname)
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_hostname := gi.NewStringArgument(c_hostname)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_v, arg_hostname, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
	gi.Free(c_hostname)
}

// g_resolver_lookup_by_name_finish
// container is not nil, container is Resolver
// is method
func (v Resolver) LookupByNameFinish(result IAsyncResult) (result1 glib.List, err error) {
	iv, err := _I.Get(1066, "Resolver", "lookup_by_name_finish")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if result != nil {
		tmp = result.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_result := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_result, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result1.P = ret.Pointer()
	return
}

// g_resolver_lookup_records
// container is not nil, container is Resolver
// is method
func (v Resolver) LookupRecords(rrname string, record_type ResolverRecordTypeEnum, cancellable ICancellable) (result glib.List, err error) {
	iv, err := _I.Get(1067, "Resolver", "lookup_records")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	c_rrname := gi.CString(rrname)
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_rrname := gi.NewStringArgument(c_rrname)
	arg_record_type := gi.NewIntArgument(int(record_type))
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_rrname, arg_record_type, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	gi.Free(c_rrname)
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// g_resolver_lookup_records_async
// container is not nil, container is Resolver
// is method
func (v Resolver) LookupRecordsAsync(rrname string, record_type ResolverRecordTypeEnum, cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(1068, "Resolver", "lookup_records_async")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_rrname := gi.CString(rrname)
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_rrname := gi.NewStringArgument(c_rrname)
	arg_record_type := gi.NewIntArgument(int(record_type))
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_v, arg_rrname, arg_record_type, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
	gi.Free(c_rrname)
}

// g_resolver_lookup_records_finish
// container is not nil, container is Resolver
// is method
func (v Resolver) LookupRecordsFinish(result IAsyncResult) (result1 glib.List, err error) {
	iv, err := _I.Get(1069, "Resolver", "lookup_records_finish")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if result != nil {
		tmp = result.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_result := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_result, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result1.P = ret.Pointer()
	return
}

// g_resolver_lookup_service
// container is not nil, container is Resolver
// is method
func (v Resolver) LookupService(service string, protocol string, domain string, cancellable ICancellable) (result glib.List, err error) {
	iv, err := _I.Get(1070, "Resolver", "lookup_service")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	c_service := gi.CString(service)
	c_protocol := gi.CString(protocol)
	c_domain := gi.CString(domain)
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_service := gi.NewStringArgument(c_service)
	arg_protocol := gi.NewStringArgument(c_protocol)
	arg_domain := gi.NewStringArgument(c_domain)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_service, arg_protocol, arg_domain, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	gi.Free(c_service)
	gi.Free(c_protocol)
	gi.Free(c_domain)
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// g_resolver_lookup_service_async
// container is not nil, container is Resolver
// is method
func (v Resolver) LookupServiceAsync(service string, protocol string, domain string, cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(1071, "Resolver", "lookup_service_async")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_service := gi.CString(service)
	c_protocol := gi.CString(protocol)
	c_domain := gi.CString(domain)
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_service := gi.NewStringArgument(c_service)
	arg_protocol := gi.NewStringArgument(c_protocol)
	arg_domain := gi.NewStringArgument(c_domain)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_v, arg_service, arg_protocol, arg_domain, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
	gi.Free(c_service)
	gi.Free(c_protocol)
	gi.Free(c_domain)
}

// g_resolver_lookup_service_finish
// container is not nil, container is Resolver
// is method
func (v Resolver) LookupServiceFinish(result IAsyncResult) (result1 glib.List, err error) {
	iv, err := _I.Get(1072, "Resolver", "lookup_service_finish")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if result != nil {
		tmp = result.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_result := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_result, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result1.P = ret.Pointer()
	return
}

// g_resolver_set_default
// container is not nil, container is Resolver
// is method
func (v Resolver) SetDefault() {
	iv, err := _I.Get(1073, "Resolver", "set_default")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	iv.Call(args, nil, nil)
}

// ignore GType struct ResolverClass
// Enum ResolverError
type ResolverErrorEnum int

const (
	ResolverErrorNotFound         ResolverErrorEnum = 0
	ResolverErrorTemporaryFailure ResolverErrorEnum = 1
	ResolverErrorInternal         ResolverErrorEnum = 2
)

func ResolverErrorGetType() gi.GType {
	ret := _I.GetGType(208, "ResolverError")
	return ret
}

// Struct ResolverPrivate
type ResolverPrivate struct {
	P unsafe.Pointer
}

func ResolverPrivateGetType() gi.GType {
	ret := _I.GetGType(209, "ResolverPrivate")
	return ret
}

// Enum ResolverRecordType
type ResolverRecordTypeEnum int

const (
	ResolverRecordTypeSrv ResolverRecordTypeEnum = 1
	ResolverRecordTypeMx  ResolverRecordTypeEnum = 2
	ResolverRecordTypeTxt ResolverRecordTypeEnum = 3
	ResolverRecordTypeSoa ResolverRecordTypeEnum = 4
	ResolverRecordTypeNs  ResolverRecordTypeEnum = 5
)

func ResolverRecordTypeGetType() gi.GType {
	ret := _I.GetGType(210, "ResolverRecordType")
	return ret
}

// Struct Resource
type Resource struct {
	P unsafe.Pointer
}

func ResourceGetType() gi.GType {
	ret := _I.GetGType(211, "Resource")
	return ret
}

// g_resource_new_from_data
// container is not nil, container is Resource
// is constructor
func NewResourceFromData(data glib.Bytes) (result Resource, err error) {
	iv, err := _I.Get(1074, "Resource", "new_from_data")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	arg_data := gi.NewPointerArgument(data.P)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_data, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// g_resources_register
// container is not nil, container is Resource
// is method
func (v Resource) _Register() {
	iv, err := _I.Get(1075, "Resource", "_register")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	iv.Call(args, nil, nil)
}

// g_resources_unregister
// container is not nil, container is Resource
// is method
func (v Resource) _Unregister() {
	iv, err := _I.Get(1076, "Resource", "_unregister")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	iv.Call(args, nil, nil)
}

// g_resource_enumerate_children
// container is not nil, container is Resource
// is method
func (v Resource) EnumerateChildren(path string, lookup_flags ResourceLookupFlags) (result gi.CStrArray, err error) {
	iv, err := _I.Get(1077, "Resource", "enumerate_children")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	c_path := gi.CString(path)
	arg_v := gi.NewPointerArgument(v.P)
	arg_path := gi.NewStringArgument(c_path)
	arg_lookup_flags := gi.NewIntArgument(int(lookup_flags))
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_path, arg_lookup_flags, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	gi.Free(c_path)
	err = gi.ToError(outArgs[0].Pointer())
	result = gi.CStrArray{P: ret.Pointer(), Len: -1}
	result.SetLenZT()
	return
}

// g_resource_get_info
// container is not nil, container is Resource
// is method
func (v Resource) GetInfo(path string, lookup_flags ResourceLookupFlags) (result bool, size uint64, flags uint32, err error) {
	iv, err := _I.Get(1078, "Resource", "get_info")
	if err != nil {
		return
	}
	var outArgs [3]gi.Argument
	c_path := gi.CString(path)
	arg_v := gi.NewPointerArgument(v.P)
	arg_path := gi.NewStringArgument(c_path)
	arg_lookup_flags := gi.NewIntArgument(int(lookup_flags))
	arg_size := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	arg_flags := gi.NewPointerArgument(unsafe.Pointer(&outArgs[1]))
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[2]))
	args := []gi.Argument{arg_v, arg_path, arg_lookup_flags, arg_size, arg_flags, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	gi.Free(c_path)
	err = gi.ToError(outArgs[2].Pointer())
	size = outArgs[0].Uint64()
	flags = outArgs[1].Uint32()
	result = ret.Bool()
	return
}

// g_resource_lookup_data
// container is not nil, container is Resource
// is method
func (v Resource) LookupData(path string, lookup_flags ResourceLookupFlags) (result glib.Bytes, err error) {
	iv, err := _I.Get(1079, "Resource", "lookup_data")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	c_path := gi.CString(path)
	arg_v := gi.NewPointerArgument(v.P)
	arg_path := gi.NewStringArgument(c_path)
	arg_lookup_flags := gi.NewIntArgument(int(lookup_flags))
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_path, arg_lookup_flags, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	gi.Free(c_path)
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// g_resource_open_stream
// container is not nil, container is Resource
// is method
func (v Resource) OpenStream(path string, lookup_flags ResourceLookupFlags) (result InputStream, err error) {
	iv, err := _I.Get(1080, "Resource", "open_stream")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	c_path := gi.CString(path)
	arg_v := gi.NewPointerArgument(v.P)
	arg_path := gi.NewStringArgument(c_path)
	arg_lookup_flags := gi.NewIntArgument(int(lookup_flags))
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_path, arg_lookup_flags, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	gi.Free(c_path)
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// g_resource_ref
// container is not nil, container is Resource
// is method
func (v Resource) Ref() (result Resource) {
	iv, err := _I.Get(1081, "Resource", "ref")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_resource_unref
// container is not nil, container is Resource
// is method
func (v Resource) Unref() {
	iv, err := _I.Get(1082, "Resource", "unref")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	iv.Call(args, nil, nil)
}

// g_resource_load
// container is not nil, container is Resource
// is method
// arg0Type tag: filename, isPtr: true
func ResourceLoad1(filename string) (result Resource, err error) {
	iv, err := _I.Get(1083, "Resource", "load")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	c_filename := gi.CString(filename)
	arg_filename := gi.NewStringArgument(c_filename)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_filename, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	gi.Free(c_filename)
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// Enum ResourceError
type ResourceErrorEnum int

const (
	ResourceErrorNotFound ResourceErrorEnum = 0
	ResourceErrorInternal ResourceErrorEnum = 1
)

func ResourceErrorGetType() gi.GType {
	ret := _I.GetGType(212, "ResourceError")
	return ret
}

// Flags ResourceFlags
type ResourceFlags int

const (
	ResourceFlagsNone       ResourceFlags = 0
	ResourceFlagsCompressed ResourceFlags = 1
)

func ResourceFlagsGetType() gi.GType {
	ret := _I.GetGType(213, "ResourceFlags")
	return ret
}

// Flags ResourceLookupFlags
type ResourceLookupFlags int

const (
	ResourceLookupFlagsNone ResourceLookupFlags = 0
)

func ResourceLookupFlagsGetType() gi.GType {
	ret := _I.GetGType(214, "ResourceLookupFlags")
	return ret
}

// Interface Seekable
type Seekable struct {
	SeekableIfc
	P unsafe.Pointer
}
type SeekableIfc struct{}
type ISeekable interface{ P_Seekable() unsafe.Pointer }

func (v Seekable) P_Seekable() unsafe.Pointer { return v.P }
func SeekableGetType() gi.GType {
	ret := _I.GetGType(215, "Seekable")
	return ret
}

// g_seekable_can_seek
// container is not nil, container is Seekable
// is method
func (v *SeekableIfc) CanSeek() (result bool) {
	iv, err := _I.Get(1084, "Seekable", "can_seek")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_seekable_can_truncate
// container is not nil, container is Seekable
// is method
func (v *SeekableIfc) CanTruncate() (result bool) {
	iv, err := _I.Get(1085, "Seekable", "can_truncate")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_seekable_seek
// container is not nil, container is Seekable
// is method
func (v *SeekableIfc) Seek(offset int64, type1 glib.SeekTypeEnum, cancellable ICancellable) (result bool, err error) {
	iv, err := _I.Get(1086, "Seekable", "seek")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_offset := gi.NewInt64Argument(offset)
	arg_type1 := gi.NewIntArgument(int(type1))
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_offset, arg_type1, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Bool()
	return
}

// g_seekable_tell
// container is not nil, container is Seekable
// is method
func (v *SeekableIfc) Tell() (result int64) {
	iv, err := _I.Get(1087, "Seekable", "tell")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Int64()
	return
}

// g_seekable_truncate
// container is not nil, container is Seekable
// is method
func (v *SeekableIfc) Truncate(offset int64, cancellable ICancellable) (result bool, err error) {
	iv, err := _I.Get(1088, "Seekable", "truncate")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_offset := gi.NewInt64Argument(offset)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_offset, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Bool()
	return
}

// ignore GType struct SeekableIface
// Object Settings
type Settings struct {
	gobject.Object
}

func WrapSettings(p unsafe.Pointer) (r Settings) { r.P = p; return }

type ISettings interface{ P_Settings() unsafe.Pointer }

func (v Settings) P_Settings() unsafe.Pointer { return v.P }
func SettingsGetType() gi.GType {
	ret := _I.GetGType(216, "Settings")
	return ret
}

// g_settings_new
// container is not nil, container is Settings
// is constructor
func NewSettings(schema_id string) (result Settings) {
	iv, err := _I.Get(1089, "Settings", "new")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_schema_id := gi.CString(schema_id)
	arg_schema_id := gi.NewStringArgument(c_schema_id)
	args := []gi.Argument{arg_schema_id}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_schema_id)
	result.P = ret.Pointer()
	return
}

// g_settings_new_full
// container is not nil, container is Settings
// is constructor
func NewSettingsFull(schema SettingsSchema, backend ISettingsBackend, path string) (result Settings) {
	iv, err := _I.Get(1090, "Settings", "new_full")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if backend != nil {
		tmp = backend.P_SettingsBackend()
	}
	c_path := gi.CString(path)
	arg_schema := gi.NewPointerArgument(schema.P)
	arg_backend := gi.NewPointerArgument(tmp)
	arg_path := gi.NewStringArgument(c_path)
	args := []gi.Argument{arg_schema, arg_backend, arg_path}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_path)
	result.P = ret.Pointer()
	return
}

// g_settings_new_with_backend
// container is not nil, container is Settings
// is constructor
func NewSettingsWithBackend(schema_id string, backend ISettingsBackend) (result Settings) {
	iv, err := _I.Get(1091, "Settings", "new_with_backend")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_schema_id := gi.CString(schema_id)
	var tmp unsafe.Pointer
	if backend != nil {
		tmp = backend.P_SettingsBackend()
	}
	arg_schema_id := gi.NewStringArgument(c_schema_id)
	arg_backend := gi.NewPointerArgument(tmp)
	args := []gi.Argument{arg_schema_id, arg_backend}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_schema_id)
	result.P = ret.Pointer()
	return
}

// g_settings_new_with_backend_and_path
// container is not nil, container is Settings
// is constructor
func NewSettingsWithBackendAndPath(schema_id string, backend ISettingsBackend, path string) (result Settings) {
	iv, err := _I.Get(1092, "Settings", "new_with_backend_and_path")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_schema_id := gi.CString(schema_id)
	var tmp unsafe.Pointer
	if backend != nil {
		tmp = backend.P_SettingsBackend()
	}
	c_path := gi.CString(path)
	arg_schema_id := gi.NewStringArgument(c_schema_id)
	arg_backend := gi.NewPointerArgument(tmp)
	arg_path := gi.NewStringArgument(c_path)
	args := []gi.Argument{arg_schema_id, arg_backend, arg_path}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_schema_id)
	gi.Free(c_path)
	result.P = ret.Pointer()
	return
}

// g_settings_new_with_path
// container is not nil, container is Settings
// is constructor
func NewSettingsWithPath(schema_id string, path string) (result Settings) {
	iv, err := _I.Get(1093, "Settings", "new_with_path")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_schema_id := gi.CString(schema_id)
	c_path := gi.CString(path)
	arg_schema_id := gi.NewStringArgument(c_schema_id)
	arg_path := gi.NewStringArgument(c_path)
	args := []gi.Argument{arg_schema_id, arg_path}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_schema_id)
	gi.Free(c_path)
	result.P = ret.Pointer()
	return
}

// g_settings_unbind
// container is not nil, container is Settings
// is method
// arg0Type tag: interface, isPtr: true
func SettingsUnbind1(object gobject.IObject, property string) {
	iv, err := _I.Get(1097, "Settings", "unbind")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if object != nil {
		tmp = object.P_Object()
	}
	c_property := gi.CString(property)
	arg_object := gi.NewPointerArgument(tmp)
	arg_property := gi.NewStringArgument(c_property)
	args := []gi.Argument{arg_object, arg_property}
	iv.Call(args, nil, nil)
	gi.Free(c_property)
}

// g_settings_apply
// container is not nil, container is Settings
// is method
func (v Settings) Apply() {
	iv, err := _I.Get(1098, "Settings", "apply")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	iv.Call(args, nil, nil)
}

// g_settings_bind
// container is not nil, container is Settings
// is method
func (v Settings) Bind(key string, object gobject.IObject, property string, flags SettingsBindFlags) {
	iv, err := _I.Get(1099, "Settings", "bind")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_key := gi.CString(key)
	var tmp unsafe.Pointer
	if object != nil {
		tmp = object.P_Object()
	}
	c_property := gi.CString(property)
	arg_v := gi.NewPointerArgument(v.P)
	arg_key := gi.NewStringArgument(c_key)
	arg_object := gi.NewPointerArgument(tmp)
	arg_property := gi.NewStringArgument(c_property)
	arg_flags := gi.NewIntArgument(int(flags))
	args := []gi.Argument{arg_v, arg_key, arg_object, arg_property, arg_flags}
	iv.Call(args, nil, nil)
	gi.Free(c_key)
	gi.Free(c_property)
}

// g_settings_bind_writable
// container is not nil, container is Settings
// is method
func (v Settings) BindWritable(key string, object gobject.IObject, property string, inverted bool) {
	iv, err := _I.Get(1100, "Settings", "bind_writable")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_key := gi.CString(key)
	var tmp unsafe.Pointer
	if object != nil {
		tmp = object.P_Object()
	}
	c_property := gi.CString(property)
	arg_v := gi.NewPointerArgument(v.P)
	arg_key := gi.NewStringArgument(c_key)
	arg_object := gi.NewPointerArgument(tmp)
	arg_property := gi.NewStringArgument(c_property)
	arg_inverted := gi.NewBoolArgument(inverted)
	args := []gi.Argument{arg_v, arg_key, arg_object, arg_property, arg_inverted}
	iv.Call(args, nil, nil)
	gi.Free(c_key)
	gi.Free(c_property)
}

// g_settings_create_action
// container is not nil, container is Settings
// is method
func (v Settings) CreateAction(key string) (result Action) {
	iv, err := _I.Get(1101, "Settings", "create_action")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_key := gi.CString(key)
	arg_v := gi.NewPointerArgument(v.P)
	arg_key := gi.NewStringArgument(c_key)
	args := []gi.Argument{arg_v, arg_key}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_key)
	result.P = ret.Pointer()
	return
}

// g_settings_delay
// container is not nil, container is Settings
// is method
func (v Settings) Delay() {
	iv, err := _I.Get(1102, "Settings", "delay")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	iv.Call(args, nil, nil)
}

// g_settings_get_boolean
// container is not nil, container is Settings
// is method
func (v Settings) GetBoolean(key string) (result bool) {
	iv, err := _I.Get(1103, "Settings", "get_boolean")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_key := gi.CString(key)
	arg_v := gi.NewPointerArgument(v.P)
	arg_key := gi.NewStringArgument(c_key)
	args := []gi.Argument{arg_v, arg_key}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_key)
	result = ret.Bool()
	return
}

// g_settings_get_child
// container is not nil, container is Settings
// is method
func (v Settings) GetChild(name string) (result Settings) {
	iv, err := _I.Get(1104, "Settings", "get_child")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_name := gi.CString(name)
	arg_v := gi.NewPointerArgument(v.P)
	arg_name := gi.NewStringArgument(c_name)
	args := []gi.Argument{arg_v, arg_name}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_name)
	result.P = ret.Pointer()
	return
}

// g_settings_get_default_value
// container is not nil, container is Settings
// is method
func (v Settings) GetDefaultValue(key string) (result glib.Variant) {
	iv, err := _I.Get(1105, "Settings", "get_default_value")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_key := gi.CString(key)
	arg_v := gi.NewPointerArgument(v.P)
	arg_key := gi.NewStringArgument(c_key)
	args := []gi.Argument{arg_v, arg_key}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_key)
	result.P = ret.Pointer()
	return
}

// g_settings_get_double
// container is not nil, container is Settings
// is method
func (v Settings) GetDouble(key string) (result float64) {
	iv, err := _I.Get(1106, "Settings", "get_double")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_key := gi.CString(key)
	arg_v := gi.NewPointerArgument(v.P)
	arg_key := gi.NewStringArgument(c_key)
	args := []gi.Argument{arg_v, arg_key}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_key)
	result = ret.Double()
	return
}

// g_settings_get_enum
// container is not nil, container is Settings
// is method
func (v Settings) GetEnum(key string) (result int32) {
	iv, err := _I.Get(1107, "Settings", "get_enum")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_key := gi.CString(key)
	arg_v := gi.NewPointerArgument(v.P)
	arg_key := gi.NewStringArgument(c_key)
	args := []gi.Argument{arg_v, arg_key}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_key)
	result = ret.Int32()
	return
}

// g_settings_get_flags
// container is not nil, container is Settings
// is method
func (v Settings) GetFlags(key string) (result uint32) {
	iv, err := _I.Get(1108, "Settings", "get_flags")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_key := gi.CString(key)
	arg_v := gi.NewPointerArgument(v.P)
	arg_key := gi.NewStringArgument(c_key)
	args := []gi.Argument{arg_v, arg_key}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_key)
	result = ret.Uint32()
	return
}

// g_settings_get_has_unapplied
// container is not nil, container is Settings
// is method
func (v Settings) GetHasUnapplied() (result bool) {
	iv, err := _I.Get(1109, "Settings", "get_has_unapplied")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_settings_get_int
// container is not nil, container is Settings
// is method
func (v Settings) GetInt(key string) (result int32) {
	iv, err := _I.Get(1110, "Settings", "get_int")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_key := gi.CString(key)
	arg_v := gi.NewPointerArgument(v.P)
	arg_key := gi.NewStringArgument(c_key)
	args := []gi.Argument{arg_v, arg_key}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_key)
	result = ret.Int32()
	return
}

// g_settings_get_int64
// container is not nil, container is Settings
// is method
func (v Settings) GetInt64(key string) (result int64) {
	iv, err := _I.Get(1111, "Settings", "get_int64")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_key := gi.CString(key)
	arg_v := gi.NewPointerArgument(v.P)
	arg_key := gi.NewStringArgument(c_key)
	args := []gi.Argument{arg_v, arg_key}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_key)
	result = ret.Int64()
	return
}

// g_settings_get_mapped
// container is not nil, container is Settings
// is method
func (v Settings) GetMapped(key string, mapping int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) (result unsafe.Pointer) {
	iv, err := _I.Get(1112, "Settings", "get_mapped")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_key := gi.CString(key)
	arg_v := gi.NewPointerArgument(v.P)
	arg_key := gi.NewStringArgument(c_key)
	arg_mapping := gi.NewIntArgument(mapping) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_v, arg_key, arg_mapping, arg_user_data}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_key)
	result = ret.Pointer()
	return
}

// g_settings_get_range
// container is not nil, container is Settings
// is method
func (v Settings) GetRange(key string) (result glib.Variant) {
	iv, err := _I.Get(1113, "Settings", "get_range")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_key := gi.CString(key)
	arg_v := gi.NewPointerArgument(v.P)
	arg_key := gi.NewStringArgument(c_key)
	args := []gi.Argument{arg_v, arg_key}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_key)
	result.P = ret.Pointer()
	return
}

// g_settings_get_string
// container is not nil, container is Settings
// is method
func (v Settings) GetString(key string) (result string) {
	iv, err := _I.Get(1114, "Settings", "get_string")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_key := gi.CString(key)
	arg_v := gi.NewPointerArgument(v.P)
	arg_key := gi.NewStringArgument(c_key)
	args := []gi.Argument{arg_v, arg_key}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_key)
	result = ret.String().Take()
	return
}

// g_settings_get_strv
// container is not nil, container is Settings
// is method
func (v Settings) GetStrv(key string) (result gi.CStrArray) {
	iv, err := _I.Get(1115, "Settings", "get_strv")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_key := gi.CString(key)
	arg_v := gi.NewPointerArgument(v.P)
	arg_key := gi.NewStringArgument(c_key)
	args := []gi.Argument{arg_v, arg_key}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_key)
	result = gi.CStrArray{P: ret.Pointer(), Len: -1}
	result.SetLenZT()
	return
}

// g_settings_get_uint
// container is not nil, container is Settings
// is method
func (v Settings) GetUint(key string) (result uint32) {
	iv, err := _I.Get(1116, "Settings", "get_uint")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_key := gi.CString(key)
	arg_v := gi.NewPointerArgument(v.P)
	arg_key := gi.NewStringArgument(c_key)
	args := []gi.Argument{arg_v, arg_key}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_key)
	result = ret.Uint32()
	return
}

// g_settings_get_uint64
// container is not nil, container is Settings
// is method
func (v Settings) GetUint64(key string) (result uint64) {
	iv, err := _I.Get(1117, "Settings", "get_uint64")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_key := gi.CString(key)
	arg_v := gi.NewPointerArgument(v.P)
	arg_key := gi.NewStringArgument(c_key)
	args := []gi.Argument{arg_v, arg_key}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_key)
	result = ret.Uint64()
	return
}

// g_settings_get_user_value
// container is not nil, container is Settings
// is method
func (v Settings) GetUserValue(key string) (result glib.Variant) {
	iv, err := _I.Get(1118, "Settings", "get_user_value")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_key := gi.CString(key)
	arg_v := gi.NewPointerArgument(v.P)
	arg_key := gi.NewStringArgument(c_key)
	args := []gi.Argument{arg_v, arg_key}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_key)
	result.P = ret.Pointer()
	return
}

// g_settings_get_value
// container is not nil, container is Settings
// is method
func (v Settings) GetValue(key string) (result glib.Variant) {
	iv, err := _I.Get(1119, "Settings", "get_value")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_key := gi.CString(key)
	arg_v := gi.NewPointerArgument(v.P)
	arg_key := gi.NewStringArgument(c_key)
	args := []gi.Argument{arg_v, arg_key}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_key)
	result.P = ret.Pointer()
	return
}

// g_settings_is_writable
// container is not nil, container is Settings
// is method
func (v Settings) IsWritable(name string) (result bool) {
	iv, err := _I.Get(1120, "Settings", "is_writable")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_name := gi.CString(name)
	arg_v := gi.NewPointerArgument(v.P)
	arg_name := gi.NewStringArgument(c_name)
	args := []gi.Argument{arg_v, arg_name}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_name)
	result = ret.Bool()
	return
}

// g_settings_list_children
// container is not nil, container is Settings
// is method
func (v Settings) ListChildren() (result gi.CStrArray) {
	iv, err := _I.Get(1121, "Settings", "list_children")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = gi.CStrArray{P: ret.Pointer(), Len: -1}
	result.SetLenZT()
	return
}

// g_settings_list_keys
// container is not nil, container is Settings
// is method
func (v Settings) ListKeys() (result gi.CStrArray) {
	iv, err := _I.Get(1122, "Settings", "list_keys")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = gi.CStrArray{P: ret.Pointer(), Len: -1}
	result.SetLenZT()
	return
}

// g_settings_range_check
// container is not nil, container is Settings
// is method
func (v Settings) RangeCheck(key string, value glib.Variant) (result bool) {
	iv, err := _I.Get(1123, "Settings", "range_check")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_key := gi.CString(key)
	arg_v := gi.NewPointerArgument(v.P)
	arg_key := gi.NewStringArgument(c_key)
	arg_value := gi.NewPointerArgument(value.P)
	args := []gi.Argument{arg_v, arg_key, arg_value}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_key)
	result = ret.Bool()
	return
}

// g_settings_reset
// container is not nil, container is Settings
// is method
func (v Settings) Reset(key string) {
	iv, err := _I.Get(1124, "Settings", "reset")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_key := gi.CString(key)
	arg_v := gi.NewPointerArgument(v.P)
	arg_key := gi.NewStringArgument(c_key)
	args := []gi.Argument{arg_v, arg_key}
	iv.Call(args, nil, nil)
	gi.Free(c_key)
}

// g_settings_revert
// container is not nil, container is Settings
// is method
func (v Settings) Revert() {
	iv, err := _I.Get(1125, "Settings", "revert")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	iv.Call(args, nil, nil)
}

// g_settings_set_boolean
// container is not nil, container is Settings
// is method
func (v Settings) SetBoolean(key string, value bool) (result bool) {
	iv, err := _I.Get(1126, "Settings", "set_boolean")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_key := gi.CString(key)
	arg_v := gi.NewPointerArgument(v.P)
	arg_key := gi.NewStringArgument(c_key)
	arg_value := gi.NewBoolArgument(value)
	args := []gi.Argument{arg_v, arg_key, arg_value}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_key)
	result = ret.Bool()
	return
}

// g_settings_set_double
// container is not nil, container is Settings
// is method
func (v Settings) SetDouble(key string, value float64) (result bool) {
	iv, err := _I.Get(1127, "Settings", "set_double")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_key := gi.CString(key)
	arg_v := gi.NewPointerArgument(v.P)
	arg_key := gi.NewStringArgument(c_key)
	arg_value := gi.NewDoubleArgument(value)
	args := []gi.Argument{arg_v, arg_key, arg_value}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_key)
	result = ret.Bool()
	return
}

// g_settings_set_enum
// container is not nil, container is Settings
// is method
func (v Settings) SetEnum(key string, value int32) (result bool) {
	iv, err := _I.Get(1128, "Settings", "set_enum")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_key := gi.CString(key)
	arg_v := gi.NewPointerArgument(v.P)
	arg_key := gi.NewStringArgument(c_key)
	arg_value := gi.NewInt32Argument(value)
	args := []gi.Argument{arg_v, arg_key, arg_value}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_key)
	result = ret.Bool()
	return
}

// g_settings_set_flags
// container is not nil, container is Settings
// is method
func (v Settings) SetFlags(key string, value uint32) (result bool) {
	iv, err := _I.Get(1129, "Settings", "set_flags")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_key := gi.CString(key)
	arg_v := gi.NewPointerArgument(v.P)
	arg_key := gi.NewStringArgument(c_key)
	arg_value := gi.NewUint32Argument(value)
	args := []gi.Argument{arg_v, arg_key, arg_value}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_key)
	result = ret.Bool()
	return
}

// g_settings_set_int
// container is not nil, container is Settings
// is method
func (v Settings) SetInt(key string, value int32) (result bool) {
	iv, err := _I.Get(1130, "Settings", "set_int")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_key := gi.CString(key)
	arg_v := gi.NewPointerArgument(v.P)
	arg_key := gi.NewStringArgument(c_key)
	arg_value := gi.NewInt32Argument(value)
	args := []gi.Argument{arg_v, arg_key, arg_value}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_key)
	result = ret.Bool()
	return
}

// g_settings_set_int64
// container is not nil, container is Settings
// is method
func (v Settings) SetInt64(key string, value int64) (result bool) {
	iv, err := _I.Get(1131, "Settings", "set_int64")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_key := gi.CString(key)
	arg_v := gi.NewPointerArgument(v.P)
	arg_key := gi.NewStringArgument(c_key)
	arg_value := gi.NewInt64Argument(value)
	args := []gi.Argument{arg_v, arg_key, arg_value}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_key)
	result = ret.Bool()
	return
}

// g_settings_set_string
// container is not nil, container is Settings
// is method
func (v Settings) SetString(key string, value string) (result bool) {
	iv, err := _I.Get(1132, "Settings", "set_string")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_key := gi.CString(key)
	c_value := gi.CString(value)
	arg_v := gi.NewPointerArgument(v.P)
	arg_key := gi.NewStringArgument(c_key)
	arg_value := gi.NewStringArgument(c_value)
	args := []gi.Argument{arg_v, arg_key, arg_value}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_key)
	gi.Free(c_value)
	result = ret.Bool()
	return
}

// g_settings_set_strv
// container is not nil, container is Settings
// is method
func (v Settings) SetStrv(key string, value gi.CStrArray) (result bool) {
	iv, err := _I.Get(1133, "Settings", "set_strv")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_key := gi.CString(key)
	arg_v := gi.NewPointerArgument(v.P)
	arg_key := gi.NewStringArgument(c_key)
	arg_value := gi.NewPointerArgument(value.P)
	args := []gi.Argument{arg_v, arg_key, arg_value}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_key)
	result = ret.Bool()
	return
}

// g_settings_set_uint
// container is not nil, container is Settings
// is method
func (v Settings) SetUint(key string, value uint32) (result bool) {
	iv, err := _I.Get(1134, "Settings", "set_uint")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_key := gi.CString(key)
	arg_v := gi.NewPointerArgument(v.P)
	arg_key := gi.NewStringArgument(c_key)
	arg_value := gi.NewUint32Argument(value)
	args := []gi.Argument{arg_v, arg_key, arg_value}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_key)
	result = ret.Bool()
	return
}

// g_settings_set_uint64
// container is not nil, container is Settings
// is method
func (v Settings) SetUint64(key string, value uint64) (result bool) {
	iv, err := _I.Get(1135, "Settings", "set_uint64")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_key := gi.CString(key)
	arg_v := gi.NewPointerArgument(v.P)
	arg_key := gi.NewStringArgument(c_key)
	arg_value := gi.NewUint64Argument(value)
	args := []gi.Argument{arg_v, arg_key, arg_value}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_key)
	result = ret.Bool()
	return
}

// g_settings_set_value
// container is not nil, container is Settings
// is method
func (v Settings) SetValue(key string, value glib.Variant) (result bool) {
	iv, err := _I.Get(1136, "Settings", "set_value")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_key := gi.CString(key)
	arg_v := gi.NewPointerArgument(v.P)
	arg_key := gi.NewStringArgument(c_key)
	arg_value := gi.NewPointerArgument(value.P)
	args := []gi.Argument{arg_v, arg_key, arg_value}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_key)
	result = ret.Bool()
	return
}

// Object SettingsBackend
type SettingsBackend struct {
	gobject.Object
}

func WrapSettingsBackend(p unsafe.Pointer) (r SettingsBackend) { r.P = p; return }

type ISettingsBackend interface{ P_SettingsBackend() unsafe.Pointer }

func (v SettingsBackend) P_SettingsBackend() unsafe.Pointer { return v.P }
func SettingsBackendGetType() gi.GType {
	ret := _I.GetGType(217, "SettingsBackend")
	return ret
}

// g_settings_backend_flatten_tree
// container is not nil, container is SettingsBackend
// is method
// arg0Type tag: interface, isPtr: true
func SettingsBackendFlattenTree1(tree glib.Tree) (path string, keys gi.CStrArray, values gi.PointerArray) {
	iv, err := _I.Get(1137, "SettingsBackend", "flatten_tree")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var outArgs [3]gi.Argument
	arg_tree := gi.NewPointerArgument(tree.P)
	arg_path := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	arg_keys := gi.NewPointerArgument(unsafe.Pointer(&outArgs[1]))
	arg_values := gi.NewPointerArgument(unsafe.Pointer(&outArgs[2]))
	args := []gi.Argument{arg_tree, arg_path, arg_keys, arg_values}
	iv.Call(args, nil, &outArgs[0])
	path = outArgs[0].String().Take()
	keys.P = outArgs[1].Pointer()
	values.P = outArgs[2].Pointer()
	values.Len = -1
	values.SetLenZT()
	return
}

// g_settings_backend_changed
// container is not nil, container is SettingsBackend
// is method
func (v SettingsBackend) Changed(key string, origin_tag unsafe.Pointer) {
	iv, err := _I.Get(1139, "SettingsBackend", "changed")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_key := gi.CString(key)
	arg_v := gi.NewPointerArgument(v.P)
	arg_key := gi.NewStringArgument(c_key)
	arg_origin_tag := gi.NewPointerArgument(origin_tag)
	args := []gi.Argument{arg_v, arg_key, arg_origin_tag}
	iv.Call(args, nil, nil)
	gi.Free(c_key)
}

// g_settings_backend_changed_tree
// container is not nil, container is SettingsBackend
// is method
func (v SettingsBackend) ChangedTree(tree glib.Tree, origin_tag unsafe.Pointer) {
	iv, err := _I.Get(1140, "SettingsBackend", "changed_tree")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_tree := gi.NewPointerArgument(tree.P)
	arg_origin_tag := gi.NewPointerArgument(origin_tag)
	args := []gi.Argument{arg_v, arg_tree, arg_origin_tag}
	iv.Call(args, nil, nil)
}

// g_settings_backend_keys_changed
// container is not nil, container is SettingsBackend
// is method
func (v SettingsBackend) KeysChanged(path string, items gi.CStrArray, origin_tag unsafe.Pointer) {
	iv, err := _I.Get(1141, "SettingsBackend", "keys_changed")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_path := gi.CString(path)
	arg_v := gi.NewPointerArgument(v.P)
	arg_path := gi.NewStringArgument(c_path)
	arg_items := gi.NewPointerArgument(items.P)
	arg_origin_tag := gi.NewPointerArgument(origin_tag)
	args := []gi.Argument{arg_v, arg_path, arg_items, arg_origin_tag}
	iv.Call(args, nil, nil)
	gi.Free(c_path)
}

// g_settings_backend_path_changed
// container is not nil, container is SettingsBackend
// is method
func (v SettingsBackend) PathChanged(path string, origin_tag unsafe.Pointer) {
	iv, err := _I.Get(1142, "SettingsBackend", "path_changed")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_path := gi.CString(path)
	arg_v := gi.NewPointerArgument(v.P)
	arg_path := gi.NewStringArgument(c_path)
	arg_origin_tag := gi.NewPointerArgument(origin_tag)
	args := []gi.Argument{arg_v, arg_path, arg_origin_tag}
	iv.Call(args, nil, nil)
	gi.Free(c_path)
}

// g_settings_backend_path_writable_changed
// container is not nil, container is SettingsBackend
// is method
func (v SettingsBackend) PathWritableChanged(path string) {
	iv, err := _I.Get(1143, "SettingsBackend", "path_writable_changed")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_path := gi.CString(path)
	arg_v := gi.NewPointerArgument(v.P)
	arg_path := gi.NewStringArgument(c_path)
	args := []gi.Argument{arg_v, arg_path}
	iv.Call(args, nil, nil)
	gi.Free(c_path)
}

// g_settings_backend_writable_changed
// container is not nil, container is SettingsBackend
// is method
func (v SettingsBackend) WritableChanged(key string) {
	iv, err := _I.Get(1144, "SettingsBackend", "writable_changed")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_key := gi.CString(key)
	arg_v := gi.NewPointerArgument(v.P)
	arg_key := gi.NewStringArgument(c_key)
	args := []gi.Argument{arg_v, arg_key}
	iv.Call(args, nil, nil)
	gi.Free(c_key)
}

// ignore GType struct SettingsBackendClass
// Struct SettingsBackendPrivate
type SettingsBackendPrivate struct {
	P unsafe.Pointer
}

func SettingsBackendPrivateGetType() gi.GType {
	ret := _I.GetGType(218, "SettingsBackendPrivate")
	return ret
}

// Flags SettingsBindFlags
type SettingsBindFlags int

const (
	SettingsBindFlagsDefault       SettingsBindFlags = 0
	SettingsBindFlagsGet           SettingsBindFlags = 1
	SettingsBindFlagsSet           SettingsBindFlags = 2
	SettingsBindFlagsNoSensitivity SettingsBindFlags = 4
	SettingsBindFlagsGetNoChanges  SettingsBindFlags = 8
	SettingsBindFlagsInvertBoolean SettingsBindFlags = 16
)

func SettingsBindFlagsGetType() gi.GType {
	ret := _I.GetGType(219, "SettingsBindFlags")
	return ret
}

type SettingsBindGetMappingStruct struct {
	F_value   gobject.Value
	F_variant glib.Variant
}

//export mySettingsBindGetMapping
func mySettingsBindGetMapping(value *C.GValue, variant *C.GVariant, user_data C.gpointer) {
	fn := gi.GetFunc(uint(uintptr(user_data)))
	args := SettingsBindGetMappingStruct{
		F_value:   gobject.Value{P: unsafe.Pointer(value)},
		F_variant: glib.Variant{P: unsafe.Pointer(variant)},
	}
	fn(args)
}

type SettingsBindSetMappingStruct struct {
	F_value         gobject.Value
	F_expected_type glib.VariantType
}

//export mySettingsBindSetMapping
func mySettingsBindSetMapping(value *C.GValue, expected_type *C.GVariantType, user_data C.gpointer) {
	fn := gi.GetFunc(uint(uintptr(user_data)))
	args := SettingsBindSetMappingStruct{
		F_value:         gobject.Value{P: unsafe.Pointer(value)},
		F_expected_type: glib.VariantType{P: unsafe.Pointer(expected_type)},
	}
	fn(args)
}

// ignore GType struct SettingsClass
type SettingsGetMappingStruct struct {
	F_value glib.Variant
}

//export mySettingsGetMapping
func mySettingsGetMapping(value *C.GVariant, user_data C.gpointer) {
	fn := gi.GetFunc(uint(uintptr(user_data)))
	args := SettingsGetMappingStruct{
		F_value: glib.Variant{P: unsafe.Pointer(value)},
	}
	fn(args)
}

// Struct SettingsPrivate
type SettingsPrivate struct {
	P unsafe.Pointer
}

func SettingsPrivateGetType() gi.GType {
	ret := _I.GetGType(220, "SettingsPrivate")
	return ret
}

// Struct SettingsSchema
type SettingsSchema struct {
	P unsafe.Pointer
}

func SettingsSchemaGetType() gi.GType {
	ret := _I.GetGType(221, "SettingsSchema")
	return ret
}

// g_settings_schema_get_id
// container is not nil, container is SettingsSchema
// is method
func (v SettingsSchema) GetId() (result string) {
	iv, err := _I.Get(1145, "SettingsSchema", "get_id")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Take()
	return
}

// g_settings_schema_get_key
// container is not nil, container is SettingsSchema
// is method
func (v SettingsSchema) GetKey(name string) (result SettingsSchemaKey) {
	iv, err := _I.Get(1146, "SettingsSchema", "get_key")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_name := gi.CString(name)
	arg_v := gi.NewPointerArgument(v.P)
	arg_name := gi.NewStringArgument(c_name)
	args := []gi.Argument{arg_v, arg_name}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_name)
	result.P = ret.Pointer()
	return
}

// g_settings_schema_get_path
// container is not nil, container is SettingsSchema
// is method
func (v SettingsSchema) GetPath() (result string) {
	iv, err := _I.Get(1147, "SettingsSchema", "get_path")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Take()
	return
}

// g_settings_schema_has_key
// container is not nil, container is SettingsSchema
// is method
func (v SettingsSchema) HasKey(name string) (result bool) {
	iv, err := _I.Get(1148, "SettingsSchema", "has_key")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_name := gi.CString(name)
	arg_v := gi.NewPointerArgument(v.P)
	arg_name := gi.NewStringArgument(c_name)
	args := []gi.Argument{arg_v, arg_name}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_name)
	result = ret.Bool()
	return
}

// g_settings_schema_list_children
// container is not nil, container is SettingsSchema
// is method
func (v SettingsSchema) ListChildren() (result gi.CStrArray) {
	iv, err := _I.Get(1149, "SettingsSchema", "list_children")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = gi.CStrArray{P: ret.Pointer(), Len: -1}
	result.SetLenZT()
	return
}

// g_settings_schema_list_keys
// container is not nil, container is SettingsSchema
// is method
func (v SettingsSchema) ListKeys() (result gi.CStrArray) {
	iv, err := _I.Get(1150, "SettingsSchema", "list_keys")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = gi.CStrArray{P: ret.Pointer(), Len: -1}
	result.SetLenZT()
	return
}

// g_settings_schema_ref
// container is not nil, container is SettingsSchema
// is method
func (v SettingsSchema) Ref() (result SettingsSchema) {
	iv, err := _I.Get(1151, "SettingsSchema", "ref")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_settings_schema_unref
// container is not nil, container is SettingsSchema
// is method
func (v SettingsSchema) Unref() {
	iv, err := _I.Get(1152, "SettingsSchema", "unref")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	iv.Call(args, nil, nil)
}

// Struct SettingsSchemaKey
type SettingsSchemaKey struct {
	P unsafe.Pointer
}

func SettingsSchemaKeyGetType() gi.GType {
	ret := _I.GetGType(222, "SettingsSchemaKey")
	return ret
}

// g_settings_schema_key_get_default_value
// container is not nil, container is SettingsSchemaKey
// is method
func (v SettingsSchemaKey) GetDefaultValue() (result glib.Variant) {
	iv, err := _I.Get(1153, "SettingsSchemaKey", "get_default_value")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_settings_schema_key_get_description
// container is not nil, container is SettingsSchemaKey
// is method
func (v SettingsSchemaKey) GetDescription() (result string) {
	iv, err := _I.Get(1154, "SettingsSchemaKey", "get_description")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Take()
	return
}

// g_settings_schema_key_get_name
// container is not nil, container is SettingsSchemaKey
// is method
func (v SettingsSchemaKey) GetName() (result string) {
	iv, err := _I.Get(1155, "SettingsSchemaKey", "get_name")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Take()
	return
}

// g_settings_schema_key_get_range
// container is not nil, container is SettingsSchemaKey
// is method
func (v SettingsSchemaKey) GetRange() (result glib.Variant) {
	iv, err := _I.Get(1156, "SettingsSchemaKey", "get_range")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_settings_schema_key_get_summary
// container is not nil, container is SettingsSchemaKey
// is method
func (v SettingsSchemaKey) GetSummary() (result string) {
	iv, err := _I.Get(1157, "SettingsSchemaKey", "get_summary")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Take()
	return
}

// g_settings_schema_key_get_value_type
// container is not nil, container is SettingsSchemaKey
// is method
func (v SettingsSchemaKey) GetValueType() (result glib.VariantType) {
	iv, err := _I.Get(1158, "SettingsSchemaKey", "get_value_type")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_settings_schema_key_range_check
// container is not nil, container is SettingsSchemaKey
// is method
func (v SettingsSchemaKey) RangeCheck(value glib.Variant) (result bool) {
	iv, err := _I.Get(1159, "SettingsSchemaKey", "range_check")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_value := gi.NewPointerArgument(value.P)
	args := []gi.Argument{arg_v, arg_value}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_settings_schema_key_ref
// container is not nil, container is SettingsSchemaKey
// is method
func (v SettingsSchemaKey) Ref() (result SettingsSchemaKey) {
	iv, err := _I.Get(1160, "SettingsSchemaKey", "ref")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_settings_schema_key_unref
// container is not nil, container is SettingsSchemaKey
// is method
func (v SettingsSchemaKey) Unref() {
	iv, err := _I.Get(1161, "SettingsSchemaKey", "unref")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	iv.Call(args, nil, nil)
}

// Struct SettingsSchemaSource
type SettingsSchemaSource struct {
	P unsafe.Pointer
}

func SettingsSchemaSourceGetType() gi.GType {
	ret := _I.GetGType(223, "SettingsSchemaSource")
	return ret
}

// g_settings_schema_source_new_from_directory
// container is not nil, container is SettingsSchemaSource
// is constructor
func NewSettingsSchemaSourceFromDirectory(directory string, parent SettingsSchemaSource, trusted bool) (result SettingsSchemaSource, err error) {
	iv, err := _I.Get(1162, "SettingsSchemaSource", "new_from_directory")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	c_directory := gi.CString(directory)
	arg_directory := gi.NewStringArgument(c_directory)
	arg_parent := gi.NewPointerArgument(parent.P)
	arg_trusted := gi.NewBoolArgument(trusted)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_directory, arg_parent, arg_trusted, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	gi.Free(c_directory)
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// g_settings_schema_source_list_schemas
// container is not nil, container is SettingsSchemaSource
// is method
func (v SettingsSchemaSource) ListSchemas(recursive bool) (non_relocatable gi.CStrArray, relocatable gi.CStrArray) {
	iv, err := _I.Get(1163, "SettingsSchemaSource", "list_schemas")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var outArgs [2]gi.Argument
	arg_v := gi.NewPointerArgument(v.P)
	arg_recursive := gi.NewBoolArgument(recursive)
	arg_non_relocatable := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	arg_relocatable := gi.NewPointerArgument(unsafe.Pointer(&outArgs[1]))
	args := []gi.Argument{arg_v, arg_recursive, arg_non_relocatable, arg_relocatable}
	iv.Call(args, nil, &outArgs[0])
	non_relocatable.P = outArgs[0].Pointer()
	relocatable.P = outArgs[1].Pointer()
	return
}

// g_settings_schema_source_lookup
// container is not nil, container is SettingsSchemaSource
// is method
func (v SettingsSchemaSource) Lookup(schema_id string, recursive bool) (result SettingsSchema) {
	iv, err := _I.Get(1164, "SettingsSchemaSource", "lookup")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_schema_id := gi.CString(schema_id)
	arg_v := gi.NewPointerArgument(v.P)
	arg_schema_id := gi.NewStringArgument(c_schema_id)
	arg_recursive := gi.NewBoolArgument(recursive)
	args := []gi.Argument{arg_v, arg_schema_id, arg_recursive}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_schema_id)
	result.P = ret.Pointer()
	return
}

// g_settings_schema_source_ref
// container is not nil, container is SettingsSchemaSource
// is method
func (v SettingsSchemaSource) Ref() (result SettingsSchemaSource) {
	iv, err := _I.Get(1165, "SettingsSchemaSource", "ref")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_settings_schema_source_unref
// container is not nil, container is SettingsSchemaSource
// is method
func (v SettingsSchemaSource) Unref() {
	iv, err := _I.Get(1166, "SettingsSchemaSource", "unref")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	iv.Call(args, nil, nil)
}

// Object SimpleAction
type SimpleAction struct {
	ActionIfc
	gobject.Object
}

func WrapSimpleAction(p unsafe.Pointer) (r SimpleAction) { r.P = p; return }

type ISimpleAction interface{ P_SimpleAction() unsafe.Pointer }

func (v SimpleAction) P_SimpleAction() unsafe.Pointer { return v.P }
func (v SimpleAction) P_Action() unsafe.Pointer       { return v.P }
func SimpleActionGetType() gi.GType {
	ret := _I.GetGType(224, "SimpleAction")
	return ret
}

// g_simple_action_new
// container is not nil, container is SimpleAction
// is constructor
func NewSimpleAction(name string, parameter_type glib.VariantType) (result SimpleAction) {
	iv, err := _I.Get(1168, "SimpleAction", "new")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_name := gi.CString(name)
	arg_name := gi.NewStringArgument(c_name)
	arg_parameter_type := gi.NewPointerArgument(parameter_type.P)
	args := []gi.Argument{arg_name, arg_parameter_type}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_name)
	result.P = ret.Pointer()
	return
}

// g_simple_action_new_stateful
// container is not nil, container is SimpleAction
// is constructor
func NewSimpleActionStateful(name string, parameter_type glib.VariantType, state glib.Variant) (result SimpleAction) {
	iv, err := _I.Get(1169, "SimpleAction", "new_stateful")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_name := gi.CString(name)
	arg_name := gi.NewStringArgument(c_name)
	arg_parameter_type := gi.NewPointerArgument(parameter_type.P)
	arg_state := gi.NewPointerArgument(state.P)
	args := []gi.Argument{arg_name, arg_parameter_type, arg_state}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_name)
	result.P = ret.Pointer()
	return
}

// g_simple_action_set_enabled
// container is not nil, container is SimpleAction
// is method
func (v SimpleAction) SetEnabled(enabled bool) {
	iv, err := _I.Get(1170, "SimpleAction", "set_enabled")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_enabled := gi.NewBoolArgument(enabled)
	args := []gi.Argument{arg_v, arg_enabled}
	iv.Call(args, nil, nil)
}

// g_simple_action_set_state
// container is not nil, container is SimpleAction
// is method
func (v SimpleAction) SetState(value glib.Variant) {
	iv, err := _I.Get(1171, "SimpleAction", "set_state")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_value := gi.NewPointerArgument(value.P)
	args := []gi.Argument{arg_v, arg_value}
	iv.Call(args, nil, nil)
}

// g_simple_action_set_state_hint
// container is not nil, container is SimpleAction
// is method
func (v SimpleAction) SetStateHint(state_hint glib.Variant) {
	iv, err := _I.Get(1172, "SimpleAction", "set_state_hint")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_state_hint := gi.NewPointerArgument(state_hint.P)
	args := []gi.Argument{arg_v, arg_state_hint}
	iv.Call(args, nil, nil)
}

// Object SimpleActionGroup
type SimpleActionGroup struct {
	ActionGroupIfc
	ActionMapIfc
	gobject.Object
}

func WrapSimpleActionGroup(p unsafe.Pointer) (r SimpleActionGroup) { r.P = p; return }

type ISimpleActionGroup interface{ P_SimpleActionGroup() unsafe.Pointer }

func (v SimpleActionGroup) P_SimpleActionGroup() unsafe.Pointer { return v.P }
func (v SimpleActionGroup) P_ActionGroup() unsafe.Pointer       { return v.P }
func (v SimpleActionGroup) P_ActionMap() unsafe.Pointer         { return v.P }
func SimpleActionGroupGetType() gi.GType {
	ret := _I.GetGType(225, "SimpleActionGroup")
	return ret
}

// g_simple_action_group_new
// container is not nil, container is SimpleActionGroup
// is constructor
func NewSimpleActionGroup() (result SimpleActionGroup) {
	iv, err := _I.Get(1173, "SimpleActionGroup", "new")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var ret gi.Argument
	iv.Call(nil, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_simple_action_group_add_entries
// container is not nil, container is SimpleActionGroup
// is method
// arg 0 entries lenArgIdx 1
func (v SimpleActionGroup) AddEntries(entries unsafe.Pointer, n_entries int32, user_data unsafe.Pointer) {
	iv, err := _I.Get(1174, "SimpleActionGroup", "add_entries")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_entries := gi.NewPointerArgument(entries)
	arg_n_entries := gi.NewInt32Argument(n_entries)
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_v, arg_entries, arg_n_entries, arg_user_data}
	iv.Call(args, nil, nil)
}

// g_simple_action_group_insert
// container is not nil, container is SimpleActionGroup
// is method
func (v SimpleActionGroup) Insert(action IAction) {
	iv, err := _I.Get(1175, "SimpleActionGroup", "insert")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if action != nil {
		tmp = action.P_Action()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_action := gi.NewPointerArgument(tmp)
	args := []gi.Argument{arg_v, arg_action}
	iv.Call(args, nil, nil)
}

// g_simple_action_group_lookup
// container is not nil, container is SimpleActionGroup
// is method
func (v SimpleActionGroup) Lookup(action_name string) (result Action) {
	iv, err := _I.Get(1176, "SimpleActionGroup", "lookup")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_action_name := gi.CString(action_name)
	arg_v := gi.NewPointerArgument(v.P)
	arg_action_name := gi.NewStringArgument(c_action_name)
	args := []gi.Argument{arg_v, arg_action_name}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_action_name)
	result.P = ret.Pointer()
	return
}

// g_simple_action_group_remove
// container is not nil, container is SimpleActionGroup
// is method
func (v SimpleActionGroup) Remove(action_name string) {
	iv, err := _I.Get(1177, "SimpleActionGroup", "remove")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_action_name := gi.CString(action_name)
	arg_v := gi.NewPointerArgument(v.P)
	arg_action_name := gi.NewStringArgument(c_action_name)
	args := []gi.Argument{arg_v, arg_action_name}
	iv.Call(args, nil, nil)
	gi.Free(c_action_name)
}

// ignore GType struct SimpleActionGroupClass
// Struct SimpleActionGroupPrivate
type SimpleActionGroupPrivate struct {
	P unsafe.Pointer
}

func SimpleActionGroupPrivateGetType() gi.GType {
	ret := _I.GetGType(226, "SimpleActionGroupPrivate")
	return ret
}

// Object SimpleAsyncResult
type SimpleAsyncResult struct {
	AsyncResultIfc
	gobject.Object
}

func WrapSimpleAsyncResult(p unsafe.Pointer) (r SimpleAsyncResult) { r.P = p; return }

type ISimpleAsyncResult interface{ P_SimpleAsyncResult() unsafe.Pointer }

func (v SimpleAsyncResult) P_SimpleAsyncResult() unsafe.Pointer { return v.P }
func (v SimpleAsyncResult) P_AsyncResult() unsafe.Pointer       { return v.P }
func SimpleAsyncResultGetType() gi.GType {
	ret := _I.GetGType(227, "SimpleAsyncResult")
	return ret
}

// g_simple_async_result_new
// container is not nil, container is SimpleAsyncResult
// is constructor
func NewSimpleAsyncResult(source_object gobject.IObject, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer, source_tag unsafe.Pointer) (result SimpleAsyncResult) {
	iv, err := _I.Get(1178, "SimpleAsyncResult", "new")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if source_object != nil {
		tmp = source_object.P_Object()
	}
	arg_source_object := gi.NewPointerArgument(tmp)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	arg_source_tag := gi.NewPointerArgument(source_tag)
	args := []gi.Argument{arg_source_object, arg_callback, arg_user_data, arg_source_tag}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_simple_async_result_new_from_error
// container is not nil, container is SimpleAsyncResult
// is constructor
func NewSimpleAsyncResultFromError(source_object gobject.IObject, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer, error glib.Error) (result SimpleAsyncResult) {
	iv, err := _I.Get(1179, "SimpleAsyncResult", "new_from_error")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if source_object != nil {
		tmp = source_object.P_Object()
	}
	arg_source_object := gi.NewPointerArgument(tmp)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	arg_error := gi.NewPointerArgument(error.P)
	args := []gi.Argument{arg_source_object, arg_callback, arg_user_data, arg_error}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_simple_async_result_is_valid
// container is not nil, container is SimpleAsyncResult
// is method
// arg0Type tag: interface, isPtr: true
func SimpleAsyncResultIsValid1(result IAsyncResult, source gobject.IObject, source_tag unsafe.Pointer) (result1 bool) {
	iv, err := _I.Get(1180, "SimpleAsyncResult", "is_valid")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if result != nil {
		tmp = result.P_AsyncResult()
	}
	var tmp1 unsafe.Pointer
	if source != nil {
		tmp1 = source.P_Object()
	}
	arg_result := gi.NewPointerArgument(tmp)
	arg_source := gi.NewPointerArgument(tmp1)
	arg_source_tag := gi.NewPointerArgument(source_tag)
	args := []gi.Argument{arg_result, arg_source, arg_source_tag}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result1 = ret.Bool()
	return
}

// g_simple_async_result_complete
// container is not nil, container is SimpleAsyncResult
// is method
func (v SimpleAsyncResult) Complete() {
	iv, err := _I.Get(1181, "SimpleAsyncResult", "complete")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	iv.Call(args, nil, nil)
}

// g_simple_async_result_complete_in_idle
// container is not nil, container is SimpleAsyncResult
// is method
func (v SimpleAsyncResult) CompleteInIdle() {
	iv, err := _I.Get(1182, "SimpleAsyncResult", "complete_in_idle")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	iv.Call(args, nil, nil)
}

// g_simple_async_result_get_op_res_gboolean
// container is not nil, container is SimpleAsyncResult
// is method
func (v SimpleAsyncResult) GetOpResGboolean() (result bool) {
	iv, err := _I.Get(1183, "SimpleAsyncResult", "get_op_res_gboolean")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_simple_async_result_get_op_res_gssize
// container is not nil, container is SimpleAsyncResult
// is method
func (v SimpleAsyncResult) GetOpResGssize() (result int64) {
	iv, err := _I.Get(1184, "SimpleAsyncResult", "get_op_res_gssize")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Int64()
	return
}

// g_simple_async_result_propagate_error
// container is not nil, container is SimpleAsyncResult
// is method
func (v SimpleAsyncResult) PropagateError() (result bool, err error) {
	iv, err := _I.Get(1185, "SimpleAsyncResult", "propagate_error")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	arg_v := gi.NewPointerArgument(v.P)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Bool()
	return
}

// g_simple_async_result_set_check_cancellable
// container is not nil, container is SimpleAsyncResult
// is method
func (v SimpleAsyncResult) SetCheckCancellable(check_cancellable ICancellable) {
	iv, err := _I.Get(1186, "SimpleAsyncResult", "set_check_cancellable")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if check_cancellable != nil {
		tmp = check_cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_check_cancellable := gi.NewPointerArgument(tmp)
	args := []gi.Argument{arg_v, arg_check_cancellable}
	iv.Call(args, nil, nil)
}

// g_simple_async_result_set_from_error
// container is not nil, container is SimpleAsyncResult
// is method
func (v SimpleAsyncResult) SetFromError(error glib.Error) {
	iv, err := _I.Get(1187, "SimpleAsyncResult", "set_from_error")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_error := gi.NewPointerArgument(error.P)
	args := []gi.Argument{arg_v, arg_error}
	iv.Call(args, nil, nil)
}

// g_simple_async_result_set_handle_cancellation
// container is not nil, container is SimpleAsyncResult
// is method
func (v SimpleAsyncResult) SetHandleCancellation(handle_cancellation bool) {
	iv, err := _I.Get(1188, "SimpleAsyncResult", "set_handle_cancellation")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_handle_cancellation := gi.NewBoolArgument(handle_cancellation)
	args := []gi.Argument{arg_v, arg_handle_cancellation}
	iv.Call(args, nil, nil)
}

// g_simple_async_result_set_op_res_gboolean
// container is not nil, container is SimpleAsyncResult
// is method
func (v SimpleAsyncResult) SetOpResGboolean(op_res bool) {
	iv, err := _I.Get(1189, "SimpleAsyncResult", "set_op_res_gboolean")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_op_res := gi.NewBoolArgument(op_res)
	args := []gi.Argument{arg_v, arg_op_res}
	iv.Call(args, nil, nil)
}

// g_simple_async_result_set_op_res_gssize
// container is not nil, container is SimpleAsyncResult
// is method
func (v SimpleAsyncResult) SetOpResGssize(op_res int64) {
	iv, err := _I.Get(1190, "SimpleAsyncResult", "set_op_res_gssize")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_op_res := gi.NewInt64Argument(op_res)
	args := []gi.Argument{arg_v, arg_op_res}
	iv.Call(args, nil, nil)
}

// ignore GType struct SimpleAsyncResultClass
// ignore callback SimpleAsyncThreadFunc
// Object SimpleIOStream
type SimpleIOStream struct {
	IOStream
}

func WrapSimpleIOStream(p unsafe.Pointer) (r SimpleIOStream) { r.P = p; return }

type ISimpleIOStream interface{ P_SimpleIOStream() unsafe.Pointer }

func (v SimpleIOStream) P_SimpleIOStream() unsafe.Pointer { return v.P }
func SimpleIOStreamGetType() gi.GType {
	ret := _I.GetGType(228, "SimpleIOStream")
	return ret
}

// g_simple_io_stream_new
// container is not nil, container is SimpleIOStream
// is constructor
func NewSimpleIOStream(input_stream IInputStream, output_stream IOutputStream) (result SimpleIOStream) {
	iv, err := _I.Get(1191, "SimpleIOStream", "new")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if input_stream != nil {
		tmp = input_stream.P_InputStream()
	}
	var tmp1 unsafe.Pointer
	if output_stream != nil {
		tmp1 = output_stream.P_OutputStream()
	}
	arg_input_stream := gi.NewPointerArgument(tmp)
	arg_output_stream := gi.NewPointerArgument(tmp1)
	args := []gi.Argument{arg_input_stream, arg_output_stream}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// Object SimplePermission
type SimplePermission struct {
	Permission
}

func WrapSimplePermission(p unsafe.Pointer) (r SimplePermission) { r.P = p; return }

type ISimplePermission interface{ P_SimplePermission() unsafe.Pointer }

func (v SimplePermission) P_SimplePermission() unsafe.Pointer { return v.P }
func SimplePermissionGetType() gi.GType {
	ret := _I.GetGType(229, "SimplePermission")
	return ret
}

// g_simple_permission_new
// container is not nil, container is SimplePermission
// is constructor
func NewSimplePermission(allowed bool) (result SimplePermission) {
	iv, err := _I.Get(1192, "SimplePermission", "new")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_allowed := gi.NewBoolArgument(allowed)
	args := []gi.Argument{arg_allowed}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// Object SimpleProxyResolver
type SimpleProxyResolver struct {
	ProxyResolverIfc
	gobject.Object
}

func WrapSimpleProxyResolver(p unsafe.Pointer) (r SimpleProxyResolver) { r.P = p; return }

type ISimpleProxyResolver interface{ P_SimpleProxyResolver() unsafe.Pointer }

func (v SimpleProxyResolver) P_SimpleProxyResolver() unsafe.Pointer { return v.P }
func (v SimpleProxyResolver) P_ProxyResolver() unsafe.Pointer       { return v.P }
func SimpleProxyResolverGetType() gi.GType {
	ret := _I.GetGType(230, "SimpleProxyResolver")
	return ret
}

// g_simple_proxy_resolver_new
// container is not nil, container is SimpleProxyResolver
// is method
// arg0Type tag: utf8, isPtr: true
func SimpleProxyResolverNew1(default_proxy string, ignore_hosts string) (result ProxyResolver) {
	iv, err := _I.Get(1193, "SimpleProxyResolver", "new")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_default_proxy := gi.CString(default_proxy)
	c_ignore_hosts := gi.CString(ignore_hosts)
	arg_default_proxy := gi.NewStringArgument(c_default_proxy)
	arg_ignore_hosts := gi.NewStringArgument(c_ignore_hosts)
	args := []gi.Argument{arg_default_proxy, arg_ignore_hosts}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_default_proxy)
	gi.Free(c_ignore_hosts)
	result.P = ret.Pointer()
	return
}

// g_simple_proxy_resolver_set_default_proxy
// container is not nil, container is SimpleProxyResolver
// is method
func (v SimpleProxyResolver) SetDefaultProxy(default_proxy string) {
	iv, err := _I.Get(1194, "SimpleProxyResolver", "set_default_proxy")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_default_proxy := gi.CString(default_proxy)
	arg_v := gi.NewPointerArgument(v.P)
	arg_default_proxy := gi.NewStringArgument(c_default_proxy)
	args := []gi.Argument{arg_v, arg_default_proxy}
	iv.Call(args, nil, nil)
	gi.Free(c_default_proxy)
}

// g_simple_proxy_resolver_set_ignore_hosts
// container is not nil, container is SimpleProxyResolver
// is method
func (v SimpleProxyResolver) SetIgnoreHosts(ignore_hosts string) {
	iv, err := _I.Get(1195, "SimpleProxyResolver", "set_ignore_hosts")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_ignore_hosts := gi.CString(ignore_hosts)
	arg_v := gi.NewPointerArgument(v.P)
	arg_ignore_hosts := gi.NewStringArgument(c_ignore_hosts)
	args := []gi.Argument{arg_v, arg_ignore_hosts}
	iv.Call(args, nil, nil)
	gi.Free(c_ignore_hosts)
}

// g_simple_proxy_resolver_set_uri_proxy
// container is not nil, container is SimpleProxyResolver
// is method
func (v SimpleProxyResolver) SetUriProxy(uri_scheme string, proxy string) {
	iv, err := _I.Get(1196, "SimpleProxyResolver", "set_uri_proxy")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_uri_scheme := gi.CString(uri_scheme)
	c_proxy := gi.CString(proxy)
	arg_v := gi.NewPointerArgument(v.P)
	arg_uri_scheme := gi.NewStringArgument(c_uri_scheme)
	arg_proxy := gi.NewStringArgument(c_proxy)
	args := []gi.Argument{arg_v, arg_uri_scheme, arg_proxy}
	iv.Call(args, nil, nil)
	gi.Free(c_uri_scheme)
	gi.Free(c_proxy)
}

// ignore GType struct SimpleProxyResolverClass
// Struct SimpleProxyResolverPrivate
type SimpleProxyResolverPrivate struct {
	P unsafe.Pointer
}

func SimpleProxyResolverPrivateGetType() gi.GType {
	ret := _I.GetGType(231, "SimpleProxyResolverPrivate")
	return ret
}

// Object Socket
type Socket struct {
	DatagramBasedIfc
	InitableIfc
	gobject.Object
}

func WrapSocket(p unsafe.Pointer) (r Socket) { r.P = p; return }

type ISocket interface{ P_Socket() unsafe.Pointer }

func (v Socket) P_Socket() unsafe.Pointer        { return v.P }
func (v Socket) P_DatagramBased() unsafe.Pointer { return v.P }
func (v Socket) P_Initable() unsafe.Pointer      { return v.P }
func SocketGetType() gi.GType {
	ret := _I.GetGType(232, "Socket")
	return ret
}

// g_socket_new
// container is not nil, container is Socket
// is constructor
func NewSocket(family SocketFamilyEnum, type1 SocketTypeEnum, protocol SocketProtocolEnum) (result Socket, err error) {
	iv, err := _I.Get(1197, "Socket", "new")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	arg_family := gi.NewIntArgument(int(family))
	arg_type1 := gi.NewIntArgument(int(type1))
	arg_protocol := gi.NewIntArgument(int(protocol))
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_family, arg_type1, arg_protocol, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// g_socket_new_from_fd
// container is not nil, container is Socket
// is constructor
func NewSocketFromFd(fd int32) (result Socket, err error) {
	iv, err := _I.Get(1198, "Socket", "new_from_fd")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	arg_fd := gi.NewInt32Argument(fd)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_fd, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// g_socket_accept
// container is not nil, container is Socket
// is method
func (v Socket) Accept(cancellable ICancellable) (result Socket, err error) {
	iv, err := _I.Get(1199, "Socket", "accept")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// g_socket_bind
// container is not nil, container is Socket
// is method
func (v Socket) Bind(address ISocketAddress, allow_reuse bool) (result bool, err error) {
	iv, err := _I.Get(1200, "Socket", "bind")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if address != nil {
		tmp = address.P_SocketAddress()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_address := gi.NewPointerArgument(tmp)
	arg_allow_reuse := gi.NewBoolArgument(allow_reuse)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_address, arg_allow_reuse, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Bool()
	return
}

// g_socket_check_connect_result
// container is not nil, container is Socket
// is method
func (v Socket) CheckConnectResult() (result bool, err error) {
	iv, err := _I.Get(1201, "Socket", "check_connect_result")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	arg_v := gi.NewPointerArgument(v.P)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Bool()
	return
}

// g_socket_close
// container is not nil, container is Socket
// is method
func (v Socket) Close() (result bool, err error) {
	iv, err := _I.Get(1202, "Socket", "close")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	arg_v := gi.NewPointerArgument(v.P)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Bool()
	return
}

// g_socket_condition_check
// container is not nil, container is Socket
// is method
func (v Socket) ConditionCheck(condition glib.IOConditionFlags) (result glib.IOConditionFlags) {
	iv, err := _I.Get(1203, "Socket", "condition_check")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_condition := gi.NewIntArgument(int(condition))
	args := []gi.Argument{arg_v, arg_condition}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = glib.IOConditionFlags(ret.Int())
	return
}

// g_socket_condition_timed_wait
// container is not nil, container is Socket
// is method
func (v Socket) ConditionTimedWait(condition glib.IOConditionFlags, timeout int64, cancellable ICancellable) (result bool, err error) {
	iv, err := _I.Get(1204, "Socket", "condition_timed_wait")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_condition := gi.NewIntArgument(int(condition))
	arg_timeout := gi.NewInt64Argument(timeout)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_condition, arg_timeout, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Bool()
	return
}

// g_socket_condition_wait
// container is not nil, container is Socket
// is method
func (v Socket) ConditionWait(condition glib.IOConditionFlags, cancellable ICancellable) (result bool, err error) {
	iv, err := _I.Get(1205, "Socket", "condition_wait")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_condition := gi.NewIntArgument(int(condition))
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_condition, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Bool()
	return
}

// g_socket_connect
// container is not nil, container is Socket
// is method
func (v Socket) Connect(address ISocketAddress, cancellable ICancellable) (result bool, err error) {
	iv, err := _I.Get(1206, "Socket", "connect")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if address != nil {
		tmp = address.P_SocketAddress()
	}
	var tmp1 unsafe.Pointer
	if cancellable != nil {
		tmp1 = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_address := gi.NewPointerArgument(tmp)
	arg_cancellable := gi.NewPointerArgument(tmp1)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_address, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Bool()
	return
}

// g_socket_connection_factory_create_connection
// container is not nil, container is Socket
// is method
func (v Socket) ConnectionFactoryCreateConnection() (result SocketConnection) {
	iv, err := _I.Get(1207, "Socket", "connection_factory_create_connection")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_socket_get_available_bytes
// container is not nil, container is Socket
// is method
func (v Socket) GetAvailableBytes() (result int64) {
	iv, err := _I.Get(1208, "Socket", "get_available_bytes")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Int64()
	return
}

// g_socket_get_blocking
// container is not nil, container is Socket
// is method
func (v Socket) GetBlocking() (result bool) {
	iv, err := _I.Get(1209, "Socket", "get_blocking")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_socket_get_broadcast
// container is not nil, container is Socket
// is method
func (v Socket) GetBroadcast() (result bool) {
	iv, err := _I.Get(1210, "Socket", "get_broadcast")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_socket_get_credentials
// container is not nil, container is Socket
// is method
func (v Socket) GetCredentials() (result Credentials, err error) {
	iv, err := _I.Get(1211, "Socket", "get_credentials")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	arg_v := gi.NewPointerArgument(v.P)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// g_socket_get_family
// container is not nil, container is Socket
// is method
func (v Socket) GetFamily() (result SocketFamilyEnum) {
	iv, err := _I.Get(1212, "Socket", "get_family")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = SocketFamilyEnum(ret.Int())
	return
}

// g_socket_get_fd
// container is not nil, container is Socket
// is method
func (v Socket) GetFd() (result int32) {
	iv, err := _I.Get(1213, "Socket", "get_fd")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Int32()
	return
}

// g_socket_get_keepalive
// container is not nil, container is Socket
// is method
func (v Socket) GetKeepalive() (result bool) {
	iv, err := _I.Get(1214, "Socket", "get_keepalive")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_socket_get_listen_backlog
// container is not nil, container is Socket
// is method
func (v Socket) GetListenBacklog() (result int32) {
	iv, err := _I.Get(1215, "Socket", "get_listen_backlog")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Int32()
	return
}

// g_socket_get_local_address
// container is not nil, container is Socket
// is method
func (v Socket) GetLocalAddress() (result SocketAddress, err error) {
	iv, err := _I.Get(1216, "Socket", "get_local_address")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	arg_v := gi.NewPointerArgument(v.P)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// g_socket_get_multicast_loopback
// container is not nil, container is Socket
// is method
func (v Socket) GetMulticastLoopback() (result bool) {
	iv, err := _I.Get(1217, "Socket", "get_multicast_loopback")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_socket_get_multicast_ttl
// container is not nil, container is Socket
// is method
func (v Socket) GetMulticastTtl() (result uint32) {
	iv, err := _I.Get(1218, "Socket", "get_multicast_ttl")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Uint32()
	return
}

// g_socket_get_option
// container is not nil, container is Socket
// is method
func (v Socket) GetOption(level int32, optname int32) (result bool, value int32, err error) {
	iv, err := _I.Get(1219, "Socket", "get_option")
	if err != nil {
		return
	}
	var outArgs [2]gi.Argument
	arg_v := gi.NewPointerArgument(v.P)
	arg_level := gi.NewInt32Argument(level)
	arg_optname := gi.NewInt32Argument(optname)
	arg_value := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[1]))
	args := []gi.Argument{arg_v, arg_level, arg_optname, arg_value, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[1].Pointer())
	value = outArgs[0].Int32()
	result = ret.Bool()
	return
}

// g_socket_get_protocol
// container is not nil, container is Socket
// is method
func (v Socket) GetProtocol() (result SocketProtocolEnum) {
	iv, err := _I.Get(1220, "Socket", "get_protocol")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = SocketProtocolEnum(ret.Int())
	return
}

// g_socket_get_remote_address
// container is not nil, container is Socket
// is method
func (v Socket) GetRemoteAddress() (result SocketAddress, err error) {
	iv, err := _I.Get(1221, "Socket", "get_remote_address")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	arg_v := gi.NewPointerArgument(v.P)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// g_socket_get_socket_type
// container is not nil, container is Socket
// is method
func (v Socket) GetSocketType() (result SocketTypeEnum) {
	iv, err := _I.Get(1222, "Socket", "get_socket_type")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = SocketTypeEnum(ret.Int())
	return
}

// g_socket_get_timeout
// container is not nil, container is Socket
// is method
func (v Socket) GetTimeout() (result uint32) {
	iv, err := _I.Get(1223, "Socket", "get_timeout")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Uint32()
	return
}

// g_socket_get_ttl
// container is not nil, container is Socket
// is method
func (v Socket) GetTtl() (result uint32) {
	iv, err := _I.Get(1224, "Socket", "get_ttl")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Uint32()
	return
}

// g_socket_is_closed
// container is not nil, container is Socket
// is method
func (v Socket) IsClosed() (result bool) {
	iv, err := _I.Get(1225, "Socket", "is_closed")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_socket_is_connected
// container is not nil, container is Socket
// is method
func (v Socket) IsConnected() (result bool) {
	iv, err := _I.Get(1226, "Socket", "is_connected")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_socket_join_multicast_group
// container is not nil, container is Socket
// is method
func (v Socket) JoinMulticastGroup(group IInetAddress, source_specific bool, iface string) (result bool, err error) {
	iv, err := _I.Get(1227, "Socket", "join_multicast_group")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if group != nil {
		tmp = group.P_InetAddress()
	}
	c_iface := gi.CString(iface)
	arg_v := gi.NewPointerArgument(v.P)
	arg_group := gi.NewPointerArgument(tmp)
	arg_source_specific := gi.NewBoolArgument(source_specific)
	arg_iface := gi.NewStringArgument(c_iface)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_group, arg_source_specific, arg_iface, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	gi.Free(c_iface)
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Bool()
	return
}

// g_socket_join_multicast_group_ssm
// container is not nil, container is Socket
// is method
func (v Socket) JoinMulticastGroupSsm(group IInetAddress, source_specific IInetAddress, iface string) (result bool, err error) {
	iv, err := _I.Get(1228, "Socket", "join_multicast_group_ssm")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if group != nil {
		tmp = group.P_InetAddress()
	}
	var tmp1 unsafe.Pointer
	if source_specific != nil {
		tmp1 = source_specific.P_InetAddress()
	}
	c_iface := gi.CString(iface)
	arg_v := gi.NewPointerArgument(v.P)
	arg_group := gi.NewPointerArgument(tmp)
	arg_source_specific := gi.NewPointerArgument(tmp1)
	arg_iface := gi.NewStringArgument(c_iface)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_group, arg_source_specific, arg_iface, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	gi.Free(c_iface)
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Bool()
	return
}

// g_socket_leave_multicast_group
// container is not nil, container is Socket
// is method
func (v Socket) LeaveMulticastGroup(group IInetAddress, source_specific bool, iface string) (result bool, err error) {
	iv, err := _I.Get(1229, "Socket", "leave_multicast_group")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if group != nil {
		tmp = group.P_InetAddress()
	}
	c_iface := gi.CString(iface)
	arg_v := gi.NewPointerArgument(v.P)
	arg_group := gi.NewPointerArgument(tmp)
	arg_source_specific := gi.NewBoolArgument(source_specific)
	arg_iface := gi.NewStringArgument(c_iface)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_group, arg_source_specific, arg_iface, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	gi.Free(c_iface)
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Bool()
	return
}

// g_socket_leave_multicast_group_ssm
// container is not nil, container is Socket
// is method
func (v Socket) LeaveMulticastGroupSsm(group IInetAddress, source_specific IInetAddress, iface string) (result bool, err error) {
	iv, err := _I.Get(1230, "Socket", "leave_multicast_group_ssm")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if group != nil {
		tmp = group.P_InetAddress()
	}
	var tmp1 unsafe.Pointer
	if source_specific != nil {
		tmp1 = source_specific.P_InetAddress()
	}
	c_iface := gi.CString(iface)
	arg_v := gi.NewPointerArgument(v.P)
	arg_group := gi.NewPointerArgument(tmp)
	arg_source_specific := gi.NewPointerArgument(tmp1)
	arg_iface := gi.NewStringArgument(c_iface)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_group, arg_source_specific, arg_iface, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	gi.Free(c_iface)
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Bool()
	return
}

// g_socket_listen
// container is not nil, container is Socket
// is method
func (v Socket) Listen() (result bool, err error) {
	iv, err := _I.Get(1231, "Socket", "listen")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	arg_v := gi.NewPointerArgument(v.P)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Bool()
	return
}

// g_socket_receive
// container is not nil, container is Socket
// is method
// arg 0 buffer lenArgIdx 1
func (v Socket) Receive(buffer gi.Uint8Array, size uint64, cancellable ICancellable) (result int64, err error) {
	iv, err := _I.Get(1232, "Socket", "receive")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_buffer := gi.NewPointerArgument(buffer.P)
	arg_size := gi.NewUint64Argument(size)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_buffer, arg_size, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Int64()
	return
}

// g_socket_receive_from
// container is not nil, container is Socket
// is method
// arg 1 buffer lenArgIdx 2
func (v Socket) ReceiveFrom(buffer gi.Uint8Array, size uint64, cancellable ICancellable) (result int64, address SocketAddress, err error) {
	iv, err := _I.Get(1233, "Socket", "receive_from")
	if err != nil {
		return
	}
	var outArgs [2]gi.Argument
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_address := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	arg_buffer := gi.NewPointerArgument(buffer.P)
	arg_size := gi.NewUint64Argument(size)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[1]))
	args := []gi.Argument{arg_v, arg_address, arg_buffer, arg_size, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[1].Pointer())
	address.P = outArgs[0].Pointer()
	result = ret.Int64()
	return
}

// g_socket_receive_message
// container is not nil, container is Socket
// is method
// arg 1 vectors lenArgIdx 2
// arg 3 messages lenArgIdx 4
func (v Socket) ReceiveMessage(vectors unsafe.Pointer, num_vectors int32, flags int /*TODO:TYPE*/, cancellable ICancellable) (result int64, address SocketAddress, messages gi.PointerArray, err error) {
	iv, err := _I.Get(1234, "Socket", "receive_message")
	if err != nil {
		return
	}
	var outArgs [5]gi.Argument
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_address := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	arg_vectors := gi.NewPointerArgument(vectors)
	arg_num_vectors := gi.NewInt32Argument(num_vectors)
	arg_messages := gi.NewPointerArgument(unsafe.Pointer(&outArgs[1]))
	arg_num_messages := gi.NewPointerArgument(unsafe.Pointer(&outArgs[2]))
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[3]))
	args := []gi.Argument{arg_v, arg_address, arg_vectors, arg_num_vectors, arg_messages, arg_num_messages, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	var num_messages int32
	_ = num_messages
	err = gi.ToError(outArgs[3].Pointer())
	address.P = outArgs[0].Pointer()
	messages.P = outArgs[1].Pointer()
	num_messages = outArgs[2].Int32()
	result = ret.Int64()
	messages.Len = int(num_messages)
	return
}

// g_socket_receive_messages
// container is not nil, container is Socket
// is method
// arg 0 messages lenArgIdx 1
func (v Socket) ReceiveMessages(messages unsafe.Pointer, num_messages uint32, flags int32, cancellable ICancellable) (result int32, err error) {
	iv, err := _I.Get(1235, "Socket", "receive_messages")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_messages := gi.NewPointerArgument(messages)
	arg_num_messages := gi.NewUint32Argument(num_messages)
	arg_flags := gi.NewInt32Argument(flags)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_messages, arg_num_messages, arg_flags, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Int32()
	return
}

// g_socket_receive_with_blocking
// container is not nil, container is Socket
// is method
// arg 0 buffer lenArgIdx 1
func (v Socket) ReceiveWithBlocking(buffer gi.Uint8Array, size uint64, blocking bool, cancellable ICancellable) (result int64, err error) {
	iv, err := _I.Get(1236, "Socket", "receive_with_blocking")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_buffer := gi.NewPointerArgument(buffer.P)
	arg_size := gi.NewUint64Argument(size)
	arg_blocking := gi.NewBoolArgument(blocking)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_buffer, arg_size, arg_blocking, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Int64()
	return
}

// g_socket_send
// container is not nil, container is Socket
// is method
// arg 0 buffer lenArgIdx 1
func (v Socket) Send(buffer gi.Uint8Array, size uint64, cancellable ICancellable) (result int64, err error) {
	iv, err := _I.Get(1237, "Socket", "send")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_buffer := gi.NewPointerArgument(buffer.P)
	arg_size := gi.NewUint64Argument(size)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_buffer, arg_size, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Int64()
	return
}

// g_socket_send_message
// container is not nil, container is Socket
// is method
// arg 1 vectors lenArgIdx 2
// arg 3 messages lenArgIdx 4
func (v Socket) SendMessage(address ISocketAddress, vectors unsafe.Pointer, num_vectors int32, messages gi.PointerArray, num_messages int32, flags int32, cancellable ICancellable) (result int64, err error) {
	iv, err := _I.Get(1238, "Socket", "send_message")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if address != nil {
		tmp = address.P_SocketAddress()
	}
	var tmp1 unsafe.Pointer
	if cancellable != nil {
		tmp1 = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_address := gi.NewPointerArgument(tmp)
	arg_vectors := gi.NewPointerArgument(vectors)
	arg_num_vectors := gi.NewInt32Argument(num_vectors)
	arg_messages := gi.NewPointerArgument(messages.P)
	arg_num_messages := gi.NewInt32Argument(num_messages)
	arg_flags := gi.NewInt32Argument(flags)
	arg_cancellable := gi.NewPointerArgument(tmp1)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_address, arg_vectors, arg_num_vectors, arg_messages, arg_num_messages, arg_flags, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Int64()
	return
}

// g_socket_send_messages
// container is not nil, container is Socket
// is method
// arg 0 messages lenArgIdx 1
func (v Socket) SendMessages(messages unsafe.Pointer, num_messages uint32, flags int32, cancellable ICancellable) (result int32, err error) {
	iv, err := _I.Get(1239, "Socket", "send_messages")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_messages := gi.NewPointerArgument(messages)
	arg_num_messages := gi.NewUint32Argument(num_messages)
	arg_flags := gi.NewInt32Argument(flags)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_messages, arg_num_messages, arg_flags, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Int32()
	return
}

// g_socket_send_to
// container is not nil, container is Socket
// is method
// arg 1 buffer lenArgIdx 2
func (v Socket) SendTo(address ISocketAddress, buffer gi.Uint8Array, size uint64, cancellable ICancellable) (result int64, err error) {
	iv, err := _I.Get(1240, "Socket", "send_to")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if address != nil {
		tmp = address.P_SocketAddress()
	}
	var tmp1 unsafe.Pointer
	if cancellable != nil {
		tmp1 = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_address := gi.NewPointerArgument(tmp)
	arg_buffer := gi.NewPointerArgument(buffer.P)
	arg_size := gi.NewUint64Argument(size)
	arg_cancellable := gi.NewPointerArgument(tmp1)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_address, arg_buffer, arg_size, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Int64()
	return
}

// g_socket_send_with_blocking
// container is not nil, container is Socket
// is method
// arg 0 buffer lenArgIdx 1
func (v Socket) SendWithBlocking(buffer gi.Uint8Array, size uint64, blocking bool, cancellable ICancellable) (result int64, err error) {
	iv, err := _I.Get(1241, "Socket", "send_with_blocking")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_buffer := gi.NewPointerArgument(buffer.P)
	arg_size := gi.NewUint64Argument(size)
	arg_blocking := gi.NewBoolArgument(blocking)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_buffer, arg_size, arg_blocking, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Int64()
	return
}

// g_socket_set_blocking
// container is not nil, container is Socket
// is method
func (v Socket) SetBlocking(blocking bool) {
	iv, err := _I.Get(1242, "Socket", "set_blocking")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_blocking := gi.NewBoolArgument(blocking)
	args := []gi.Argument{arg_v, arg_blocking}
	iv.Call(args, nil, nil)
}

// g_socket_set_broadcast
// container is not nil, container is Socket
// is method
func (v Socket) SetBroadcast(broadcast bool) {
	iv, err := _I.Get(1243, "Socket", "set_broadcast")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_broadcast := gi.NewBoolArgument(broadcast)
	args := []gi.Argument{arg_v, arg_broadcast}
	iv.Call(args, nil, nil)
}

// g_socket_set_keepalive
// container is not nil, container is Socket
// is method
func (v Socket) SetKeepalive(keepalive bool) {
	iv, err := _I.Get(1244, "Socket", "set_keepalive")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_keepalive := gi.NewBoolArgument(keepalive)
	args := []gi.Argument{arg_v, arg_keepalive}
	iv.Call(args, nil, nil)
}

// g_socket_set_listen_backlog
// container is not nil, container is Socket
// is method
func (v Socket) SetListenBacklog(backlog int32) {
	iv, err := _I.Get(1245, "Socket", "set_listen_backlog")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_backlog := gi.NewInt32Argument(backlog)
	args := []gi.Argument{arg_v, arg_backlog}
	iv.Call(args, nil, nil)
}

// g_socket_set_multicast_loopback
// container is not nil, container is Socket
// is method
func (v Socket) SetMulticastLoopback(loopback bool) {
	iv, err := _I.Get(1246, "Socket", "set_multicast_loopback")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_loopback := gi.NewBoolArgument(loopback)
	args := []gi.Argument{arg_v, arg_loopback}
	iv.Call(args, nil, nil)
}

// g_socket_set_multicast_ttl
// container is not nil, container is Socket
// is method
func (v Socket) SetMulticastTtl(ttl uint32) {
	iv, err := _I.Get(1247, "Socket", "set_multicast_ttl")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_ttl := gi.NewUint32Argument(ttl)
	args := []gi.Argument{arg_v, arg_ttl}
	iv.Call(args, nil, nil)
}

// g_socket_set_option
// container is not nil, container is Socket
// is method
func (v Socket) SetOption(level int32, optname int32, value int32) (result bool, err error) {
	iv, err := _I.Get(1248, "Socket", "set_option")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	arg_v := gi.NewPointerArgument(v.P)
	arg_level := gi.NewInt32Argument(level)
	arg_optname := gi.NewInt32Argument(optname)
	arg_value := gi.NewInt32Argument(value)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_level, arg_optname, arg_value, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Bool()
	return
}

// g_socket_set_timeout
// container is not nil, container is Socket
// is method
func (v Socket) SetTimeout(timeout uint32) {
	iv, err := _I.Get(1249, "Socket", "set_timeout")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_timeout := gi.NewUint32Argument(timeout)
	args := []gi.Argument{arg_v, arg_timeout}
	iv.Call(args, nil, nil)
}

// g_socket_set_ttl
// container is not nil, container is Socket
// is method
func (v Socket) SetTtl(ttl uint32) {
	iv, err := _I.Get(1250, "Socket", "set_ttl")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_ttl := gi.NewUint32Argument(ttl)
	args := []gi.Argument{arg_v, arg_ttl}
	iv.Call(args, nil, nil)
}

// g_socket_shutdown
// container is not nil, container is Socket
// is method
func (v Socket) Shutdown(shutdown_read bool, shutdown_write bool) (result bool, err error) {
	iv, err := _I.Get(1251, "Socket", "shutdown")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	arg_v := gi.NewPointerArgument(v.P)
	arg_shutdown_read := gi.NewBoolArgument(shutdown_read)
	arg_shutdown_write := gi.NewBoolArgument(shutdown_write)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_shutdown_read, arg_shutdown_write, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Bool()
	return
}

// g_socket_speaks_ipv4
// container is not nil, container is Socket
// is method
func (v Socket) SpeaksIpv4() (result bool) {
	iv, err := _I.Get(1252, "Socket", "speaks_ipv4")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// Object SocketAddress
type SocketAddress struct {
	SocketConnectableIfc
	gobject.Object
}

func WrapSocketAddress(p unsafe.Pointer) (r SocketAddress) { r.P = p; return }

type ISocketAddress interface{ P_SocketAddress() unsafe.Pointer }

func (v SocketAddress) P_SocketAddress() unsafe.Pointer     { return v.P }
func (v SocketAddress) P_SocketConnectable() unsafe.Pointer { return v.P }
func SocketAddressGetType() gi.GType {
	ret := _I.GetGType(233, "SocketAddress")
	return ret
}

// g_socket_address_new_from_native
// container is not nil, container is SocketAddress
// is constructor
func NewSocketAddressFromNative(native unsafe.Pointer, len1 uint64) (result SocketAddress) {
	iv, err := _I.Get(1253, "SocketAddress", "new_from_native")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_native := gi.NewPointerArgument(native)
	arg_len1 := gi.NewUint64Argument(len1)
	args := []gi.Argument{arg_native, arg_len1}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_socket_address_get_family
// container is not nil, container is SocketAddress
// is method
func (v SocketAddress) GetFamily() (result SocketFamilyEnum) {
	iv, err := _I.Get(1254, "SocketAddress", "get_family")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = SocketFamilyEnum(ret.Int())
	return
}

// g_socket_address_get_native_size
// container is not nil, container is SocketAddress
// is method
func (v SocketAddress) GetNativeSize() (result int64) {
	iv, err := _I.Get(1255, "SocketAddress", "get_native_size")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Int64()
	return
}

// g_socket_address_to_native
// container is not nil, container is SocketAddress
// is method
func (v SocketAddress) ToNative(dest unsafe.Pointer, destlen uint64) (result bool, err error) {
	iv, err := _I.Get(1256, "SocketAddress", "to_native")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	arg_v := gi.NewPointerArgument(v.P)
	arg_dest := gi.NewPointerArgument(dest)
	arg_destlen := gi.NewUint64Argument(destlen)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_dest, arg_destlen, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Bool()
	return
}

// ignore GType struct SocketAddressClass
// Object SocketAddressEnumerator
type SocketAddressEnumerator struct {
	gobject.Object
}

func WrapSocketAddressEnumerator(p unsafe.Pointer) (r SocketAddressEnumerator) { r.P = p; return }

type ISocketAddressEnumerator interface{ P_SocketAddressEnumerator() unsafe.Pointer }

func (v SocketAddressEnumerator) P_SocketAddressEnumerator() unsafe.Pointer { return v.P }
func SocketAddressEnumeratorGetType() gi.GType {
	ret := _I.GetGType(234, "SocketAddressEnumerator")
	return ret
}

// g_socket_address_enumerator_next
// container is not nil, container is SocketAddressEnumerator
// is method
func (v SocketAddressEnumerator) Next(cancellable ICancellable) (result SocketAddress, err error) {
	iv, err := _I.Get(1257, "SocketAddressEnumerator", "next")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// g_socket_address_enumerator_next_async
// container is not nil, container is SocketAddressEnumerator
// is method
func (v SocketAddressEnumerator) NextAsync(cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(1258, "SocketAddressEnumerator", "next_async")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_v, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
}

// g_socket_address_enumerator_next_finish
// container is not nil, container is SocketAddressEnumerator
// is method
func (v SocketAddressEnumerator) NextFinish(result IAsyncResult) (result1 SocketAddress, err error) {
	iv, err := _I.Get(1259, "SocketAddressEnumerator", "next_finish")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if result != nil {
		tmp = result.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_result := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_result, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result1.P = ret.Pointer()
	return
}

// ignore GType struct SocketAddressEnumeratorClass
// ignore GType struct SocketClass
// Object SocketClient
type SocketClient struct {
	gobject.Object
}

func WrapSocketClient(p unsafe.Pointer) (r SocketClient) { r.P = p; return }

type ISocketClient interface{ P_SocketClient() unsafe.Pointer }

func (v SocketClient) P_SocketClient() unsafe.Pointer { return v.P }
func SocketClientGetType() gi.GType {
	ret := _I.GetGType(235, "SocketClient")
	return ret
}

// g_socket_client_new
// container is not nil, container is SocketClient
// is constructor
func NewSocketClient() (result SocketClient) {
	iv, err := _I.Get(1260, "SocketClient", "new")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var ret gi.Argument
	iv.Call(nil, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_socket_client_add_application_proxy
// container is not nil, container is SocketClient
// is method
func (v SocketClient) AddApplicationProxy(protocol string) {
	iv, err := _I.Get(1261, "SocketClient", "add_application_proxy")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_protocol := gi.CString(protocol)
	arg_v := gi.NewPointerArgument(v.P)
	arg_protocol := gi.NewStringArgument(c_protocol)
	args := []gi.Argument{arg_v, arg_protocol}
	iv.Call(args, nil, nil)
	gi.Free(c_protocol)
}

// g_socket_client_connect
// container is not nil, container is SocketClient
// is method
func (v SocketClient) Connect(connectable ISocketConnectable, cancellable ICancellable) (result SocketConnection, err error) {
	iv, err := _I.Get(1262, "SocketClient", "connect")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if connectable != nil {
		tmp = connectable.P_SocketConnectable()
	}
	var tmp1 unsafe.Pointer
	if cancellable != nil {
		tmp1 = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_connectable := gi.NewPointerArgument(tmp)
	arg_cancellable := gi.NewPointerArgument(tmp1)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_connectable, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// g_socket_client_connect_async
// container is not nil, container is SocketClient
// is method
func (v SocketClient) ConnectAsync(connectable ISocketConnectable, cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(1263, "SocketClient", "connect_async")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if connectable != nil {
		tmp = connectable.P_SocketConnectable()
	}
	var tmp1 unsafe.Pointer
	if cancellable != nil {
		tmp1 = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_connectable := gi.NewPointerArgument(tmp)
	arg_cancellable := gi.NewPointerArgument(tmp1)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_v, arg_connectable, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
}

// g_socket_client_connect_finish
// container is not nil, container is SocketClient
// is method
func (v SocketClient) ConnectFinish(result IAsyncResult) (result1 SocketConnection, err error) {
	iv, err := _I.Get(1264, "SocketClient", "connect_finish")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if result != nil {
		tmp = result.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_result := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_result, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result1.P = ret.Pointer()
	return
}

// g_socket_client_connect_to_host
// container is not nil, container is SocketClient
// is method
func (v SocketClient) ConnectToHost(host_and_port string, default_port uint16, cancellable ICancellable) (result SocketConnection, err error) {
	iv, err := _I.Get(1265, "SocketClient", "connect_to_host")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	c_host_and_port := gi.CString(host_and_port)
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_host_and_port := gi.NewStringArgument(c_host_and_port)
	arg_default_port := gi.NewUint16Argument(default_port)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_host_and_port, arg_default_port, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	gi.Free(c_host_and_port)
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// g_socket_client_connect_to_host_async
// container is not nil, container is SocketClient
// is method
func (v SocketClient) ConnectToHostAsync(host_and_port string, default_port uint16, cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(1266, "SocketClient", "connect_to_host_async")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_host_and_port := gi.CString(host_and_port)
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_host_and_port := gi.NewStringArgument(c_host_and_port)
	arg_default_port := gi.NewUint16Argument(default_port)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_v, arg_host_and_port, arg_default_port, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
	gi.Free(c_host_and_port)
}

// g_socket_client_connect_to_host_finish
// container is not nil, container is SocketClient
// is method
func (v SocketClient) ConnectToHostFinish(result IAsyncResult) (result1 SocketConnection, err error) {
	iv, err := _I.Get(1267, "SocketClient", "connect_to_host_finish")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if result != nil {
		tmp = result.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_result := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_result, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result1.P = ret.Pointer()
	return
}

// g_socket_client_connect_to_service
// container is not nil, container is SocketClient
// is method
func (v SocketClient) ConnectToService(domain string, service string, cancellable ICancellable) (result SocketConnection, err error) {
	iv, err := _I.Get(1268, "SocketClient", "connect_to_service")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	c_domain := gi.CString(domain)
	c_service := gi.CString(service)
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_domain := gi.NewStringArgument(c_domain)
	arg_service := gi.NewStringArgument(c_service)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_domain, arg_service, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	gi.Free(c_domain)
	gi.Free(c_service)
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// g_socket_client_connect_to_service_async
// container is not nil, container is SocketClient
// is method
func (v SocketClient) ConnectToServiceAsync(domain string, service string, cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(1269, "SocketClient", "connect_to_service_async")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_domain := gi.CString(domain)
	c_service := gi.CString(service)
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_domain := gi.NewStringArgument(c_domain)
	arg_service := gi.NewStringArgument(c_service)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_v, arg_domain, arg_service, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
	gi.Free(c_domain)
	gi.Free(c_service)
}

// g_socket_client_connect_to_service_finish
// container is not nil, container is SocketClient
// is method
func (v SocketClient) ConnectToServiceFinish(result IAsyncResult) (result1 SocketConnection, err error) {
	iv, err := _I.Get(1270, "SocketClient", "connect_to_service_finish")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if result != nil {
		tmp = result.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_result := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_result, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result1.P = ret.Pointer()
	return
}

// g_socket_client_connect_to_uri
// container is not nil, container is SocketClient
// is method
func (v SocketClient) ConnectToUri(uri string, default_port uint16, cancellable ICancellable) (result SocketConnection, err error) {
	iv, err := _I.Get(1271, "SocketClient", "connect_to_uri")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	c_uri := gi.CString(uri)
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_uri := gi.NewStringArgument(c_uri)
	arg_default_port := gi.NewUint16Argument(default_port)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_uri, arg_default_port, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	gi.Free(c_uri)
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// g_socket_client_connect_to_uri_async
// container is not nil, container is SocketClient
// is method
func (v SocketClient) ConnectToUriAsync(uri string, default_port uint16, cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(1272, "SocketClient", "connect_to_uri_async")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_uri := gi.CString(uri)
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_uri := gi.NewStringArgument(c_uri)
	arg_default_port := gi.NewUint16Argument(default_port)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_v, arg_uri, arg_default_port, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
	gi.Free(c_uri)
}

// g_socket_client_connect_to_uri_finish
// container is not nil, container is SocketClient
// is method
func (v SocketClient) ConnectToUriFinish(result IAsyncResult) (result1 SocketConnection, err error) {
	iv, err := _I.Get(1273, "SocketClient", "connect_to_uri_finish")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if result != nil {
		tmp = result.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_result := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_result, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result1.P = ret.Pointer()
	return
}

// g_socket_client_get_enable_proxy
// container is not nil, container is SocketClient
// is method
func (v SocketClient) GetEnableProxy() (result bool) {
	iv, err := _I.Get(1274, "SocketClient", "get_enable_proxy")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_socket_client_get_family
// container is not nil, container is SocketClient
// is method
func (v SocketClient) GetFamily() (result SocketFamilyEnum) {
	iv, err := _I.Get(1275, "SocketClient", "get_family")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = SocketFamilyEnum(ret.Int())
	return
}

// g_socket_client_get_local_address
// container is not nil, container is SocketClient
// is method
func (v SocketClient) GetLocalAddress() (result SocketAddress) {
	iv, err := _I.Get(1276, "SocketClient", "get_local_address")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_socket_client_get_protocol
// container is not nil, container is SocketClient
// is method
func (v SocketClient) GetProtocol() (result SocketProtocolEnum) {
	iv, err := _I.Get(1277, "SocketClient", "get_protocol")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = SocketProtocolEnum(ret.Int())
	return
}

// g_socket_client_get_proxy_resolver
// container is not nil, container is SocketClient
// is method
func (v SocketClient) GetProxyResolver() (result ProxyResolver) {
	iv, err := _I.Get(1278, "SocketClient", "get_proxy_resolver")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_socket_client_get_socket_type
// container is not nil, container is SocketClient
// is method
func (v SocketClient) GetSocketType() (result SocketTypeEnum) {
	iv, err := _I.Get(1279, "SocketClient", "get_socket_type")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = SocketTypeEnum(ret.Int())
	return
}

// g_socket_client_get_timeout
// container is not nil, container is SocketClient
// is method
func (v SocketClient) GetTimeout() (result uint32) {
	iv, err := _I.Get(1280, "SocketClient", "get_timeout")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Uint32()
	return
}

// g_socket_client_get_tls
// container is not nil, container is SocketClient
// is method
func (v SocketClient) GetTls() (result bool) {
	iv, err := _I.Get(1281, "SocketClient", "get_tls")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_socket_client_get_tls_validation_flags
// container is not nil, container is SocketClient
// is method
func (v SocketClient) GetTlsValidationFlags() (result TlsCertificateFlags) {
	iv, err := _I.Get(1282, "SocketClient", "get_tls_validation_flags")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = TlsCertificateFlags(ret.Int())
	return
}

// g_socket_client_set_enable_proxy
// container is not nil, container is SocketClient
// is method
func (v SocketClient) SetEnableProxy(enable bool) {
	iv, err := _I.Get(1283, "SocketClient", "set_enable_proxy")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_enable := gi.NewBoolArgument(enable)
	args := []gi.Argument{arg_v, arg_enable}
	iv.Call(args, nil, nil)
}

// g_socket_client_set_family
// container is not nil, container is SocketClient
// is method
func (v SocketClient) SetFamily(family SocketFamilyEnum) {
	iv, err := _I.Get(1284, "SocketClient", "set_family")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_family := gi.NewIntArgument(int(family))
	args := []gi.Argument{arg_v, arg_family}
	iv.Call(args, nil, nil)
}

// g_socket_client_set_local_address
// container is not nil, container is SocketClient
// is method
func (v SocketClient) SetLocalAddress(address ISocketAddress) {
	iv, err := _I.Get(1285, "SocketClient", "set_local_address")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if address != nil {
		tmp = address.P_SocketAddress()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_address := gi.NewPointerArgument(tmp)
	args := []gi.Argument{arg_v, arg_address}
	iv.Call(args, nil, nil)
}

// g_socket_client_set_protocol
// container is not nil, container is SocketClient
// is method
func (v SocketClient) SetProtocol(protocol SocketProtocolEnum) {
	iv, err := _I.Get(1286, "SocketClient", "set_protocol")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_protocol := gi.NewIntArgument(int(protocol))
	args := []gi.Argument{arg_v, arg_protocol}
	iv.Call(args, nil, nil)
}

// g_socket_client_set_proxy_resolver
// container is not nil, container is SocketClient
// is method
func (v SocketClient) SetProxyResolver(proxy_resolver IProxyResolver) {
	iv, err := _I.Get(1287, "SocketClient", "set_proxy_resolver")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if proxy_resolver != nil {
		tmp = proxy_resolver.P_ProxyResolver()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_proxy_resolver := gi.NewPointerArgument(tmp)
	args := []gi.Argument{arg_v, arg_proxy_resolver}
	iv.Call(args, nil, nil)
}

// g_socket_client_set_socket_type
// container is not nil, container is SocketClient
// is method
func (v SocketClient) SetSocketType(type1 SocketTypeEnum) {
	iv, err := _I.Get(1288, "SocketClient", "set_socket_type")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_type1 := gi.NewIntArgument(int(type1))
	args := []gi.Argument{arg_v, arg_type1}
	iv.Call(args, nil, nil)
}

// g_socket_client_set_timeout
// container is not nil, container is SocketClient
// is method
func (v SocketClient) SetTimeout(timeout uint32) {
	iv, err := _I.Get(1289, "SocketClient", "set_timeout")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_timeout := gi.NewUint32Argument(timeout)
	args := []gi.Argument{arg_v, arg_timeout}
	iv.Call(args, nil, nil)
}

// g_socket_client_set_tls
// container is not nil, container is SocketClient
// is method
func (v SocketClient) SetTls(tls bool) {
	iv, err := _I.Get(1290, "SocketClient", "set_tls")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_tls := gi.NewBoolArgument(tls)
	args := []gi.Argument{arg_v, arg_tls}
	iv.Call(args, nil, nil)
}

// g_socket_client_set_tls_validation_flags
// container is not nil, container is SocketClient
// is method
func (v SocketClient) SetTlsValidationFlags(flags TlsCertificateFlags) {
	iv, err := _I.Get(1291, "SocketClient", "set_tls_validation_flags")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_flags := gi.NewIntArgument(int(flags))
	args := []gi.Argument{arg_v, arg_flags}
	iv.Call(args, nil, nil)
}

// ignore GType struct SocketClientClass
// Enum SocketClientEvent
type SocketClientEventEnum int

const (
	SocketClientEventResolving        SocketClientEventEnum = 0
	SocketClientEventResolved         SocketClientEventEnum = 1
	SocketClientEventConnecting       SocketClientEventEnum = 2
	SocketClientEventConnected        SocketClientEventEnum = 3
	SocketClientEventProxyNegotiating SocketClientEventEnum = 4
	SocketClientEventProxyNegotiated  SocketClientEventEnum = 5
	SocketClientEventTlsHandshaking   SocketClientEventEnum = 6
	SocketClientEventTlsHandshaked    SocketClientEventEnum = 7
	SocketClientEventComplete         SocketClientEventEnum = 8
)

func SocketClientEventGetType() gi.GType {
	ret := _I.GetGType(236, "SocketClientEvent")
	return ret
}

// Struct SocketClientPrivate
type SocketClientPrivate struct {
	P unsafe.Pointer
}

func SocketClientPrivateGetType() gi.GType {
	ret := _I.GetGType(237, "SocketClientPrivate")
	return ret
}

// Interface SocketConnectable
type SocketConnectable struct {
	SocketConnectableIfc
	P unsafe.Pointer
}
type SocketConnectableIfc struct{}
type ISocketConnectable interface{ P_SocketConnectable() unsafe.Pointer }

func (v SocketConnectable) P_SocketConnectable() unsafe.Pointer { return v.P }
func SocketConnectableGetType() gi.GType {
	ret := _I.GetGType(238, "SocketConnectable")
	return ret
}

// g_socket_connectable_enumerate
// container is not nil, container is SocketConnectable
// is method
func (v *SocketConnectableIfc) Enumerate() (result SocketAddressEnumerator) {
	iv, err := _I.Get(1292, "SocketConnectable", "enumerate")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_socket_connectable_proxy_enumerate
// container is not nil, container is SocketConnectable
// is method
func (v *SocketConnectableIfc) ProxyEnumerate() (result SocketAddressEnumerator) {
	iv, err := _I.Get(1293, "SocketConnectable", "proxy_enumerate")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_socket_connectable_to_string
// container is not nil, container is SocketConnectable
// is method
func (v *SocketConnectableIfc) ToString() (result string) {
	iv, err := _I.Get(1294, "SocketConnectable", "to_string")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Take()
	return
}

// ignore GType struct SocketConnectableIface
// Object SocketConnection
type SocketConnection struct {
	IOStream
}

func WrapSocketConnection(p unsafe.Pointer) (r SocketConnection) { r.P = p; return }

type ISocketConnection interface{ P_SocketConnection() unsafe.Pointer }

func (v SocketConnection) P_SocketConnection() unsafe.Pointer { return v.P }
func SocketConnectionGetType() gi.GType {
	ret := _I.GetGType(239, "SocketConnection")
	return ret
}

// g_socket_connection_factory_lookup_type
// container is not nil, container is SocketConnection
// is method
// arg0Type tag: interface, isPtr: false
func SocketConnectionFactoryLookupType1(family SocketFamilyEnum, type1 SocketTypeEnum, protocol_id int32) (result gi.GType) {
	iv, err := _I.Get(1295, "SocketConnection", "factory_lookup_type")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_family := gi.NewIntArgument(int(family))
	arg_type1 := gi.NewIntArgument(int(type1))
	arg_protocol_id := gi.NewInt32Argument(protocol_id)
	args := []gi.Argument{arg_family, arg_type1, arg_protocol_id}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = gi.GType(ret.Uint())
	return
}

// g_socket_connection_factory_register_type
// container is not nil, container is SocketConnection
// is method
// arg0Type tag: GType, isPtr: false
func SocketConnectionFactoryRegisterType1(g_type gi.GType, family SocketFamilyEnum, type1 SocketTypeEnum, protocol int32) {
	iv, err := _I.Get(1296, "SocketConnection", "factory_register_type")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_g_type := gi.NewUintArgument(uint(g_type))
	arg_family := gi.NewIntArgument(int(family))
	arg_type1 := gi.NewIntArgument(int(type1))
	arg_protocol := gi.NewInt32Argument(protocol)
	args := []gi.Argument{arg_g_type, arg_family, arg_type1, arg_protocol}
	iv.Call(args, nil, nil)
}

// g_socket_connection_connect
// container is not nil, container is SocketConnection
// is method
func (v SocketConnection) Connect(address ISocketAddress, cancellable ICancellable) (result bool, err error) {
	iv, err := _I.Get(1297, "SocketConnection", "connect")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if address != nil {
		tmp = address.P_SocketAddress()
	}
	var tmp1 unsafe.Pointer
	if cancellable != nil {
		tmp1 = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_address := gi.NewPointerArgument(tmp)
	arg_cancellable := gi.NewPointerArgument(tmp1)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_address, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Bool()
	return
}

// g_socket_connection_connect_async
// container is not nil, container is SocketConnection
// is method
func (v SocketConnection) ConnectAsync(address ISocketAddress, cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(1298, "SocketConnection", "connect_async")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if address != nil {
		tmp = address.P_SocketAddress()
	}
	var tmp1 unsafe.Pointer
	if cancellable != nil {
		tmp1 = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_address := gi.NewPointerArgument(tmp)
	arg_cancellable := gi.NewPointerArgument(tmp1)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_v, arg_address, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
}

// g_socket_connection_connect_finish
// container is not nil, container is SocketConnection
// is method
func (v SocketConnection) ConnectFinish(result IAsyncResult) (result1 bool, err error) {
	iv, err := _I.Get(1299, "SocketConnection", "connect_finish")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if result != nil {
		tmp = result.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_result := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_result, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result1 = ret.Bool()
	return
}

// g_socket_connection_get_local_address
// container is not nil, container is SocketConnection
// is method
func (v SocketConnection) GetLocalAddress() (result SocketAddress, err error) {
	iv, err := _I.Get(1300, "SocketConnection", "get_local_address")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	arg_v := gi.NewPointerArgument(v.P)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// g_socket_connection_get_remote_address
// container is not nil, container is SocketConnection
// is method
func (v SocketConnection) GetRemoteAddress() (result SocketAddress, err error) {
	iv, err := _I.Get(1301, "SocketConnection", "get_remote_address")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	arg_v := gi.NewPointerArgument(v.P)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// g_socket_connection_get_socket
// container is not nil, container is SocketConnection
// is method
func (v SocketConnection) GetSocket() (result Socket) {
	iv, err := _I.Get(1302, "SocketConnection", "get_socket")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_socket_connection_is_connected
// container is not nil, container is SocketConnection
// is method
func (v SocketConnection) IsConnected() (result bool) {
	iv, err := _I.Get(1303, "SocketConnection", "is_connected")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// ignore GType struct SocketConnectionClass
// Struct SocketConnectionPrivate
type SocketConnectionPrivate struct {
	P unsafe.Pointer
}

func SocketConnectionPrivateGetType() gi.GType {
	ret := _I.GetGType(240, "SocketConnectionPrivate")
	return ret
}

// Object SocketControlMessage
type SocketControlMessage struct {
	gobject.Object
}

func WrapSocketControlMessage(p unsafe.Pointer) (r SocketControlMessage) { r.P = p; return }

type ISocketControlMessage interface{ P_SocketControlMessage() unsafe.Pointer }

func (v SocketControlMessage) P_SocketControlMessage() unsafe.Pointer { return v.P }
func SocketControlMessageGetType() gi.GType {
	ret := _I.GetGType(241, "SocketControlMessage")
	return ret
}

// g_socket_control_message_deserialize
// container is not nil, container is SocketControlMessage
// is method
// arg0Type tag: gint32, isPtr: false
// arg 3 data lenArgIdx 2
func SocketControlMessageDeserialize1(level int32, type1 int32, size uint64, data gi.Uint8Array) (result SocketControlMessage) {
	iv, err := _I.Get(1304, "SocketControlMessage", "deserialize")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_level := gi.NewInt32Argument(level)
	arg_type1 := gi.NewInt32Argument(type1)
	arg_size := gi.NewUint64Argument(size)
	arg_data := gi.NewPointerArgument(data.P)
	args := []gi.Argument{arg_level, arg_type1, arg_size, arg_data}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_socket_control_message_get_level
// container is not nil, container is SocketControlMessage
// is method
func (v SocketControlMessage) GetLevel() (result int32) {
	iv, err := _I.Get(1305, "SocketControlMessage", "get_level")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Int32()
	return
}

// g_socket_control_message_get_msg_type
// container is not nil, container is SocketControlMessage
// is method
func (v SocketControlMessage) GetMsgType() (result int32) {
	iv, err := _I.Get(1306, "SocketControlMessage", "get_msg_type")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Int32()
	return
}

// g_socket_control_message_get_size
// container is not nil, container is SocketControlMessage
// is method
func (v SocketControlMessage) GetSize() (result uint64) {
	iv, err := _I.Get(1307, "SocketControlMessage", "get_size")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Uint64()
	return
}

// g_socket_control_message_serialize
// container is not nil, container is SocketControlMessage
// is method
func (v SocketControlMessage) Serialize(data unsafe.Pointer) {
	iv, err := _I.Get(1308, "SocketControlMessage", "serialize")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_data := gi.NewPointerArgument(data)
	args := []gi.Argument{arg_v, arg_data}
	iv.Call(args, nil, nil)
}

// ignore GType struct SocketControlMessageClass
// Struct SocketControlMessagePrivate
type SocketControlMessagePrivate struct {
	P unsafe.Pointer
}

func SocketControlMessagePrivateGetType() gi.GType {
	ret := _I.GetGType(242, "SocketControlMessagePrivate")
	return ret
}

// Enum SocketFamily
type SocketFamilyEnum int

const (
	SocketFamilyInvalid SocketFamilyEnum = 0
	SocketFamilyUnix    SocketFamilyEnum = 1
	SocketFamilyIpv4    SocketFamilyEnum = 2
	SocketFamilyIpv6    SocketFamilyEnum = 10
)

func SocketFamilyGetType() gi.GType {
	ret := _I.GetGType(243, "SocketFamily")
	return ret
}

// Object SocketListener
type SocketListener struct {
	gobject.Object
}

func WrapSocketListener(p unsafe.Pointer) (r SocketListener) { r.P = p; return }

type ISocketListener interface{ P_SocketListener() unsafe.Pointer }

func (v SocketListener) P_SocketListener() unsafe.Pointer { return v.P }
func SocketListenerGetType() gi.GType {
	ret := _I.GetGType(244, "SocketListener")
	return ret
}

// g_socket_listener_new
// container is not nil, container is SocketListener
// is constructor
func NewSocketListener() (result SocketListener) {
	iv, err := _I.Get(1309, "SocketListener", "new")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var ret gi.Argument
	iv.Call(nil, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_socket_listener_accept
// container is not nil, container is SocketListener
// is method
func (v SocketListener) Accept(cancellable ICancellable) (result SocketConnection, source_object gobject.Object, err error) {
	iv, err := _I.Get(1310, "SocketListener", "accept")
	if err != nil {
		return
	}
	var outArgs [2]gi.Argument
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_source_object := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[1]))
	args := []gi.Argument{arg_v, arg_source_object, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[1].Pointer())
	source_object.P = outArgs[0].Pointer()
	result.P = ret.Pointer()
	return
}

// g_socket_listener_accept_async
// container is not nil, container is SocketListener
// is method
func (v SocketListener) AcceptAsync(cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(1311, "SocketListener", "accept_async")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_v, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
}

// g_socket_listener_accept_finish
// container is not nil, container is SocketListener
// is method
func (v SocketListener) AcceptFinish(result IAsyncResult) (result1 SocketConnection, source_object gobject.Object, err error) {
	iv, err := _I.Get(1312, "SocketListener", "accept_finish")
	if err != nil {
		return
	}
	var outArgs [2]gi.Argument
	var tmp unsafe.Pointer
	if result != nil {
		tmp = result.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_result := gi.NewPointerArgument(tmp)
	arg_source_object := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[1]))
	args := []gi.Argument{arg_v, arg_result, arg_source_object, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[1].Pointer())
	source_object.P = outArgs[0].Pointer()
	result1.P = ret.Pointer()
	return
}

// g_socket_listener_accept_socket
// container is not nil, container is SocketListener
// is method
func (v SocketListener) AcceptSocket(cancellable ICancellable) (result Socket, source_object gobject.Object, err error) {
	iv, err := _I.Get(1313, "SocketListener", "accept_socket")
	if err != nil {
		return
	}
	var outArgs [2]gi.Argument
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_source_object := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[1]))
	args := []gi.Argument{arg_v, arg_source_object, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[1].Pointer())
	source_object.P = outArgs[0].Pointer()
	result.P = ret.Pointer()
	return
}

// g_socket_listener_accept_socket_async
// container is not nil, container is SocketListener
// is method
func (v SocketListener) AcceptSocketAsync(cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(1314, "SocketListener", "accept_socket_async")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_v, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
}

// g_socket_listener_accept_socket_finish
// container is not nil, container is SocketListener
// is method
func (v SocketListener) AcceptSocketFinish(result IAsyncResult) (result1 Socket, source_object gobject.Object, err error) {
	iv, err := _I.Get(1315, "SocketListener", "accept_socket_finish")
	if err != nil {
		return
	}
	var outArgs [2]gi.Argument
	var tmp unsafe.Pointer
	if result != nil {
		tmp = result.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_result := gi.NewPointerArgument(tmp)
	arg_source_object := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[1]))
	args := []gi.Argument{arg_v, arg_result, arg_source_object, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[1].Pointer())
	source_object.P = outArgs[0].Pointer()
	result1.P = ret.Pointer()
	return
}

// g_socket_listener_add_address
// container is not nil, container is SocketListener
// is method
func (v SocketListener) AddAddress(address ISocketAddress, type1 SocketTypeEnum, protocol SocketProtocolEnum, source_object gobject.IObject) (result bool, effective_address SocketAddress, err error) {
	iv, err := _I.Get(1316, "SocketListener", "add_address")
	if err != nil {
		return
	}
	var outArgs [2]gi.Argument
	var tmp unsafe.Pointer
	if address != nil {
		tmp = address.P_SocketAddress()
	}
	var tmp1 unsafe.Pointer
	if source_object != nil {
		tmp1 = source_object.P_Object()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_address := gi.NewPointerArgument(tmp)
	arg_type1 := gi.NewIntArgument(int(type1))
	arg_protocol := gi.NewIntArgument(int(protocol))
	arg_source_object := gi.NewPointerArgument(tmp1)
	arg_effective_address := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[1]))
	args := []gi.Argument{arg_v, arg_address, arg_type1, arg_protocol, arg_source_object, arg_effective_address, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[1].Pointer())
	effective_address.P = outArgs[0].Pointer()
	result = ret.Bool()
	return
}

// g_socket_listener_add_any_inet_port
// container is not nil, container is SocketListener
// is method
func (v SocketListener) AddAnyInetPort(source_object gobject.IObject) (result uint16, err error) {
	iv, err := _I.Get(1317, "SocketListener", "add_any_inet_port")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if source_object != nil {
		tmp = source_object.P_Object()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_source_object := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_source_object, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Uint16()
	return
}

// g_socket_listener_add_inet_port
// container is not nil, container is SocketListener
// is method
func (v SocketListener) AddInetPort(port uint16, source_object gobject.IObject) (result bool, err error) {
	iv, err := _I.Get(1318, "SocketListener", "add_inet_port")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if source_object != nil {
		tmp = source_object.P_Object()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_port := gi.NewUint16Argument(port)
	arg_source_object := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_port, arg_source_object, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Bool()
	return
}

// g_socket_listener_add_socket
// container is not nil, container is SocketListener
// is method
func (v SocketListener) AddSocket(socket ISocket, source_object gobject.IObject) (result bool, err error) {
	iv, err := _I.Get(1319, "SocketListener", "add_socket")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if socket != nil {
		tmp = socket.P_Socket()
	}
	var tmp1 unsafe.Pointer
	if source_object != nil {
		tmp1 = source_object.P_Object()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_socket := gi.NewPointerArgument(tmp)
	arg_source_object := gi.NewPointerArgument(tmp1)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_socket, arg_source_object, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Bool()
	return
}

// g_socket_listener_close
// container is not nil, container is SocketListener
// is method
func (v SocketListener) Close() {
	iv, err := _I.Get(1320, "SocketListener", "close")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	iv.Call(args, nil, nil)
}

// g_socket_listener_set_backlog
// container is not nil, container is SocketListener
// is method
func (v SocketListener) SetBacklog(listen_backlog int32) {
	iv, err := _I.Get(1321, "SocketListener", "set_backlog")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_listen_backlog := gi.NewInt32Argument(listen_backlog)
	args := []gi.Argument{arg_v, arg_listen_backlog}
	iv.Call(args, nil, nil)
}

// ignore GType struct SocketListenerClass
// Enum SocketListenerEvent
type SocketListenerEventEnum int

const (
	SocketListenerEventBinding   SocketListenerEventEnum = 0
	SocketListenerEventBound     SocketListenerEventEnum = 1
	SocketListenerEventListening SocketListenerEventEnum = 2
	SocketListenerEventListened  SocketListenerEventEnum = 3
)

func SocketListenerEventGetType() gi.GType {
	ret := _I.GetGType(245, "SocketListenerEvent")
	return ret
}

// Struct SocketListenerPrivate
type SocketListenerPrivate struct {
	P unsafe.Pointer
}

func SocketListenerPrivateGetType() gi.GType {
	ret := _I.GetGType(246, "SocketListenerPrivate")
	return ret
}

// Flags SocketMsgFlags
type SocketMsgFlags int

const (
	SocketMsgFlagsNone      SocketMsgFlags = 0
	SocketMsgFlagsOob       SocketMsgFlags = 1
	SocketMsgFlagsPeek      SocketMsgFlags = 2
	SocketMsgFlagsDontroute SocketMsgFlags = 4
)

func SocketMsgFlagsGetType() gi.GType {
	ret := _I.GetGType(247, "SocketMsgFlags")
	return ret
}

// Struct SocketPrivate
type SocketPrivate struct {
	P unsafe.Pointer
}

func SocketPrivateGetType() gi.GType {
	ret := _I.GetGType(248, "SocketPrivate")
	return ret
}

// Enum SocketProtocol
type SocketProtocolEnum int

const (
	SocketProtocolUnknown SocketProtocolEnum = -1
	SocketProtocolDefault SocketProtocolEnum = 0
	SocketProtocolTcp     SocketProtocolEnum = 6
	SocketProtocolUdp     SocketProtocolEnum = 17
	SocketProtocolSctp    SocketProtocolEnum = 132
)

func SocketProtocolGetType() gi.GType {
	ret := _I.GetGType(249, "SocketProtocol")
	return ret
}

// Object SocketService
type SocketService struct {
	SocketListener
}

func WrapSocketService(p unsafe.Pointer) (r SocketService) { r.P = p; return }

type ISocketService interface{ P_SocketService() unsafe.Pointer }

func (v SocketService) P_SocketService() unsafe.Pointer { return v.P }
func SocketServiceGetType() gi.GType {
	ret := _I.GetGType(250, "SocketService")
	return ret
}

// g_socket_service_new
// container is not nil, container is SocketService
// is constructor
func NewSocketService() (result SocketService) {
	iv, err := _I.Get(1322, "SocketService", "new")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var ret gi.Argument
	iv.Call(nil, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_socket_service_is_active
// container is not nil, container is SocketService
// is method
func (v SocketService) IsActive() (result bool) {
	iv, err := _I.Get(1323, "SocketService", "is_active")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_socket_service_start
// container is not nil, container is SocketService
// is method
func (v SocketService) Start() {
	iv, err := _I.Get(1324, "SocketService", "start")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	iv.Call(args, nil, nil)
}

// g_socket_service_stop
// container is not nil, container is SocketService
// is method
func (v SocketService) Stop() {
	iv, err := _I.Get(1325, "SocketService", "stop")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	iv.Call(args, nil, nil)
}

// ignore GType struct SocketServiceClass
// Struct SocketServicePrivate
type SocketServicePrivate struct {
	P unsafe.Pointer
}

func SocketServicePrivateGetType() gi.GType {
	ret := _I.GetGType(251, "SocketServicePrivate")
	return ret
}

type SocketSourceFuncStruct struct {
	F_socket    Socket
	F_condition glib.IOConditionFlags
}

//export mySocketSourceFunc
func mySocketSourceFunc(socket *C.GSocket, condition C.GIOCondition, user_data C.gpointer) {
	fn := gi.GetFunc(uint(uintptr(user_data)))
	args := SocketSourceFuncStruct{
		F_socket:    WrapSocket(unsafe.Pointer(socket)),
		F_condition: glib.IOConditionFlags(condition),
	}
	fn(args)
}

// Enum SocketType
type SocketTypeEnum int

const (
	SocketTypeInvalid   SocketTypeEnum = 0
	SocketTypeStream    SocketTypeEnum = 1
	SocketTypeDatagram  SocketTypeEnum = 2
	SocketTypeSeqpacket SocketTypeEnum = 3
)

func SocketTypeGetType() gi.GType {
	ret := _I.GetGType(252, "SocketType")
	return ret
}

// Struct SrvTarget
type SrvTarget struct {
	P unsafe.Pointer
}

func SrvTargetGetType() gi.GType {
	ret := _I.GetGType(253, "SrvTarget")
	return ret
}

// g_srv_target_new
// container is not nil, container is SrvTarget
// is constructor
func NewSrvTarget(hostname string, port uint16, priority uint16, weight uint16) (result SrvTarget) {
	iv, err := _I.Get(1326, "SrvTarget", "new")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_hostname := gi.CString(hostname)
	arg_hostname := gi.NewStringArgument(c_hostname)
	arg_port := gi.NewUint16Argument(port)
	arg_priority := gi.NewUint16Argument(priority)
	arg_weight := gi.NewUint16Argument(weight)
	args := []gi.Argument{arg_hostname, arg_port, arg_priority, arg_weight}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_hostname)
	result.P = ret.Pointer()
	return
}

// g_srv_target_copy
// container is not nil, container is SrvTarget
// is method
func (v SrvTarget) Copy() (result SrvTarget) {
	iv, err := _I.Get(1327, "SrvTarget", "copy")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_srv_target_free
// container is not nil, container is SrvTarget
// is method
func (v SrvTarget) Free() {
	iv, err := _I.Get(1328, "SrvTarget", "free")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	iv.Call(args, nil, nil)
}

// g_srv_target_get_hostname
// container is not nil, container is SrvTarget
// is method
func (v SrvTarget) GetHostname() (result string) {
	iv, err := _I.Get(1329, "SrvTarget", "get_hostname")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Take()
	return
}

// g_srv_target_get_port
// container is not nil, container is SrvTarget
// is method
func (v SrvTarget) GetPort() (result uint16) {
	iv, err := _I.Get(1330, "SrvTarget", "get_port")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Uint16()
	return
}

// g_srv_target_get_priority
// container is not nil, container is SrvTarget
// is method
func (v SrvTarget) GetPriority() (result uint16) {
	iv, err := _I.Get(1331, "SrvTarget", "get_priority")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Uint16()
	return
}

// g_srv_target_get_weight
// container is not nil, container is SrvTarget
// is method
func (v SrvTarget) GetWeight() (result uint16) {
	iv, err := _I.Get(1332, "SrvTarget", "get_weight")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Uint16()
	return
}

// Struct StaticResource
type StaticResource struct {
	P unsafe.Pointer
}

const SizeOfStructStaticResource = 40

func StaticResourceGetType() gi.GType {
	ret := _I.GetGType(254, "StaticResource")
	return ret
}

// g_static_resource_fini
// container is not nil, container is StaticResource
// is method
func (v StaticResource) Fini() {
	iv, err := _I.Get(1333, "StaticResource", "fini")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	iv.Call(args, nil, nil)
}

// g_static_resource_get_resource
// container is not nil, container is StaticResource
// is method
func (v StaticResource) GetResource() (result Resource) {
	iv, err := _I.Get(1334, "StaticResource", "get_resource")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_static_resource_init
// container is not nil, container is StaticResource
// is method
func (v StaticResource) Init() {
	iv, err := _I.Get(1335, "StaticResource", "init")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	iv.Call(args, nil, nil)
}

// Object Subprocess
type Subprocess struct {
	InitableIfc
	gobject.Object
}

func WrapSubprocess(p unsafe.Pointer) (r Subprocess) { r.P = p; return }

type ISubprocess interface{ P_Subprocess() unsafe.Pointer }

func (v Subprocess) P_Subprocess() unsafe.Pointer { return v.P }
func (v Subprocess) P_Initable() unsafe.Pointer   { return v.P }
func SubprocessGetType() gi.GType {
	ret := _I.GetGType(255, "Subprocess")
	return ret
}

// g_subprocess_newv
// container is not nil, container is Subprocess
// is constructor
func NewSubprocess(argv gi.CStrArray, flags SubprocessFlags) (result Subprocess, err error) {
	iv, err := _I.Get(1336, "Subprocess", "new")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	arg_argv := gi.NewPointerArgument(argv.P)
	arg_flags := gi.NewIntArgument(int(flags))
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_argv, arg_flags, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// g_subprocess_communicate
// container is not nil, container is Subprocess
// is method
func (v Subprocess) Communicate(stdin_buf glib.Bytes, cancellable ICancellable) (result bool, stdout_buf glib.Bytes, stderr_buf glib.Bytes, err error) {
	iv, err := _I.Get(1337, "Subprocess", "communicate")
	if err != nil {
		return
	}
	var outArgs [3]gi.Argument
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_stdin_buf := gi.NewPointerArgument(stdin_buf.P)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_stdout_buf := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	arg_stderr_buf := gi.NewPointerArgument(unsafe.Pointer(&outArgs[1]))
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[2]))
	args := []gi.Argument{arg_v, arg_stdin_buf, arg_cancellable, arg_stdout_buf, arg_stderr_buf, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[2].Pointer())
	stdout_buf.P = outArgs[0].Pointer()
	stderr_buf.P = outArgs[1].Pointer()
	result = ret.Bool()
	return
}

// g_subprocess_communicate_async
// container is not nil, container is Subprocess
// is method
func (v Subprocess) CommunicateAsync(stdin_buf glib.Bytes, cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(1338, "Subprocess", "communicate_async")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_stdin_buf := gi.NewPointerArgument(stdin_buf.P)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_v, arg_stdin_buf, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
}

// g_subprocess_communicate_finish
// container is not nil, container is Subprocess
// is method
func (v Subprocess) CommunicateFinish(result IAsyncResult) (result1 bool, stdout_buf glib.Bytes, stderr_buf glib.Bytes, err error) {
	iv, err := _I.Get(1339, "Subprocess", "communicate_finish")
	if err != nil {
		return
	}
	var outArgs [3]gi.Argument
	var tmp unsafe.Pointer
	if result != nil {
		tmp = result.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_result := gi.NewPointerArgument(tmp)
	arg_stdout_buf := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	arg_stderr_buf := gi.NewPointerArgument(unsafe.Pointer(&outArgs[1]))
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[2]))
	args := []gi.Argument{arg_v, arg_result, arg_stdout_buf, arg_stderr_buf, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[2].Pointer())
	stdout_buf.P = outArgs[0].Pointer()
	stderr_buf.P = outArgs[1].Pointer()
	result1 = ret.Bool()
	return
}

// g_subprocess_communicate_utf8
// container is not nil, container is Subprocess
// is method
func (v Subprocess) CommunicateUtf8(stdin_buf string, cancellable ICancellable) (result bool, stdout_buf string, stderr_buf string, err error) {
	iv, err := _I.Get(1340, "Subprocess", "communicate_utf8")
	if err != nil {
		return
	}
	var outArgs [3]gi.Argument
	c_stdin_buf := gi.CString(stdin_buf)
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_stdin_buf := gi.NewStringArgument(c_stdin_buf)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_stdout_buf := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	arg_stderr_buf := gi.NewPointerArgument(unsafe.Pointer(&outArgs[1]))
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[2]))
	args := []gi.Argument{arg_v, arg_stdin_buf, arg_cancellable, arg_stdout_buf, arg_stderr_buf, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	gi.Free(c_stdin_buf)
	err = gi.ToError(outArgs[2].Pointer())
	stdout_buf = outArgs[0].String().Take()
	stderr_buf = outArgs[1].String().Take()
	result = ret.Bool()
	return
}

// g_subprocess_communicate_utf8_async
// container is not nil, container is Subprocess
// is method
func (v Subprocess) CommunicateUtf8Async(stdin_buf string, cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(1341, "Subprocess", "communicate_utf8_async")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_stdin_buf := gi.CString(stdin_buf)
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_stdin_buf := gi.NewStringArgument(c_stdin_buf)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_v, arg_stdin_buf, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
	gi.Free(c_stdin_buf)
}

// g_subprocess_communicate_utf8_finish
// container is not nil, container is Subprocess
// is method
func (v Subprocess) CommunicateUtf8Finish(result IAsyncResult) (result1 bool, stdout_buf string, stderr_buf string, err error) {
	iv, err := _I.Get(1342, "Subprocess", "communicate_utf8_finish")
	if err != nil {
		return
	}
	var outArgs [3]gi.Argument
	var tmp unsafe.Pointer
	if result != nil {
		tmp = result.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_result := gi.NewPointerArgument(tmp)
	arg_stdout_buf := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	arg_stderr_buf := gi.NewPointerArgument(unsafe.Pointer(&outArgs[1]))
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[2]))
	args := []gi.Argument{arg_v, arg_result, arg_stdout_buf, arg_stderr_buf, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[2].Pointer())
	stdout_buf = outArgs[0].String().Take()
	stderr_buf = outArgs[1].String().Take()
	result1 = ret.Bool()
	return
}

// g_subprocess_force_exit
// container is not nil, container is Subprocess
// is method
func (v Subprocess) ForceExit() {
	iv, err := _I.Get(1343, "Subprocess", "force_exit")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	iv.Call(args, nil, nil)
}

// g_subprocess_get_exit_status
// container is not nil, container is Subprocess
// is method
func (v Subprocess) GetExitStatus() (result int32) {
	iv, err := _I.Get(1344, "Subprocess", "get_exit_status")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Int32()
	return
}

// g_subprocess_get_identifier
// container is not nil, container is Subprocess
// is method
func (v Subprocess) GetIdentifier() (result string) {
	iv, err := _I.Get(1345, "Subprocess", "get_identifier")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Take()
	return
}

// g_subprocess_get_if_exited
// container is not nil, container is Subprocess
// is method
func (v Subprocess) GetIfExited() (result bool) {
	iv, err := _I.Get(1346, "Subprocess", "get_if_exited")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_subprocess_get_if_signaled
// container is not nil, container is Subprocess
// is method
func (v Subprocess) GetIfSignaled() (result bool) {
	iv, err := _I.Get(1347, "Subprocess", "get_if_signaled")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_subprocess_get_status
// container is not nil, container is Subprocess
// is method
func (v Subprocess) GetStatus() (result int32) {
	iv, err := _I.Get(1348, "Subprocess", "get_status")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Int32()
	return
}

// g_subprocess_get_stderr_pipe
// container is not nil, container is Subprocess
// is method
func (v Subprocess) GetStderrPipe() (result InputStream) {
	iv, err := _I.Get(1349, "Subprocess", "get_stderr_pipe")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_subprocess_get_stdin_pipe
// container is not nil, container is Subprocess
// is method
func (v Subprocess) GetStdinPipe() (result OutputStream) {
	iv, err := _I.Get(1350, "Subprocess", "get_stdin_pipe")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_subprocess_get_stdout_pipe
// container is not nil, container is Subprocess
// is method
func (v Subprocess) GetStdoutPipe() (result InputStream) {
	iv, err := _I.Get(1351, "Subprocess", "get_stdout_pipe")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_subprocess_get_successful
// container is not nil, container is Subprocess
// is method
func (v Subprocess) GetSuccessful() (result bool) {
	iv, err := _I.Get(1352, "Subprocess", "get_successful")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_subprocess_get_term_sig
// container is not nil, container is Subprocess
// is method
func (v Subprocess) GetTermSig() (result int32) {
	iv, err := _I.Get(1353, "Subprocess", "get_term_sig")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Int32()
	return
}

// g_subprocess_send_signal
// container is not nil, container is Subprocess
// is method
func (v Subprocess) SendSignal(signal_num int32) {
	iv, err := _I.Get(1354, "Subprocess", "send_signal")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_signal_num := gi.NewInt32Argument(signal_num)
	args := []gi.Argument{arg_v, arg_signal_num}
	iv.Call(args, nil, nil)
}

// g_subprocess_wait
// container is not nil, container is Subprocess
// is method
func (v Subprocess) Wait(cancellable ICancellable) (result bool, err error) {
	iv, err := _I.Get(1355, "Subprocess", "wait")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Bool()
	return
}

// g_subprocess_wait_async
// container is not nil, container is Subprocess
// is method
func (v Subprocess) WaitAsync(cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(1356, "Subprocess", "wait_async")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_v, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
}

// g_subprocess_wait_check
// container is not nil, container is Subprocess
// is method
func (v Subprocess) WaitCheck(cancellable ICancellable) (result bool, err error) {
	iv, err := _I.Get(1357, "Subprocess", "wait_check")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Bool()
	return
}

// g_subprocess_wait_check_async
// container is not nil, container is Subprocess
// is method
func (v Subprocess) WaitCheckAsync(cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(1358, "Subprocess", "wait_check_async")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_v, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
}

// g_subprocess_wait_check_finish
// container is not nil, container is Subprocess
// is method
func (v Subprocess) WaitCheckFinish(result IAsyncResult) (result1 bool, err error) {
	iv, err := _I.Get(1359, "Subprocess", "wait_check_finish")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if result != nil {
		tmp = result.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_result := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_result, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result1 = ret.Bool()
	return
}

// g_subprocess_wait_finish
// container is not nil, container is Subprocess
// is method
func (v Subprocess) WaitFinish(result IAsyncResult) (result1 bool, err error) {
	iv, err := _I.Get(1360, "Subprocess", "wait_finish")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if result != nil {
		tmp = result.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_result := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_result, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result1 = ret.Bool()
	return
}

// Flags SubprocessFlags
type SubprocessFlags int

const (
	SubprocessFlagsNone          SubprocessFlags = 0
	SubprocessFlagsStdinPipe     SubprocessFlags = 1
	SubprocessFlagsStdinInherit  SubprocessFlags = 2
	SubprocessFlagsStdoutPipe    SubprocessFlags = 4
	SubprocessFlagsStdoutSilence SubprocessFlags = 8
	SubprocessFlagsStderrPipe    SubprocessFlags = 16
	SubprocessFlagsStderrSilence SubprocessFlags = 32
	SubprocessFlagsStderrMerge   SubprocessFlags = 64
	SubprocessFlagsInheritFds    SubprocessFlags = 128
)

func SubprocessFlagsGetType() gi.GType {
	ret := _I.GetGType(256, "SubprocessFlags")
	return ret
}

// Object SubprocessLauncher
type SubprocessLauncher struct {
	gobject.Object
}

func WrapSubprocessLauncher(p unsafe.Pointer) (r SubprocessLauncher) { r.P = p; return }

type ISubprocessLauncher interface{ P_SubprocessLauncher() unsafe.Pointer }

func (v SubprocessLauncher) P_SubprocessLauncher() unsafe.Pointer { return v.P }
func SubprocessLauncherGetType() gi.GType {
	ret := _I.GetGType(257, "SubprocessLauncher")
	return ret
}

// g_subprocess_launcher_new
// container is not nil, container is SubprocessLauncher
// is constructor
func NewSubprocessLauncher(flags SubprocessFlags) (result SubprocessLauncher) {
	iv, err := _I.Get(1361, "SubprocessLauncher", "new")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_flags := gi.NewIntArgument(int(flags))
	args := []gi.Argument{arg_flags}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_subprocess_launcher_getenv
// container is not nil, container is SubprocessLauncher
// is method
func (v SubprocessLauncher) Getenv(variable string) (result string) {
	iv, err := _I.Get(1362, "SubprocessLauncher", "getenv")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_variable := gi.CString(variable)
	arg_v := gi.NewPointerArgument(v.P)
	arg_variable := gi.NewStringArgument(c_variable)
	args := []gi.Argument{arg_v, arg_variable}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_variable)
	result = ret.String().Take()
	return
}

// g_subprocess_launcher_set_cwd
// container is not nil, container is SubprocessLauncher
// is method
func (v SubprocessLauncher) SetCwd(cwd string) {
	iv, err := _I.Get(1363, "SubprocessLauncher", "set_cwd")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_cwd := gi.CString(cwd)
	arg_v := gi.NewPointerArgument(v.P)
	arg_cwd := gi.NewStringArgument(c_cwd)
	args := []gi.Argument{arg_v, arg_cwd}
	iv.Call(args, nil, nil)
	gi.Free(c_cwd)
}

// g_subprocess_launcher_set_environ
// container is not nil, container is SubprocessLauncher
// is method
func (v SubprocessLauncher) SetEnviron(env gi.CStrArray) {
	iv, err := _I.Get(1364, "SubprocessLauncher", "set_environ")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_env := gi.NewPointerArgument(env.P)
	args := []gi.Argument{arg_v, arg_env}
	iv.Call(args, nil, nil)
}

// g_subprocess_launcher_set_flags
// container is not nil, container is SubprocessLauncher
// is method
func (v SubprocessLauncher) SetFlags(flags SubprocessFlags) {
	iv, err := _I.Get(1365, "SubprocessLauncher", "set_flags")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_flags := gi.NewIntArgument(int(flags))
	args := []gi.Argument{arg_v, arg_flags}
	iv.Call(args, nil, nil)
}

// g_subprocess_launcher_set_stderr_file_path
// container is not nil, container is SubprocessLauncher
// is method
func (v SubprocessLauncher) SetStderrFilePath(path string) {
	iv, err := _I.Get(1366, "SubprocessLauncher", "set_stderr_file_path")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_path := gi.CString(path)
	arg_v := gi.NewPointerArgument(v.P)
	arg_path := gi.NewStringArgument(c_path)
	args := []gi.Argument{arg_v, arg_path}
	iv.Call(args, nil, nil)
	gi.Free(c_path)
}

// g_subprocess_launcher_set_stdin_file_path
// container is not nil, container is SubprocessLauncher
// is method
func (v SubprocessLauncher) SetStdinFilePath(path string) {
	iv, err := _I.Get(1367, "SubprocessLauncher", "set_stdin_file_path")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_path := gi.CString(path)
	arg_v := gi.NewPointerArgument(v.P)
	arg_path := gi.NewStringArgument(c_path)
	args := []gi.Argument{arg_v, arg_path}
	iv.Call(args, nil, nil)
	gi.Free(c_path)
}

// g_subprocess_launcher_set_stdout_file_path
// container is not nil, container is SubprocessLauncher
// is method
func (v SubprocessLauncher) SetStdoutFilePath(path string) {
	iv, err := _I.Get(1368, "SubprocessLauncher", "set_stdout_file_path")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_path := gi.CString(path)
	arg_v := gi.NewPointerArgument(v.P)
	arg_path := gi.NewStringArgument(c_path)
	args := []gi.Argument{arg_v, arg_path}
	iv.Call(args, nil, nil)
	gi.Free(c_path)
}

// g_subprocess_launcher_setenv
// container is not nil, container is SubprocessLauncher
// is method
func (v SubprocessLauncher) Setenv(variable string, value string, overwrite bool) {
	iv, err := _I.Get(1369, "SubprocessLauncher", "setenv")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_variable := gi.CString(variable)
	c_value := gi.CString(value)
	arg_v := gi.NewPointerArgument(v.P)
	arg_variable := gi.NewStringArgument(c_variable)
	arg_value := gi.NewStringArgument(c_value)
	arg_overwrite := gi.NewBoolArgument(overwrite)
	args := []gi.Argument{arg_v, arg_variable, arg_value, arg_overwrite}
	iv.Call(args, nil, nil)
	gi.Free(c_variable)
	gi.Free(c_value)
}

// g_subprocess_launcher_spawnv
// container is not nil, container is SubprocessLauncher
// is method
func (v SubprocessLauncher) Spawnv(argv gi.CStrArray) (result Subprocess, err error) {
	iv, err := _I.Get(1370, "SubprocessLauncher", "spawnv")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	arg_v := gi.NewPointerArgument(v.P)
	arg_argv := gi.NewPointerArgument(argv.P)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_argv, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// g_subprocess_launcher_take_fd
// container is not nil, container is SubprocessLauncher
// is method
func (v SubprocessLauncher) TakeFd(source_fd int32, target_fd int32) {
	iv, err := _I.Get(1371, "SubprocessLauncher", "take_fd")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_source_fd := gi.NewInt32Argument(source_fd)
	arg_target_fd := gi.NewInt32Argument(target_fd)
	args := []gi.Argument{arg_v, arg_source_fd, arg_target_fd}
	iv.Call(args, nil, nil)
}

// g_subprocess_launcher_take_stderr_fd
// container is not nil, container is SubprocessLauncher
// is method
func (v SubprocessLauncher) TakeStderrFd(fd int32) {
	iv, err := _I.Get(1372, "SubprocessLauncher", "take_stderr_fd")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_fd := gi.NewInt32Argument(fd)
	args := []gi.Argument{arg_v, arg_fd}
	iv.Call(args, nil, nil)
}

// g_subprocess_launcher_take_stdin_fd
// container is not nil, container is SubprocessLauncher
// is method
func (v SubprocessLauncher) TakeStdinFd(fd int32) {
	iv, err := _I.Get(1373, "SubprocessLauncher", "take_stdin_fd")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_fd := gi.NewInt32Argument(fd)
	args := []gi.Argument{arg_v, arg_fd}
	iv.Call(args, nil, nil)
}

// g_subprocess_launcher_take_stdout_fd
// container is not nil, container is SubprocessLauncher
// is method
func (v SubprocessLauncher) TakeStdoutFd(fd int32) {
	iv, err := _I.Get(1374, "SubprocessLauncher", "take_stdout_fd")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_fd := gi.NewInt32Argument(fd)
	args := []gi.Argument{arg_v, arg_fd}
	iv.Call(args, nil, nil)
}

// g_subprocess_launcher_unsetenv
// container is not nil, container is SubprocessLauncher
// is method
func (v SubprocessLauncher) Unsetenv(variable string) {
	iv, err := _I.Get(1375, "SubprocessLauncher", "unsetenv")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_variable := gi.CString(variable)
	arg_v := gi.NewPointerArgument(v.P)
	arg_variable := gi.NewStringArgument(c_variable)
	args := []gi.Argument{arg_v, arg_variable}
	iv.Call(args, nil, nil)
	gi.Free(c_variable)
}

// Object Task
type Task struct {
	AsyncResultIfc
	gobject.Object
}

func WrapTask(p unsafe.Pointer) (r Task) { r.P = p; return }

type ITask interface{ P_Task() unsafe.Pointer }

func (v Task) P_Task() unsafe.Pointer        { return v.P }
func (v Task) P_AsyncResult() unsafe.Pointer { return v.P }
func TaskGetType() gi.GType {
	ret := _I.GetGType(258, "Task")
	return ret
}

// g_task_new
// container is not nil, container is Task
// is constructor
func NewTask(source_object gobject.IObject, cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, callback_data unsafe.Pointer) (result Task) {
	iv, err := _I.Get(1376, "Task", "new")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if source_object != nil {
		tmp = source_object.P_Object()
	}
	var tmp1 unsafe.Pointer
	if cancellable != nil {
		tmp1 = cancellable.P_Cancellable()
	}
	arg_source_object := gi.NewPointerArgument(tmp)
	arg_cancellable := gi.NewPointerArgument(tmp1)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_callback_data := gi.NewPointerArgument(callback_data)
	args := []gi.Argument{arg_source_object, arg_cancellable, arg_callback, arg_callback_data}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_task_is_valid
// container is not nil, container is Task
// is method
// arg0Type tag: interface, isPtr: true
func TaskIsValid1(result IAsyncResult, source_object gobject.IObject) (result1 bool) {
	iv, err := _I.Get(1377, "Task", "is_valid")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if result != nil {
		tmp = result.P_AsyncResult()
	}
	var tmp1 unsafe.Pointer
	if source_object != nil {
		tmp1 = source_object.P_Object()
	}
	arg_result := gi.NewPointerArgument(tmp)
	arg_source_object := gi.NewPointerArgument(tmp1)
	args := []gi.Argument{arg_result, arg_source_object}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result1 = ret.Bool()
	return
}

// g_task_report_error
// container is not nil, container is Task
// is method
// arg0Type tag: interface, isPtr: true
func TaskReportError1(source_object gobject.IObject, callback int /*TODO_TYPE isPtr: false, tag: interface*/, callback_data unsafe.Pointer, source_tag unsafe.Pointer, error glib.Error) {
	iv, err := _I.Get(1378, "Task", "report_error")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if source_object != nil {
		tmp = source_object.P_Object()
	}
	arg_source_object := gi.NewPointerArgument(tmp)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_callback_data := gi.NewPointerArgument(callback_data)
	arg_source_tag := gi.NewPointerArgument(source_tag)
	arg_error := gi.NewPointerArgument(error.P)
	args := []gi.Argument{arg_source_object, arg_callback, arg_callback_data, arg_source_tag, arg_error}
	iv.Call(args, nil, nil)
}

// g_task_get_cancellable
// container is not nil, container is Task
// is method
func (v Task) GetCancellable() (result Cancellable) {
	iv, err := _I.Get(1379, "Task", "get_cancellable")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_task_get_check_cancellable
// container is not nil, container is Task
// is method
func (v Task) GetCheckCancellable() (result bool) {
	iv, err := _I.Get(1380, "Task", "get_check_cancellable")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_task_get_completed
// container is not nil, container is Task
// is method
func (v Task) GetCompleted() (result bool) {
	iv, err := _I.Get(1381, "Task", "get_completed")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_task_get_context
// container is not nil, container is Task
// is method
func (v Task) GetContext() (result glib.MainContext) {
	iv, err := _I.Get(1382, "Task", "get_context")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_task_get_priority
// container is not nil, container is Task
// is method
func (v Task) GetPriority() (result int32) {
	iv, err := _I.Get(1383, "Task", "get_priority")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Int32()
	return
}

// g_task_get_return_on_cancel
// container is not nil, container is Task
// is method
func (v Task) GetReturnOnCancel() (result bool) {
	iv, err := _I.Get(1384, "Task", "get_return_on_cancel")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_task_get_source_object
// container is not nil, container is Task
// is method
func (v Task) GetSourceObject() (result gobject.Object) {
	iv, err := _I.Get(1385, "Task", "get_source_object")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_task_get_source_tag
// container is not nil, container is Task
// is method
func (v Task) GetSourceTag() (result unsafe.Pointer) {
	iv, err := _I.Get(1386, "Task", "get_source_tag")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Pointer()
	return
}

// g_task_get_task_data
// container is not nil, container is Task
// is method
func (v Task) GetTaskData() (result unsafe.Pointer) {
	iv, err := _I.Get(1387, "Task", "get_task_data")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Pointer()
	return
}

// g_task_had_error
// container is not nil, container is Task
// is method
func (v Task) HadError() (result bool) {
	iv, err := _I.Get(1388, "Task", "had_error")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_task_propagate_boolean
// container is not nil, container is Task
// is method
func (v Task) PropagateBoolean() (result bool, err error) {
	iv, err := _I.Get(1389, "Task", "propagate_boolean")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	arg_v := gi.NewPointerArgument(v.P)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Bool()
	return
}

// g_task_propagate_int
// container is not nil, container is Task
// is method
func (v Task) PropagateInt() (result int64, err error) {
	iv, err := _I.Get(1390, "Task", "propagate_int")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	arg_v := gi.NewPointerArgument(v.P)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Int64()
	return
}

// g_task_propagate_pointer
// container is not nil, container is Task
// is method
func (v Task) PropagatePointer() (result unsafe.Pointer, err error) {
	iv, err := _I.Get(1391, "Task", "propagate_pointer")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	arg_v := gi.NewPointerArgument(v.P)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Pointer()
	return
}

// g_task_return_boolean
// container is not nil, container is Task
// is method
func (v Task) ReturnBoolean(result bool) {
	iv, err := _I.Get(1392, "Task", "return_boolean")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_result := gi.NewBoolArgument(result)
	args := []gi.Argument{arg_v, arg_result}
	iv.Call(args, nil, nil)
}

// g_task_return_error
// container is not nil, container is Task
// is method
func (v Task) ReturnError(error glib.Error) {
	iv, err := _I.Get(1393, "Task", "return_error")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_error := gi.NewPointerArgument(error.P)
	args := []gi.Argument{arg_v, arg_error}
	iv.Call(args, nil, nil)
}

// g_task_return_error_if_cancelled
// container is not nil, container is Task
// is method
func (v Task) ReturnErrorIfCancelled() (result bool) {
	iv, err := _I.Get(1394, "Task", "return_error_if_cancelled")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_task_return_int
// container is not nil, container is Task
// is method
func (v Task) ReturnInt(result int64) {
	iv, err := _I.Get(1395, "Task", "return_int")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_result := gi.NewInt64Argument(result)
	args := []gi.Argument{arg_v, arg_result}
	iv.Call(args, nil, nil)
}

// g_task_return_pointer
// container is not nil, container is Task
// is method
func (v Task) ReturnPointer(result unsafe.Pointer, result_destroy int /*TODO_TYPE isPtr: false, tag: interface*/) {
	iv, err := _I.Get(1396, "Task", "return_pointer")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_result := gi.NewPointerArgument(result)
	arg_result_destroy := gi.NewIntArgument(result_destroy) /*TODO*/
	args := []gi.Argument{arg_v, arg_result, arg_result_destroy}
	iv.Call(args, nil, nil)
}

// g_task_set_check_cancellable
// container is not nil, container is Task
// is method
func (v Task) SetCheckCancellable(check_cancellable bool) {
	iv, err := _I.Get(1397, "Task", "set_check_cancellable")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_check_cancellable := gi.NewBoolArgument(check_cancellable)
	args := []gi.Argument{arg_v, arg_check_cancellable}
	iv.Call(args, nil, nil)
}

// g_task_set_priority
// container is not nil, container is Task
// is method
func (v Task) SetPriority(priority int32) {
	iv, err := _I.Get(1398, "Task", "set_priority")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_priority := gi.NewInt32Argument(priority)
	args := []gi.Argument{arg_v, arg_priority}
	iv.Call(args, nil, nil)
}

// g_task_set_return_on_cancel
// container is not nil, container is Task
// is method
func (v Task) SetReturnOnCancel(return_on_cancel bool) (result bool) {
	iv, err := _I.Get(1399, "Task", "set_return_on_cancel")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_return_on_cancel := gi.NewBoolArgument(return_on_cancel)
	args := []gi.Argument{arg_v, arg_return_on_cancel}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_task_set_source_tag
// container is not nil, container is Task
// is method
func (v Task) SetSourceTag(source_tag unsafe.Pointer) {
	iv, err := _I.Get(1400, "Task", "set_source_tag")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_source_tag := gi.NewPointerArgument(source_tag)
	args := []gi.Argument{arg_v, arg_source_tag}
	iv.Call(args, nil, nil)
}

// g_task_set_task_data
// container is not nil, container is Task
// is method
func (v Task) SetTaskData(task_data unsafe.Pointer, task_data_destroy int /*TODO_TYPE isPtr: false, tag: interface*/) {
	iv, err := _I.Get(1401, "Task", "set_task_data")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_task_data := gi.NewPointerArgument(task_data)
	arg_task_data_destroy := gi.NewIntArgument(task_data_destroy) /*TODO*/
	args := []gi.Argument{arg_v, arg_task_data, arg_task_data_destroy}
	iv.Call(args, nil, nil)
}

// ignore GType struct TaskClass
// ignore callback TaskThreadFunc
// Object TcpConnection
type TcpConnection struct {
	SocketConnection
}

func WrapTcpConnection(p unsafe.Pointer) (r TcpConnection) { r.P = p; return }

type ITcpConnection interface{ P_TcpConnection() unsafe.Pointer }

func (v TcpConnection) P_TcpConnection() unsafe.Pointer { return v.P }
func TcpConnectionGetType() gi.GType {
	ret := _I.GetGType(259, "TcpConnection")
	return ret
}

// g_tcp_connection_get_graceful_disconnect
// container is not nil, container is TcpConnection
// is method
func (v TcpConnection) GetGracefulDisconnect() (result bool) {
	iv, err := _I.Get(1402, "TcpConnection", "get_graceful_disconnect")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_tcp_connection_set_graceful_disconnect
// container is not nil, container is TcpConnection
// is method
func (v TcpConnection) SetGracefulDisconnect(graceful_disconnect bool) {
	iv, err := _I.Get(1403, "TcpConnection", "set_graceful_disconnect")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_graceful_disconnect := gi.NewBoolArgument(graceful_disconnect)
	args := []gi.Argument{arg_v, arg_graceful_disconnect}
	iv.Call(args, nil, nil)
}

// ignore GType struct TcpConnectionClass
// Struct TcpConnectionPrivate
type TcpConnectionPrivate struct {
	P unsafe.Pointer
}

func TcpConnectionPrivateGetType() gi.GType {
	ret := _I.GetGType(260, "TcpConnectionPrivate")
	return ret
}

// Object TcpWrapperConnection
type TcpWrapperConnection struct {
	TcpConnection
}

func WrapTcpWrapperConnection(p unsafe.Pointer) (r TcpWrapperConnection) { r.P = p; return }

type ITcpWrapperConnection interface{ P_TcpWrapperConnection() unsafe.Pointer }

func (v TcpWrapperConnection) P_TcpWrapperConnection() unsafe.Pointer { return v.P }
func TcpWrapperConnectionGetType() gi.GType {
	ret := _I.GetGType(261, "TcpWrapperConnection")
	return ret
}

// g_tcp_wrapper_connection_new
// container is not nil, container is TcpWrapperConnection
// is constructor
func NewTcpWrapperConnection(base_io_stream IIOStream, socket ISocket) (result TcpWrapperConnection) {
	iv, err := _I.Get(1404, "TcpWrapperConnection", "new")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if base_io_stream != nil {
		tmp = base_io_stream.P_IOStream()
	}
	var tmp1 unsafe.Pointer
	if socket != nil {
		tmp1 = socket.P_Socket()
	}
	arg_base_io_stream := gi.NewPointerArgument(tmp)
	arg_socket := gi.NewPointerArgument(tmp1)
	args := []gi.Argument{arg_base_io_stream, arg_socket}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_tcp_wrapper_connection_get_base_io_stream
// container is not nil, container is TcpWrapperConnection
// is method
func (v TcpWrapperConnection) GetBaseIoStream() (result IOStream) {
	iv, err := _I.Get(1405, "TcpWrapperConnection", "get_base_io_stream")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// ignore GType struct TcpWrapperConnectionClass
// Struct TcpWrapperConnectionPrivate
type TcpWrapperConnectionPrivate struct {
	P unsafe.Pointer
}

func TcpWrapperConnectionPrivateGetType() gi.GType {
	ret := _I.GetGType(262, "TcpWrapperConnectionPrivate")
	return ret
}

// Object TestDBus
type TestDBus struct {
	gobject.Object
}

func WrapTestDBus(p unsafe.Pointer) (r TestDBus) { r.P = p; return }

type ITestDBus interface{ P_TestDBus() unsafe.Pointer }

func (v TestDBus) P_TestDBus() unsafe.Pointer { return v.P }
func TestDBusGetType() gi.GType {
	ret := _I.GetGType(263, "TestDBus")
	return ret
}

// g_test_dbus_new
// container is not nil, container is TestDBus
// is constructor
func NewTestDBus(flags TestDBusFlags) (result TestDBus) {
	iv, err := _I.Get(1406, "TestDBus", "new")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_flags := gi.NewIntArgument(int(flags))
	args := []gi.Argument{arg_flags}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_test_dbus_add_service_dir
// container is not nil, container is TestDBus
// is method
func (v TestDBus) AddServiceDir(path string) {
	iv, err := _I.Get(1408, "TestDBus", "add_service_dir")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_path := gi.CString(path)
	arg_v := gi.NewPointerArgument(v.P)
	arg_path := gi.NewStringArgument(c_path)
	args := []gi.Argument{arg_v, arg_path}
	iv.Call(args, nil, nil)
	gi.Free(c_path)
}

// g_test_dbus_down
// container is not nil, container is TestDBus
// is method
func (v TestDBus) Down() {
	iv, err := _I.Get(1409, "TestDBus", "down")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	iv.Call(args, nil, nil)
}

// g_test_dbus_get_bus_address
// container is not nil, container is TestDBus
// is method
func (v TestDBus) GetBusAddress() (result string) {
	iv, err := _I.Get(1410, "TestDBus", "get_bus_address")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Take()
	return
}

// g_test_dbus_get_flags
// container is not nil, container is TestDBus
// is method
func (v TestDBus) GetFlags() (result TestDBusFlags) {
	iv, err := _I.Get(1411, "TestDBus", "get_flags")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = TestDBusFlags(ret.Int())
	return
}

// g_test_dbus_stop
// container is not nil, container is TestDBus
// is method
func (v TestDBus) Stop() {
	iv, err := _I.Get(1412, "TestDBus", "stop")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	iv.Call(args, nil, nil)
}

// g_test_dbus_up
// container is not nil, container is TestDBus
// is method
func (v TestDBus) Up() {
	iv, err := _I.Get(1413, "TestDBus", "up")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	iv.Call(args, nil, nil)
}

// Flags TestDBusFlags
type TestDBusFlags int

const (
	TestDBusFlagsNone TestDBusFlags = 0
)

func TestDBusFlagsGetType() gi.GType {
	ret := _I.GetGType(264, "TestDBusFlags")
	return ret
}

// Object ThemedIcon
type ThemedIcon struct {
	IconIfc
	gobject.Object
}

func WrapThemedIcon(p unsafe.Pointer) (r ThemedIcon) { r.P = p; return }

type IThemedIcon interface{ P_ThemedIcon() unsafe.Pointer }

func (v ThemedIcon) P_ThemedIcon() unsafe.Pointer { return v.P }
func (v ThemedIcon) P_Icon() unsafe.Pointer       { return v.P }
func ThemedIconGetType() gi.GType {
	ret := _I.GetGType(265, "ThemedIcon")
	return ret
}

// g_themed_icon_new
// container is not nil, container is ThemedIcon
// is constructor
func NewThemedIcon(iconname string) (result ThemedIcon) {
	iv, err := _I.Get(1414, "ThemedIcon", "new")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_iconname := gi.CString(iconname)
	arg_iconname := gi.NewStringArgument(c_iconname)
	args := []gi.Argument{arg_iconname}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_iconname)
	result.P = ret.Pointer()
	return
}

// g_themed_icon_new_from_names
// container is not nil, container is ThemedIcon
// is constructor
// arg 0 iconnames lenArgIdx 1
func NewThemedIconFromNames(iconnames gi.CStrArray, len1 int32) (result ThemedIcon) {
	iv, err := _I.Get(1415, "ThemedIcon", "new_from_names")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_iconnames := gi.NewPointerArgument(iconnames.P)
	arg_len1 := gi.NewInt32Argument(len1)
	args := []gi.Argument{arg_iconnames, arg_len1}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_themed_icon_new_with_default_fallbacks
// container is not nil, container is ThemedIcon
// is constructor
func NewThemedIconWithDefaultFallbacks(iconname string) (result ThemedIcon) {
	iv, err := _I.Get(1416, "ThemedIcon", "new_with_default_fallbacks")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_iconname := gi.CString(iconname)
	arg_iconname := gi.NewStringArgument(c_iconname)
	args := []gi.Argument{arg_iconname}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_iconname)
	result.P = ret.Pointer()
	return
}

// g_themed_icon_append_name
// container is not nil, container is ThemedIcon
// is method
func (v ThemedIcon) AppendName(iconname string) {
	iv, err := _I.Get(1417, "ThemedIcon", "append_name")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_iconname := gi.CString(iconname)
	arg_v := gi.NewPointerArgument(v.P)
	arg_iconname := gi.NewStringArgument(c_iconname)
	args := []gi.Argument{arg_v, arg_iconname}
	iv.Call(args, nil, nil)
	gi.Free(c_iconname)
}

// g_themed_icon_get_names
// container is not nil, container is ThemedIcon
// is method
func (v ThemedIcon) GetNames() (result gi.CStrArray) {
	iv, err := _I.Get(1418, "ThemedIcon", "get_names")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = gi.CStrArray{P: ret.Pointer(), Len: -1}
	result.SetLenZT()
	return
}

// g_themed_icon_prepend_name
// container is not nil, container is ThemedIcon
// is method
func (v ThemedIcon) PrependName(iconname string) {
	iv, err := _I.Get(1419, "ThemedIcon", "prepend_name")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_iconname := gi.CString(iconname)
	arg_v := gi.NewPointerArgument(v.P)
	arg_iconname := gi.NewStringArgument(c_iconname)
	args := []gi.Argument{arg_v, arg_iconname}
	iv.Call(args, nil, nil)
	gi.Free(c_iconname)
}

// ignore GType struct ThemedIconClass
// Object ThreadedSocketService
type ThreadedSocketService struct {
	SocketService
}

func WrapThreadedSocketService(p unsafe.Pointer) (r ThreadedSocketService) { r.P = p; return }

type IThreadedSocketService interface{ P_ThreadedSocketService() unsafe.Pointer }

func (v ThreadedSocketService) P_ThreadedSocketService() unsafe.Pointer { return v.P }
func ThreadedSocketServiceGetType() gi.GType {
	ret := _I.GetGType(266, "ThreadedSocketService")
	return ret
}

// g_threaded_socket_service_new
// container is not nil, container is ThreadedSocketService
// is constructor
func NewThreadedSocketService(max_threads int32) (result ThreadedSocketService) {
	iv, err := _I.Get(1420, "ThreadedSocketService", "new")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_max_threads := gi.NewInt32Argument(max_threads)
	args := []gi.Argument{arg_max_threads}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// ignore GType struct ThreadedSocketServiceClass
// Struct ThreadedSocketServicePrivate
type ThreadedSocketServicePrivate struct {
	P unsafe.Pointer
}

func ThreadedSocketServicePrivateGetType() gi.GType {
	ret := _I.GetGType(267, "ThreadedSocketServicePrivate")
	return ret
}

// Enum TlsAuthenticationMode
type TlsAuthenticationModeEnum int

const (
	TlsAuthenticationModeNone      TlsAuthenticationModeEnum = 0
	TlsAuthenticationModeRequested TlsAuthenticationModeEnum = 1
	TlsAuthenticationModeRequired  TlsAuthenticationModeEnum = 2
)

func TlsAuthenticationModeGetType() gi.GType {
	ret := _I.GetGType(268, "TlsAuthenticationMode")
	return ret
}

// Interface TlsBackend
type TlsBackend struct {
	TlsBackendIfc
	P unsafe.Pointer
}
type TlsBackendIfc struct{}
type ITlsBackend interface{ P_TlsBackend() unsafe.Pointer }

func (v TlsBackend) P_TlsBackend() unsafe.Pointer { return v.P }
func TlsBackendGetType() gi.GType {
	ret := _I.GetGType(269, "TlsBackend")
	return ret
}

// g_tls_backend_get_certificate_type
// container is not nil, container is TlsBackend
// is method
func (v *TlsBackendIfc) GetCertificateType() (result gi.GType) {
	iv, err := _I.Get(1422, "TlsBackend", "get_certificate_type")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = gi.GType(ret.Uint())
	return
}

// g_tls_backend_get_client_connection_type
// container is not nil, container is TlsBackend
// is method
func (v *TlsBackendIfc) GetClientConnectionType() (result gi.GType) {
	iv, err := _I.Get(1423, "TlsBackend", "get_client_connection_type")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = gi.GType(ret.Uint())
	return
}

// g_tls_backend_get_default_database
// container is not nil, container is TlsBackend
// is method
func (v *TlsBackendIfc) GetDefaultDatabase() (result TlsDatabase) {
	iv, err := _I.Get(1424, "TlsBackend", "get_default_database")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_tls_backend_get_dtls_client_connection_type
// container is not nil, container is TlsBackend
// is method
func (v *TlsBackendIfc) GetDtlsClientConnectionType() (result gi.GType) {
	iv, err := _I.Get(1425, "TlsBackend", "get_dtls_client_connection_type")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = gi.GType(ret.Uint())
	return
}

// g_tls_backend_get_dtls_server_connection_type
// container is not nil, container is TlsBackend
// is method
func (v *TlsBackendIfc) GetDtlsServerConnectionType() (result gi.GType) {
	iv, err := _I.Get(1426, "TlsBackend", "get_dtls_server_connection_type")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = gi.GType(ret.Uint())
	return
}

// g_tls_backend_get_file_database_type
// container is not nil, container is TlsBackend
// is method
func (v *TlsBackendIfc) GetFileDatabaseType() (result gi.GType) {
	iv, err := _I.Get(1427, "TlsBackend", "get_file_database_type")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = gi.GType(ret.Uint())
	return
}

// g_tls_backend_get_server_connection_type
// container is not nil, container is TlsBackend
// is method
func (v *TlsBackendIfc) GetServerConnectionType() (result gi.GType) {
	iv, err := _I.Get(1428, "TlsBackend", "get_server_connection_type")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = gi.GType(ret.Uint())
	return
}

// g_tls_backend_supports_dtls
// container is not nil, container is TlsBackend
// is method
func (v *TlsBackendIfc) SupportsDtls() (result bool) {
	iv, err := _I.Get(1429, "TlsBackend", "supports_dtls")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_tls_backend_supports_tls
// container is not nil, container is TlsBackend
// is method
func (v *TlsBackendIfc) SupportsTls() (result bool) {
	iv, err := _I.Get(1430, "TlsBackend", "supports_tls")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// ignore GType struct TlsBackendInterface
// Object TlsCertificate
type TlsCertificate struct {
	gobject.Object
}

func WrapTlsCertificate(p unsafe.Pointer) (r TlsCertificate) { r.P = p; return }

type ITlsCertificate interface{ P_TlsCertificate() unsafe.Pointer }

func (v TlsCertificate) P_TlsCertificate() unsafe.Pointer { return v.P }
func TlsCertificateGetType() gi.GType {
	ret := _I.GetGType(270, "TlsCertificate")
	return ret
}

// g_tls_certificate_new_from_file
// container is not nil, container is TlsCertificate
// is constructor
func NewTlsCertificateFromFile(file string) (result TlsCertificate, err error) {
	iv, err := _I.Get(1431, "TlsCertificate", "new_from_file")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	c_file := gi.CString(file)
	arg_file := gi.NewStringArgument(c_file)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_file, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	gi.Free(c_file)
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// g_tls_certificate_new_from_files
// container is not nil, container is TlsCertificate
// is constructor
func NewTlsCertificateFromFiles(cert_file string, key_file string) (result TlsCertificate, err error) {
	iv, err := _I.Get(1432, "TlsCertificate", "new_from_files")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	c_cert_file := gi.CString(cert_file)
	c_key_file := gi.CString(key_file)
	arg_cert_file := gi.NewStringArgument(c_cert_file)
	arg_key_file := gi.NewStringArgument(c_key_file)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_cert_file, arg_key_file, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	gi.Free(c_cert_file)
	gi.Free(c_key_file)
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// g_tls_certificate_new_from_pem
// container is not nil, container is TlsCertificate
// is constructor
func NewTlsCertificateFromPem(data string, length int64) (result TlsCertificate, err error) {
	iv, err := _I.Get(1433, "TlsCertificate", "new_from_pem")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	c_data := gi.CString(data)
	arg_data := gi.NewStringArgument(c_data)
	arg_length := gi.NewInt64Argument(length)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_data, arg_length, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	gi.Free(c_data)
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// g_tls_certificate_list_new_from_file
// container is not nil, container is TlsCertificate
// is method
// arg0Type tag: filename, isPtr: true
func TlsCertificateListNewFromFile1(file string) (result glib.List, err error) {
	iv, err := _I.Get(1434, "TlsCertificate", "list_new_from_file")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	c_file := gi.CString(file)
	arg_file := gi.NewStringArgument(c_file)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_file, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	gi.Free(c_file)
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// g_tls_certificate_get_issuer
// container is not nil, container is TlsCertificate
// is method
func (v TlsCertificate) GetIssuer() (result TlsCertificate) {
	iv, err := _I.Get(1435, "TlsCertificate", "get_issuer")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_tls_certificate_is_same
// container is not nil, container is TlsCertificate
// is method
func (v TlsCertificate) IsSame(cert_two ITlsCertificate) (result bool) {
	iv, err := _I.Get(1436, "TlsCertificate", "is_same")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if cert_two != nil {
		tmp = cert_two.P_TlsCertificate()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_cert_two := gi.NewPointerArgument(tmp)
	args := []gi.Argument{arg_v, arg_cert_two}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_tls_certificate_verify
// container is not nil, container is TlsCertificate
// is method
func (v TlsCertificate) Verify(identity ISocketConnectable, trusted_ca ITlsCertificate) (result TlsCertificateFlags) {
	iv, err := _I.Get(1437, "TlsCertificate", "verify")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if identity != nil {
		tmp = identity.P_SocketConnectable()
	}
	var tmp1 unsafe.Pointer
	if trusted_ca != nil {
		tmp1 = trusted_ca.P_TlsCertificate()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_identity := gi.NewPointerArgument(tmp)
	arg_trusted_ca := gi.NewPointerArgument(tmp1)
	args := []gi.Argument{arg_v, arg_identity, arg_trusted_ca}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = TlsCertificateFlags(ret.Int())
	return
}

// ignore GType struct TlsCertificateClass
// Flags TlsCertificateFlags
type TlsCertificateFlags int

const (
	TlsCertificateFlagsUnknownCa    TlsCertificateFlags = 1
	TlsCertificateFlagsBadIdentity  TlsCertificateFlags = 2
	TlsCertificateFlagsNotActivated TlsCertificateFlags = 4
	TlsCertificateFlagsExpired      TlsCertificateFlags = 8
	TlsCertificateFlagsRevoked      TlsCertificateFlags = 16
	TlsCertificateFlagsInsecure     TlsCertificateFlags = 32
	TlsCertificateFlagsGenericError TlsCertificateFlags = 64
	TlsCertificateFlagsValidateAll  TlsCertificateFlags = 127
)

func TlsCertificateFlagsGetType() gi.GType {
	ret := _I.GetGType(271, "TlsCertificateFlags")
	return ret
}

// Struct TlsCertificatePrivate
type TlsCertificatePrivate struct {
	P unsafe.Pointer
}

func TlsCertificatePrivateGetType() gi.GType {
	ret := _I.GetGType(272, "TlsCertificatePrivate")
	return ret
}

// Enum TlsCertificateRequestFlags
type TlsCertificateRequestFlagsEnum int

const (
	TlsCertificateRequestFlagsNone TlsCertificateRequestFlagsEnum = 0
)

func TlsCertificateRequestFlagsGetType() gi.GType {
	ret := _I.GetGType(273, "TlsCertificateRequestFlags")
	return ret
}

// Interface TlsClientConnection
type TlsClientConnection struct {
	TlsClientConnectionIfc
	P unsafe.Pointer
}
type TlsClientConnectionIfc struct{}
type ITlsClientConnection interface{ P_TlsClientConnection() unsafe.Pointer }

func (v TlsClientConnection) P_TlsClientConnection() unsafe.Pointer { return v.P }
func TlsClientConnectionGetType() gi.GType {
	ret := _I.GetGType(274, "TlsClientConnection")
	return ret
}

// g_tls_client_connection_new
// container is not nil, container is TlsClientConnection
// is method
// arg0Type tag: interface, isPtr: true
func TlsClientConnectionNew1(base_io_stream IIOStream, server_identity ISocketConnectable) (result TlsClientConnection, err error) {
	iv, err := _I.Get(1438, "TlsClientConnection", "new")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if base_io_stream != nil {
		tmp = base_io_stream.P_IOStream()
	}
	var tmp1 unsafe.Pointer
	if server_identity != nil {
		tmp1 = server_identity.P_SocketConnectable()
	}
	arg_base_io_stream := gi.NewPointerArgument(tmp)
	arg_server_identity := gi.NewPointerArgument(tmp1)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_base_io_stream, arg_server_identity, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// g_tls_client_connection_copy_session_state
// container is not nil, container is TlsClientConnection
// is method
func (v *TlsClientConnectionIfc) CopySessionState(source ITlsClientConnection) {
	iv, err := _I.Get(1439, "TlsClientConnection", "copy_session_state")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if source != nil {
		tmp = source.P_TlsClientConnection()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_source := gi.NewPointerArgument(tmp)
	args := []gi.Argument{arg_v, arg_source}
	iv.Call(args, nil, nil)
}

// g_tls_client_connection_get_accepted_cas
// container is not nil, container is TlsClientConnection
// is method
func (v *TlsClientConnectionIfc) GetAcceptedCas() (result glib.List) {
	iv, err := _I.Get(1440, "TlsClientConnection", "get_accepted_cas")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_tls_client_connection_get_server_identity
// container is not nil, container is TlsClientConnection
// is method
func (v *TlsClientConnectionIfc) GetServerIdentity() (result SocketConnectable) {
	iv, err := _I.Get(1441, "TlsClientConnection", "get_server_identity")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_tls_client_connection_get_use_ssl3
// container is not nil, container is TlsClientConnection
// is method
func (v *TlsClientConnectionIfc) GetUseSsl3() (result bool) {
	iv, err := _I.Get(1442, "TlsClientConnection", "get_use_ssl3")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_tls_client_connection_get_validation_flags
// container is not nil, container is TlsClientConnection
// is method
func (v *TlsClientConnectionIfc) GetValidationFlags() (result TlsCertificateFlags) {
	iv, err := _I.Get(1443, "TlsClientConnection", "get_validation_flags")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = TlsCertificateFlags(ret.Int())
	return
}

// g_tls_client_connection_set_server_identity
// container is not nil, container is TlsClientConnection
// is method
func (v *TlsClientConnectionIfc) SetServerIdentity(identity ISocketConnectable) {
	iv, err := _I.Get(1444, "TlsClientConnection", "set_server_identity")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if identity != nil {
		tmp = identity.P_SocketConnectable()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_identity := gi.NewPointerArgument(tmp)
	args := []gi.Argument{arg_v, arg_identity}
	iv.Call(args, nil, nil)
}

// g_tls_client_connection_set_use_ssl3
// container is not nil, container is TlsClientConnection
// is method
func (v *TlsClientConnectionIfc) SetUseSsl3(use_ssl3 bool) {
	iv, err := _I.Get(1445, "TlsClientConnection", "set_use_ssl3")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_use_ssl3 := gi.NewBoolArgument(use_ssl3)
	args := []gi.Argument{arg_v, arg_use_ssl3}
	iv.Call(args, nil, nil)
}

// g_tls_client_connection_set_validation_flags
// container is not nil, container is TlsClientConnection
// is method
func (v *TlsClientConnectionIfc) SetValidationFlags(flags TlsCertificateFlags) {
	iv, err := _I.Get(1446, "TlsClientConnection", "set_validation_flags")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_flags := gi.NewIntArgument(int(flags))
	args := []gi.Argument{arg_v, arg_flags}
	iv.Call(args, nil, nil)
}

// ignore GType struct TlsClientConnectionInterface
// Object TlsConnection
type TlsConnection struct {
	IOStream
}

func WrapTlsConnection(p unsafe.Pointer) (r TlsConnection) { r.P = p; return }

type ITlsConnection interface{ P_TlsConnection() unsafe.Pointer }

func (v TlsConnection) P_TlsConnection() unsafe.Pointer { return v.P }
func TlsConnectionGetType() gi.GType {
	ret := _I.GetGType(275, "TlsConnection")
	return ret
}

// g_tls_connection_emit_accept_certificate
// container is not nil, container is TlsConnection
// is method
func (v TlsConnection) EmitAcceptCertificate(peer_cert ITlsCertificate, errors TlsCertificateFlags) (result bool) {
	iv, err := _I.Get(1447, "TlsConnection", "emit_accept_certificate")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if peer_cert != nil {
		tmp = peer_cert.P_TlsCertificate()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_peer_cert := gi.NewPointerArgument(tmp)
	arg_errors := gi.NewIntArgument(int(errors))
	args := []gi.Argument{arg_v, arg_peer_cert, arg_errors}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_tls_connection_get_certificate
// container is not nil, container is TlsConnection
// is method
func (v TlsConnection) GetCertificate() (result TlsCertificate) {
	iv, err := _I.Get(1448, "TlsConnection", "get_certificate")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_tls_connection_get_database
// container is not nil, container is TlsConnection
// is method
func (v TlsConnection) GetDatabase() (result TlsDatabase) {
	iv, err := _I.Get(1449, "TlsConnection", "get_database")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_tls_connection_get_interaction
// container is not nil, container is TlsConnection
// is method
func (v TlsConnection) GetInteraction() (result TlsInteraction) {
	iv, err := _I.Get(1450, "TlsConnection", "get_interaction")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_tls_connection_get_peer_certificate
// container is not nil, container is TlsConnection
// is method
func (v TlsConnection) GetPeerCertificate() (result TlsCertificate) {
	iv, err := _I.Get(1451, "TlsConnection", "get_peer_certificate")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_tls_connection_get_peer_certificate_errors
// container is not nil, container is TlsConnection
// is method
func (v TlsConnection) GetPeerCertificateErrors() (result TlsCertificateFlags) {
	iv, err := _I.Get(1452, "TlsConnection", "get_peer_certificate_errors")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = TlsCertificateFlags(ret.Int())
	return
}

// g_tls_connection_get_rehandshake_mode
// container is not nil, container is TlsConnection
// is method
func (v TlsConnection) GetRehandshakeMode() (result TlsRehandshakeModeEnum) {
	iv, err := _I.Get(1453, "TlsConnection", "get_rehandshake_mode")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = TlsRehandshakeModeEnum(ret.Int())
	return
}

// g_tls_connection_get_require_close_notify
// container is not nil, container is TlsConnection
// is method
func (v TlsConnection) GetRequireCloseNotify() (result bool) {
	iv, err := _I.Get(1454, "TlsConnection", "get_require_close_notify")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_tls_connection_get_use_system_certdb
// container is not nil, container is TlsConnection
// is method
func (v TlsConnection) GetUseSystemCertdb() (result bool) {
	iv, err := _I.Get(1455, "TlsConnection", "get_use_system_certdb")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_tls_connection_handshake
// container is not nil, container is TlsConnection
// is method
func (v TlsConnection) Handshake(cancellable ICancellable) (result bool, err error) {
	iv, err := _I.Get(1456, "TlsConnection", "handshake")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Bool()
	return
}

// g_tls_connection_handshake_async
// container is not nil, container is TlsConnection
// is method
func (v TlsConnection) HandshakeAsync(io_priority int32, cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(1457, "TlsConnection", "handshake_async")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_io_priority := gi.NewInt32Argument(io_priority)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_v, arg_io_priority, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
}

// g_tls_connection_handshake_finish
// container is not nil, container is TlsConnection
// is method
func (v TlsConnection) HandshakeFinish(result IAsyncResult) (result1 bool, err error) {
	iv, err := _I.Get(1458, "TlsConnection", "handshake_finish")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if result != nil {
		tmp = result.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_result := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_result, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result1 = ret.Bool()
	return
}

// g_tls_connection_set_certificate
// container is not nil, container is TlsConnection
// is method
func (v TlsConnection) SetCertificate(certificate ITlsCertificate) {
	iv, err := _I.Get(1459, "TlsConnection", "set_certificate")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if certificate != nil {
		tmp = certificate.P_TlsCertificate()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_certificate := gi.NewPointerArgument(tmp)
	args := []gi.Argument{arg_v, arg_certificate}
	iv.Call(args, nil, nil)
}

// g_tls_connection_set_database
// container is not nil, container is TlsConnection
// is method
func (v TlsConnection) SetDatabase(database ITlsDatabase) {
	iv, err := _I.Get(1460, "TlsConnection", "set_database")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if database != nil {
		tmp = database.P_TlsDatabase()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_database := gi.NewPointerArgument(tmp)
	args := []gi.Argument{arg_v, arg_database}
	iv.Call(args, nil, nil)
}

// g_tls_connection_set_interaction
// container is not nil, container is TlsConnection
// is method
func (v TlsConnection) SetInteraction(interaction ITlsInteraction) {
	iv, err := _I.Get(1461, "TlsConnection", "set_interaction")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if interaction != nil {
		tmp = interaction.P_TlsInteraction()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_interaction := gi.NewPointerArgument(tmp)
	args := []gi.Argument{arg_v, arg_interaction}
	iv.Call(args, nil, nil)
}

// g_tls_connection_set_rehandshake_mode
// container is not nil, container is TlsConnection
// is method
func (v TlsConnection) SetRehandshakeMode(mode TlsRehandshakeModeEnum) {
	iv, err := _I.Get(1462, "TlsConnection", "set_rehandshake_mode")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_mode := gi.NewIntArgument(int(mode))
	args := []gi.Argument{arg_v, arg_mode}
	iv.Call(args, nil, nil)
}

// g_tls_connection_set_require_close_notify
// container is not nil, container is TlsConnection
// is method
func (v TlsConnection) SetRequireCloseNotify(require_close_notify bool) {
	iv, err := _I.Get(1463, "TlsConnection", "set_require_close_notify")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_require_close_notify := gi.NewBoolArgument(require_close_notify)
	args := []gi.Argument{arg_v, arg_require_close_notify}
	iv.Call(args, nil, nil)
}

// g_tls_connection_set_use_system_certdb
// container is not nil, container is TlsConnection
// is method
func (v TlsConnection) SetUseSystemCertdb(use_system_certdb bool) {
	iv, err := _I.Get(1464, "TlsConnection", "set_use_system_certdb")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_use_system_certdb := gi.NewBoolArgument(use_system_certdb)
	args := []gi.Argument{arg_v, arg_use_system_certdb}
	iv.Call(args, nil, nil)
}

// ignore GType struct TlsConnectionClass
// Struct TlsConnectionPrivate
type TlsConnectionPrivate struct {
	P unsafe.Pointer
}

func TlsConnectionPrivateGetType() gi.GType {
	ret := _I.GetGType(276, "TlsConnectionPrivate")
	return ret
}

// Object TlsDatabase
type TlsDatabase struct {
	gobject.Object
}

func WrapTlsDatabase(p unsafe.Pointer) (r TlsDatabase) { r.P = p; return }

type ITlsDatabase interface{ P_TlsDatabase() unsafe.Pointer }

func (v TlsDatabase) P_TlsDatabase() unsafe.Pointer { return v.P }
func TlsDatabaseGetType() gi.GType {
	ret := _I.GetGType(277, "TlsDatabase")
	return ret
}

// g_tls_database_create_certificate_handle
// container is not nil, container is TlsDatabase
// is method
func (v TlsDatabase) CreateCertificateHandle(certificate ITlsCertificate) (result string) {
	iv, err := _I.Get(1465, "TlsDatabase", "create_certificate_handle")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if certificate != nil {
		tmp = certificate.P_TlsCertificate()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_certificate := gi.NewPointerArgument(tmp)
	args := []gi.Argument{arg_v, arg_certificate}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Take()
	return
}

// g_tls_database_lookup_certificate_for_handle
// container is not nil, container is TlsDatabase
// is method
func (v TlsDatabase) LookupCertificateForHandle(handle string, interaction ITlsInteraction, flags TlsDatabaseLookupFlagsEnum, cancellable ICancellable) (result TlsCertificate, err error) {
	iv, err := _I.Get(1466, "TlsDatabase", "lookup_certificate_for_handle")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	c_handle := gi.CString(handle)
	var tmp unsafe.Pointer
	if interaction != nil {
		tmp = interaction.P_TlsInteraction()
	}
	var tmp1 unsafe.Pointer
	if cancellable != nil {
		tmp1 = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_handle := gi.NewStringArgument(c_handle)
	arg_interaction := gi.NewPointerArgument(tmp)
	arg_flags := gi.NewIntArgument(int(flags))
	arg_cancellable := gi.NewPointerArgument(tmp1)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_handle, arg_interaction, arg_flags, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	gi.Free(c_handle)
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// g_tls_database_lookup_certificate_for_handle_async
// container is not nil, container is TlsDatabase
// is method
func (v TlsDatabase) LookupCertificateForHandleAsync(handle string, interaction ITlsInteraction, flags TlsDatabaseLookupFlagsEnum, cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(1467, "TlsDatabase", "lookup_certificate_for_handle_async")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_handle := gi.CString(handle)
	var tmp unsafe.Pointer
	if interaction != nil {
		tmp = interaction.P_TlsInteraction()
	}
	var tmp1 unsafe.Pointer
	if cancellable != nil {
		tmp1 = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_handle := gi.NewStringArgument(c_handle)
	arg_interaction := gi.NewPointerArgument(tmp)
	arg_flags := gi.NewIntArgument(int(flags))
	arg_cancellable := gi.NewPointerArgument(tmp1)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_v, arg_handle, arg_interaction, arg_flags, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
	gi.Free(c_handle)
}

// g_tls_database_lookup_certificate_for_handle_finish
// container is not nil, container is TlsDatabase
// is method
func (v TlsDatabase) LookupCertificateForHandleFinish(result IAsyncResult) (result1 TlsCertificate, err error) {
	iv, err := _I.Get(1468, "TlsDatabase", "lookup_certificate_for_handle_finish")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if result != nil {
		tmp = result.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_result := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_result, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result1.P = ret.Pointer()
	return
}

// g_tls_database_lookup_certificate_issuer
// container is not nil, container is TlsDatabase
// is method
func (v TlsDatabase) LookupCertificateIssuer(certificate ITlsCertificate, interaction ITlsInteraction, flags TlsDatabaseLookupFlagsEnum, cancellable ICancellable) (result TlsCertificate, err error) {
	iv, err := _I.Get(1469, "TlsDatabase", "lookup_certificate_issuer")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if certificate != nil {
		tmp = certificate.P_TlsCertificate()
	}
	var tmp1 unsafe.Pointer
	if interaction != nil {
		tmp1 = interaction.P_TlsInteraction()
	}
	var tmp2 unsafe.Pointer
	if cancellable != nil {
		tmp2 = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_certificate := gi.NewPointerArgument(tmp)
	arg_interaction := gi.NewPointerArgument(tmp1)
	arg_flags := gi.NewIntArgument(int(flags))
	arg_cancellable := gi.NewPointerArgument(tmp2)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_certificate, arg_interaction, arg_flags, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// g_tls_database_lookup_certificate_issuer_async
// container is not nil, container is TlsDatabase
// is method
func (v TlsDatabase) LookupCertificateIssuerAsync(certificate ITlsCertificate, interaction ITlsInteraction, flags TlsDatabaseLookupFlagsEnum, cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(1470, "TlsDatabase", "lookup_certificate_issuer_async")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if certificate != nil {
		tmp = certificate.P_TlsCertificate()
	}
	var tmp1 unsafe.Pointer
	if interaction != nil {
		tmp1 = interaction.P_TlsInteraction()
	}
	var tmp2 unsafe.Pointer
	if cancellable != nil {
		tmp2 = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_certificate := gi.NewPointerArgument(tmp)
	arg_interaction := gi.NewPointerArgument(tmp1)
	arg_flags := gi.NewIntArgument(int(flags))
	arg_cancellable := gi.NewPointerArgument(tmp2)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_v, arg_certificate, arg_interaction, arg_flags, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
}

// g_tls_database_lookup_certificate_issuer_finish
// container is not nil, container is TlsDatabase
// is method
func (v TlsDatabase) LookupCertificateIssuerFinish(result IAsyncResult) (result1 TlsCertificate, err error) {
	iv, err := _I.Get(1471, "TlsDatabase", "lookup_certificate_issuer_finish")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if result != nil {
		tmp = result.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_result := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_result, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result1.P = ret.Pointer()
	return
}

// g_tls_database_lookup_certificates_issued_by
// container is not nil, container is TlsDatabase
// is method
func (v TlsDatabase) LookupCertificatesIssuedBy(issuer_raw_dn glib.ByteArray, interaction ITlsInteraction, flags TlsDatabaseLookupFlagsEnum, cancellable ICancellable) (result glib.List, err error) {
	iv, err := _I.Get(1472, "TlsDatabase", "lookup_certificates_issued_by")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if interaction != nil {
		tmp = interaction.P_TlsInteraction()
	}
	var tmp1 unsafe.Pointer
	if cancellable != nil {
		tmp1 = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_issuer_raw_dn := gi.NewPointerArgument(issuer_raw_dn.P)
	arg_interaction := gi.NewPointerArgument(tmp)
	arg_flags := gi.NewIntArgument(int(flags))
	arg_cancellable := gi.NewPointerArgument(tmp1)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_issuer_raw_dn, arg_interaction, arg_flags, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// g_tls_database_lookup_certificates_issued_by_async
// container is not nil, container is TlsDatabase
// is method
func (v TlsDatabase) LookupCertificatesIssuedByAsync(issuer_raw_dn glib.ByteArray, interaction ITlsInteraction, flags TlsDatabaseLookupFlagsEnum, cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(1473, "TlsDatabase", "lookup_certificates_issued_by_async")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if interaction != nil {
		tmp = interaction.P_TlsInteraction()
	}
	var tmp1 unsafe.Pointer
	if cancellable != nil {
		tmp1 = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_issuer_raw_dn := gi.NewPointerArgument(issuer_raw_dn.P)
	arg_interaction := gi.NewPointerArgument(tmp)
	arg_flags := gi.NewIntArgument(int(flags))
	arg_cancellable := gi.NewPointerArgument(tmp1)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_v, arg_issuer_raw_dn, arg_interaction, arg_flags, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
}

// g_tls_database_lookup_certificates_issued_by_finish
// container is not nil, container is TlsDatabase
// is method
func (v TlsDatabase) LookupCertificatesIssuedByFinish(result IAsyncResult) (result1 glib.List, err error) {
	iv, err := _I.Get(1474, "TlsDatabase", "lookup_certificates_issued_by_finish")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if result != nil {
		tmp = result.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_result := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_result, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result1.P = ret.Pointer()
	return
}

// g_tls_database_verify_chain
// container is not nil, container is TlsDatabase
// is method
func (v TlsDatabase) VerifyChain(chain ITlsCertificate, purpose string, identity ISocketConnectable, interaction ITlsInteraction, flags TlsDatabaseVerifyFlags, cancellable ICancellable) (result TlsCertificateFlags, err error) {
	iv, err := _I.Get(1475, "TlsDatabase", "verify_chain")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if chain != nil {
		tmp = chain.P_TlsCertificate()
	}
	c_purpose := gi.CString(purpose)
	var tmp1 unsafe.Pointer
	if identity != nil {
		tmp1 = identity.P_SocketConnectable()
	}
	var tmp2 unsafe.Pointer
	if interaction != nil {
		tmp2 = interaction.P_TlsInteraction()
	}
	var tmp3 unsafe.Pointer
	if cancellable != nil {
		tmp3 = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_chain := gi.NewPointerArgument(tmp)
	arg_purpose := gi.NewStringArgument(c_purpose)
	arg_identity := gi.NewPointerArgument(tmp1)
	arg_interaction := gi.NewPointerArgument(tmp2)
	arg_flags := gi.NewIntArgument(int(flags))
	arg_cancellable := gi.NewPointerArgument(tmp3)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_chain, arg_purpose, arg_identity, arg_interaction, arg_flags, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	gi.Free(c_purpose)
	err = gi.ToError(outArgs[0].Pointer())
	result = TlsCertificateFlags(ret.Int())
	return
}

// g_tls_database_verify_chain_async
// container is not nil, container is TlsDatabase
// is method
func (v TlsDatabase) VerifyChainAsync(chain ITlsCertificate, purpose string, identity ISocketConnectable, interaction ITlsInteraction, flags TlsDatabaseVerifyFlags, cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(1476, "TlsDatabase", "verify_chain_async")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if chain != nil {
		tmp = chain.P_TlsCertificate()
	}
	c_purpose := gi.CString(purpose)
	var tmp1 unsafe.Pointer
	if identity != nil {
		tmp1 = identity.P_SocketConnectable()
	}
	var tmp2 unsafe.Pointer
	if interaction != nil {
		tmp2 = interaction.P_TlsInteraction()
	}
	var tmp3 unsafe.Pointer
	if cancellable != nil {
		tmp3 = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_chain := gi.NewPointerArgument(tmp)
	arg_purpose := gi.NewStringArgument(c_purpose)
	arg_identity := gi.NewPointerArgument(tmp1)
	arg_interaction := gi.NewPointerArgument(tmp2)
	arg_flags := gi.NewIntArgument(int(flags))
	arg_cancellable := gi.NewPointerArgument(tmp3)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_v, arg_chain, arg_purpose, arg_identity, arg_interaction, arg_flags, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
	gi.Free(c_purpose)
}

// g_tls_database_verify_chain_finish
// container is not nil, container is TlsDatabase
// is method
func (v TlsDatabase) VerifyChainFinish(result IAsyncResult) (result1 TlsCertificateFlags, err error) {
	iv, err := _I.Get(1477, "TlsDatabase", "verify_chain_finish")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if result != nil {
		tmp = result.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_result := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_result, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result1 = TlsCertificateFlags(ret.Int())
	return
}

// ignore GType struct TlsDatabaseClass
// Enum TlsDatabaseLookupFlags
type TlsDatabaseLookupFlagsEnum int

const (
	TlsDatabaseLookupFlagsNone    TlsDatabaseLookupFlagsEnum = 0
	TlsDatabaseLookupFlagsKeypair TlsDatabaseLookupFlagsEnum = 1
)

func TlsDatabaseLookupFlagsGetType() gi.GType {
	ret := _I.GetGType(278, "TlsDatabaseLookupFlags")
	return ret
}

// Struct TlsDatabasePrivate
type TlsDatabasePrivate struct {
	P unsafe.Pointer
}

func TlsDatabasePrivateGetType() gi.GType {
	ret := _I.GetGType(279, "TlsDatabasePrivate")
	return ret
}

// Flags TlsDatabaseVerifyFlags
type TlsDatabaseVerifyFlags int

const (
	TlsDatabaseVerifyFlagsNone TlsDatabaseVerifyFlags = 0
)

func TlsDatabaseVerifyFlagsGetType() gi.GType {
	ret := _I.GetGType(280, "TlsDatabaseVerifyFlags")
	return ret
}

// Enum TlsError
type TlsErrorEnum int

const (
	TlsErrorUnavailable         TlsErrorEnum = 0
	TlsErrorMisc                TlsErrorEnum = 1
	TlsErrorBadCertificate      TlsErrorEnum = 2
	TlsErrorNotTls              TlsErrorEnum = 3
	TlsErrorHandshake           TlsErrorEnum = 4
	TlsErrorCertificateRequired TlsErrorEnum = 5
	TlsErrorEof                 TlsErrorEnum = 6
)

func TlsErrorGetType() gi.GType {
	ret := _I.GetGType(281, "TlsError")
	return ret
}

// Interface TlsFileDatabase
type TlsFileDatabase struct {
	TlsFileDatabaseIfc
	P unsafe.Pointer
}
type TlsFileDatabaseIfc struct{}
type ITlsFileDatabase interface{ P_TlsFileDatabase() unsafe.Pointer }

func (v TlsFileDatabase) P_TlsFileDatabase() unsafe.Pointer { return v.P }
func TlsFileDatabaseGetType() gi.GType {
	ret := _I.GetGType(282, "TlsFileDatabase")
	return ret
}

// g_tls_file_database_new
// container is not nil, container is TlsFileDatabase
// is method
// arg0Type tag: filename, isPtr: true
func TlsFileDatabaseNew1(anchors string) (result TlsFileDatabase, err error) {
	iv, err := _I.Get(1478, "TlsFileDatabase", "new")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	c_anchors := gi.CString(anchors)
	arg_anchors := gi.NewStringArgument(c_anchors)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_anchors, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	gi.Free(c_anchors)
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// ignore GType struct TlsFileDatabaseInterface
// Object TlsInteraction
type TlsInteraction struct {
	gobject.Object
}

func WrapTlsInteraction(p unsafe.Pointer) (r TlsInteraction) { r.P = p; return }

type ITlsInteraction interface{ P_TlsInteraction() unsafe.Pointer }

func (v TlsInteraction) P_TlsInteraction() unsafe.Pointer { return v.P }
func TlsInteractionGetType() gi.GType {
	ret := _I.GetGType(283, "TlsInteraction")
	return ret
}

// g_tls_interaction_ask_password
// container is not nil, container is TlsInteraction
// is method
func (v TlsInteraction) AskPassword(password ITlsPassword, cancellable ICancellable) (result TlsInteractionResultEnum, err error) {
	iv, err := _I.Get(1479, "TlsInteraction", "ask_password")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if password != nil {
		tmp = password.P_TlsPassword()
	}
	var tmp1 unsafe.Pointer
	if cancellable != nil {
		tmp1 = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_password := gi.NewPointerArgument(tmp)
	arg_cancellable := gi.NewPointerArgument(tmp1)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_password, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = TlsInteractionResultEnum(ret.Int())
	return
}

// g_tls_interaction_ask_password_async
// container is not nil, container is TlsInteraction
// is method
func (v TlsInteraction) AskPasswordAsync(password ITlsPassword, cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(1480, "TlsInteraction", "ask_password_async")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if password != nil {
		tmp = password.P_TlsPassword()
	}
	var tmp1 unsafe.Pointer
	if cancellable != nil {
		tmp1 = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_password := gi.NewPointerArgument(tmp)
	arg_cancellable := gi.NewPointerArgument(tmp1)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_v, arg_password, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
}

// g_tls_interaction_ask_password_finish
// container is not nil, container is TlsInteraction
// is method
func (v TlsInteraction) AskPasswordFinish(result IAsyncResult) (result1 TlsInteractionResultEnum, err error) {
	iv, err := _I.Get(1481, "TlsInteraction", "ask_password_finish")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if result != nil {
		tmp = result.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_result := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_result, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result1 = TlsInteractionResultEnum(ret.Int())
	return
}

// g_tls_interaction_invoke_ask_password
// container is not nil, container is TlsInteraction
// is method
func (v TlsInteraction) InvokeAskPassword(password ITlsPassword, cancellable ICancellable) (result TlsInteractionResultEnum, err error) {
	iv, err := _I.Get(1482, "TlsInteraction", "invoke_ask_password")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if password != nil {
		tmp = password.P_TlsPassword()
	}
	var tmp1 unsafe.Pointer
	if cancellable != nil {
		tmp1 = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_password := gi.NewPointerArgument(tmp)
	arg_cancellable := gi.NewPointerArgument(tmp1)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_password, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = TlsInteractionResultEnum(ret.Int())
	return
}

// g_tls_interaction_invoke_request_certificate
// container is not nil, container is TlsInteraction
// is method
func (v TlsInteraction) InvokeRequestCertificate(connection ITlsConnection, flags TlsCertificateRequestFlagsEnum, cancellable ICancellable) (result TlsInteractionResultEnum, err error) {
	iv, err := _I.Get(1483, "TlsInteraction", "invoke_request_certificate")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if connection != nil {
		tmp = connection.P_TlsConnection()
	}
	var tmp1 unsafe.Pointer
	if cancellable != nil {
		tmp1 = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_connection := gi.NewPointerArgument(tmp)
	arg_flags := gi.NewIntArgument(int(flags))
	arg_cancellable := gi.NewPointerArgument(tmp1)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_connection, arg_flags, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = TlsInteractionResultEnum(ret.Int())
	return
}

// g_tls_interaction_request_certificate
// container is not nil, container is TlsInteraction
// is method
func (v TlsInteraction) RequestCertificate(connection ITlsConnection, flags TlsCertificateRequestFlagsEnum, cancellable ICancellable) (result TlsInteractionResultEnum, err error) {
	iv, err := _I.Get(1484, "TlsInteraction", "request_certificate")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if connection != nil {
		tmp = connection.P_TlsConnection()
	}
	var tmp1 unsafe.Pointer
	if cancellable != nil {
		tmp1 = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_connection := gi.NewPointerArgument(tmp)
	arg_flags := gi.NewIntArgument(int(flags))
	arg_cancellable := gi.NewPointerArgument(tmp1)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_connection, arg_flags, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = TlsInteractionResultEnum(ret.Int())
	return
}

// g_tls_interaction_request_certificate_async
// container is not nil, container is TlsInteraction
// is method
func (v TlsInteraction) RequestCertificateAsync(connection ITlsConnection, flags TlsCertificateRequestFlagsEnum, cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(1485, "TlsInteraction", "request_certificate_async")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if connection != nil {
		tmp = connection.P_TlsConnection()
	}
	var tmp1 unsafe.Pointer
	if cancellable != nil {
		tmp1 = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_connection := gi.NewPointerArgument(tmp)
	arg_flags := gi.NewIntArgument(int(flags))
	arg_cancellable := gi.NewPointerArgument(tmp1)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_v, arg_connection, arg_flags, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
}

// g_tls_interaction_request_certificate_finish
// container is not nil, container is TlsInteraction
// is method
func (v TlsInteraction) RequestCertificateFinish(result IAsyncResult) (result1 TlsInteractionResultEnum, err error) {
	iv, err := _I.Get(1486, "TlsInteraction", "request_certificate_finish")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if result != nil {
		tmp = result.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_result := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_result, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result1 = TlsInteractionResultEnum(ret.Int())
	return
}

// ignore GType struct TlsInteractionClass
// Struct TlsInteractionPrivate
type TlsInteractionPrivate struct {
	P unsafe.Pointer
}

func TlsInteractionPrivateGetType() gi.GType {
	ret := _I.GetGType(284, "TlsInteractionPrivate")
	return ret
}

// Enum TlsInteractionResult
type TlsInteractionResultEnum int

const (
	TlsInteractionResultUnhandled TlsInteractionResultEnum = 0
	TlsInteractionResultHandled   TlsInteractionResultEnum = 1
	TlsInteractionResultFailed    TlsInteractionResultEnum = 2
)

func TlsInteractionResultGetType() gi.GType {
	ret := _I.GetGType(285, "TlsInteractionResult")
	return ret
}

// Object TlsPassword
type TlsPassword struct {
	gobject.Object
}

func WrapTlsPassword(p unsafe.Pointer) (r TlsPassword) { r.P = p; return }

type ITlsPassword interface{ P_TlsPassword() unsafe.Pointer }

func (v TlsPassword) P_TlsPassword() unsafe.Pointer { return v.P }
func TlsPasswordGetType() gi.GType {
	ret := _I.GetGType(286, "TlsPassword")
	return ret
}

// g_tls_password_new
// container is not nil, container is TlsPassword
// is constructor
func NewTlsPassword(flags TlsPasswordFlags, description string) (result TlsPassword) {
	iv, err := _I.Get(1487, "TlsPassword", "new")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_description := gi.CString(description)
	arg_flags := gi.NewIntArgument(int(flags))
	arg_description := gi.NewStringArgument(c_description)
	args := []gi.Argument{arg_flags, arg_description}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_description)
	result.P = ret.Pointer()
	return
}

// g_tls_password_get_description
// container is not nil, container is TlsPassword
// is method
func (v TlsPassword) GetDescription() (result string) {
	iv, err := _I.Get(1488, "TlsPassword", "get_description")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Take()
	return
}

// g_tls_password_get_flags
// container is not nil, container is TlsPassword
// is method
func (v TlsPassword) GetFlags() (result TlsPasswordFlags) {
	iv, err := _I.Get(1489, "TlsPassword", "get_flags")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = TlsPasswordFlags(ret.Int())
	return
}

// g_tls_password_get_value
// container is not nil, container is TlsPassword
// is method
func (v TlsPassword) GetValue(length uint64) (result uint8) {
	iv, err := _I.Get(1490, "TlsPassword", "get_value")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_length := gi.NewUint64Argument(length)
	args := []gi.Argument{arg_v, arg_length}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Uint8()
	return
}

// g_tls_password_get_warning
// container is not nil, container is TlsPassword
// is method
func (v TlsPassword) GetWarning() (result string) {
	iv, err := _I.Get(1491, "TlsPassword", "get_warning")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Take()
	return
}

// g_tls_password_set_description
// container is not nil, container is TlsPassword
// is method
func (v TlsPassword) SetDescription(description string) {
	iv, err := _I.Get(1492, "TlsPassword", "set_description")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_description := gi.CString(description)
	arg_v := gi.NewPointerArgument(v.P)
	arg_description := gi.NewStringArgument(c_description)
	args := []gi.Argument{arg_v, arg_description}
	iv.Call(args, nil, nil)
	gi.Free(c_description)
}

// g_tls_password_set_flags
// container is not nil, container is TlsPassword
// is method
func (v TlsPassword) SetFlags(flags TlsPasswordFlags) {
	iv, err := _I.Get(1493, "TlsPassword", "set_flags")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_flags := gi.NewIntArgument(int(flags))
	args := []gi.Argument{arg_v, arg_flags}
	iv.Call(args, nil, nil)
}

// g_tls_password_set_value
// container is not nil, container is TlsPassword
// is method
// arg 0 value lenArgIdx 1
func (v TlsPassword) SetValue(value gi.Uint8Array, length int64) {
	iv, err := _I.Get(1494, "TlsPassword", "set_value")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_value := gi.NewPointerArgument(value.P)
	arg_length := gi.NewInt64Argument(length)
	args := []gi.Argument{arg_v, arg_value, arg_length}
	iv.Call(args, nil, nil)
}

// g_tls_password_set_value_full
// container is not nil, container is TlsPassword
// is method
// arg 0 value lenArgIdx 1
func (v TlsPassword) SetValueFull(value gi.Uint8Array, length int64, destroy int /*TODO_TYPE isPtr: false, tag: interface*/) {
	iv, err := _I.Get(1495, "TlsPassword", "set_value_full")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_value := gi.NewPointerArgument(value.P)
	arg_length := gi.NewInt64Argument(length)
	arg_destroy := gi.NewIntArgument(destroy) /*TODO*/
	args := []gi.Argument{arg_v, arg_value, arg_length, arg_destroy}
	iv.Call(args, nil, nil)
}

// g_tls_password_set_warning
// container is not nil, container is TlsPassword
// is method
func (v TlsPassword) SetWarning(warning string) {
	iv, err := _I.Get(1496, "TlsPassword", "set_warning")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_warning := gi.CString(warning)
	arg_v := gi.NewPointerArgument(v.P)
	arg_warning := gi.NewStringArgument(c_warning)
	args := []gi.Argument{arg_v, arg_warning}
	iv.Call(args, nil, nil)
	gi.Free(c_warning)
}

// ignore GType struct TlsPasswordClass
// Flags TlsPasswordFlags
type TlsPasswordFlags int

const (
	TlsPasswordFlagsNone      TlsPasswordFlags = 0
	TlsPasswordFlagsRetry     TlsPasswordFlags = 2
	TlsPasswordFlagsManyTries TlsPasswordFlags = 4
	TlsPasswordFlagsFinalTry  TlsPasswordFlags = 8
)

func TlsPasswordFlagsGetType() gi.GType {
	ret := _I.GetGType(287, "TlsPasswordFlags")
	return ret
}

// Struct TlsPasswordPrivate
type TlsPasswordPrivate struct {
	P unsafe.Pointer
}

func TlsPasswordPrivateGetType() gi.GType {
	ret := _I.GetGType(288, "TlsPasswordPrivate")
	return ret
}

// Enum TlsRehandshakeMode
type TlsRehandshakeModeEnum int

const (
	TlsRehandshakeModeNever    TlsRehandshakeModeEnum = 0
	TlsRehandshakeModeSafely   TlsRehandshakeModeEnum = 1
	TlsRehandshakeModeUnsafely TlsRehandshakeModeEnum = 2
)

func TlsRehandshakeModeGetType() gi.GType {
	ret := _I.GetGType(289, "TlsRehandshakeMode")
	return ret
}

// Interface TlsServerConnection
type TlsServerConnection struct {
	TlsServerConnectionIfc
	P unsafe.Pointer
}
type TlsServerConnectionIfc struct{}
type ITlsServerConnection interface{ P_TlsServerConnection() unsafe.Pointer }

func (v TlsServerConnection) P_TlsServerConnection() unsafe.Pointer { return v.P }
func TlsServerConnectionGetType() gi.GType {
	ret := _I.GetGType(290, "TlsServerConnection")
	return ret
}

// g_tls_server_connection_new
// container is not nil, container is TlsServerConnection
// is method
// arg0Type tag: interface, isPtr: true
func TlsServerConnectionNew1(base_io_stream IIOStream, certificate ITlsCertificate) (result TlsServerConnection, err error) {
	iv, err := _I.Get(1497, "TlsServerConnection", "new")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if base_io_stream != nil {
		tmp = base_io_stream.P_IOStream()
	}
	var tmp1 unsafe.Pointer
	if certificate != nil {
		tmp1 = certificate.P_TlsCertificate()
	}
	arg_base_io_stream := gi.NewPointerArgument(tmp)
	arg_certificate := gi.NewPointerArgument(tmp1)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_base_io_stream, arg_certificate, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// ignore GType struct TlsServerConnectionInterface
// Object UnixConnection
type UnixConnection struct {
	SocketConnection
}

func WrapUnixConnection(p unsafe.Pointer) (r UnixConnection) { r.P = p; return }

type IUnixConnection interface{ P_UnixConnection() unsafe.Pointer }

func (v UnixConnection) P_UnixConnection() unsafe.Pointer { return v.P }
func UnixConnectionGetType() gi.GType {
	ret := _I.GetGType(291, "UnixConnection")
	return ret
}

// g_unix_connection_receive_credentials
// container is not nil, container is UnixConnection
// is method
func (v UnixConnection) ReceiveCredentials(cancellable ICancellable) (result Credentials, err error) {
	iv, err := _I.Get(1498, "UnixConnection", "receive_credentials")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// g_unix_connection_receive_credentials_async
// container is not nil, container is UnixConnection
// is method
func (v UnixConnection) ReceiveCredentialsAsync(cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(1499, "UnixConnection", "receive_credentials_async")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_v, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
}

// g_unix_connection_receive_credentials_finish
// container is not nil, container is UnixConnection
// is method
func (v UnixConnection) ReceiveCredentialsFinish(result IAsyncResult) (result1 Credentials, err error) {
	iv, err := _I.Get(1500, "UnixConnection", "receive_credentials_finish")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if result != nil {
		tmp = result.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_result := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_result, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result1.P = ret.Pointer()
	return
}

// g_unix_connection_receive_fd
// container is not nil, container is UnixConnection
// is method
func (v UnixConnection) ReceiveFd(cancellable ICancellable) (result int32, err error) {
	iv, err := _I.Get(1501, "UnixConnection", "receive_fd")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Int32()
	return
}

// g_unix_connection_send_credentials
// container is not nil, container is UnixConnection
// is method
func (v UnixConnection) SendCredentials(cancellable ICancellable) (result bool, err error) {
	iv, err := _I.Get(1502, "UnixConnection", "send_credentials")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Bool()
	return
}

// g_unix_connection_send_credentials_async
// container is not nil, container is UnixConnection
// is method
func (v UnixConnection) SendCredentialsAsync(cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(1503, "UnixConnection", "send_credentials_async")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_v, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
}

// g_unix_connection_send_credentials_finish
// container is not nil, container is UnixConnection
// is method
func (v UnixConnection) SendCredentialsFinish(result IAsyncResult) (result1 bool, err error) {
	iv, err := _I.Get(1504, "UnixConnection", "send_credentials_finish")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if result != nil {
		tmp = result.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_result := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_result, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result1 = ret.Bool()
	return
}

// g_unix_connection_send_fd
// container is not nil, container is UnixConnection
// is method
func (v UnixConnection) SendFd(fd int32, cancellable ICancellable) (result bool, err error) {
	iv, err := _I.Get(1505, "UnixConnection", "send_fd")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_fd := gi.NewInt32Argument(fd)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_fd, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Bool()
	return
}

// ignore GType struct UnixConnectionClass
// Struct UnixConnectionPrivate
type UnixConnectionPrivate struct {
	P unsafe.Pointer
}

func UnixConnectionPrivateGetType() gi.GType {
	ret := _I.GetGType(292, "UnixConnectionPrivate")
	return ret
}

// Object UnixCredentialsMessage
type UnixCredentialsMessage struct {
	SocketControlMessage
}

func WrapUnixCredentialsMessage(p unsafe.Pointer) (r UnixCredentialsMessage) { r.P = p; return }

type IUnixCredentialsMessage interface{ P_UnixCredentialsMessage() unsafe.Pointer }

func (v UnixCredentialsMessage) P_UnixCredentialsMessage() unsafe.Pointer { return v.P }
func UnixCredentialsMessageGetType() gi.GType {
	ret := _I.GetGType(293, "UnixCredentialsMessage")
	return ret
}

// g_unix_credentials_message_new
// container is not nil, container is UnixCredentialsMessage
// is constructor
func NewUnixCredentialsMessage() (result UnixCredentialsMessage) {
	iv, err := _I.Get(1506, "UnixCredentialsMessage", "new")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var ret gi.Argument
	iv.Call(nil, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_unix_credentials_message_new_with_credentials
// container is not nil, container is UnixCredentialsMessage
// is constructor
func NewUnixCredentialsMessageWithCredentials(credentials ICredentials) (result UnixCredentialsMessage) {
	iv, err := _I.Get(1507, "UnixCredentialsMessage", "new_with_credentials")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if credentials != nil {
		tmp = credentials.P_Credentials()
	}
	arg_credentials := gi.NewPointerArgument(tmp)
	args := []gi.Argument{arg_credentials}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_unix_credentials_message_get_credentials
// container is not nil, container is UnixCredentialsMessage
// is method
func (v UnixCredentialsMessage) GetCredentials() (result Credentials) {
	iv, err := _I.Get(1509, "UnixCredentialsMessage", "get_credentials")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// ignore GType struct UnixCredentialsMessageClass
// Struct UnixCredentialsMessagePrivate
type UnixCredentialsMessagePrivate struct {
	P unsafe.Pointer
}

func UnixCredentialsMessagePrivateGetType() gi.GType {
	ret := _I.GetGType(294, "UnixCredentialsMessagePrivate")
	return ret
}

// Object UnixFDList
type UnixFDList struct {
	gobject.Object
}

func WrapUnixFDList(p unsafe.Pointer) (r UnixFDList) { r.P = p; return }

type IUnixFDList interface{ P_UnixFDList() unsafe.Pointer }

func (v UnixFDList) P_UnixFDList() unsafe.Pointer { return v.P }
func UnixFDListGetType() gi.GType {
	ret := _I.GetGType(295, "UnixFDList")
	return ret
}

// g_unix_fd_list_new
// container is not nil, container is UnixFDList
// is constructor
func NewUnixFDList() (result UnixFDList) {
	iv, err := _I.Get(1510, "UnixFDList", "new")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var ret gi.Argument
	iv.Call(nil, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_unix_fd_list_new_from_array
// container is not nil, container is UnixFDList
// is constructor
// arg 0 fds lenArgIdx 1
func NewUnixFDListFromArray(fds gi.Int32Array, n_fds int32) (result UnixFDList) {
	iv, err := _I.Get(1511, "UnixFDList", "new_from_array")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_fds := gi.NewPointerArgument(fds.P)
	arg_n_fds := gi.NewInt32Argument(n_fds)
	args := []gi.Argument{arg_fds, arg_n_fds}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_unix_fd_list_append
// container is not nil, container is UnixFDList
// is method
func (v UnixFDList) Append(fd int32) (result int32, err error) {
	iv, err := _I.Get(1512, "UnixFDList", "append")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	arg_v := gi.NewPointerArgument(v.P)
	arg_fd := gi.NewInt32Argument(fd)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_fd, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Int32()
	return
}

// g_unix_fd_list_get
// container is not nil, container is UnixFDList
// is method
func (v UnixFDList) Get(index_ int32) (result int32, err error) {
	iv, err := _I.Get(1513, "UnixFDList", "get")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	arg_v := gi.NewPointerArgument(v.P)
	arg_index_ := gi.NewInt32Argument(index_)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_index_, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Int32()
	return
}

// g_unix_fd_list_get_length
// container is not nil, container is UnixFDList
// is method
func (v UnixFDList) GetLength() (result int32) {
	iv, err := _I.Get(1514, "UnixFDList", "get_length")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Int32()
	return
}

// g_unix_fd_list_peek_fds
// container is not nil, container is UnixFDList
// is method
// ret lenArgIdx 0
func (v UnixFDList) PeekFds() (result gi.Int32Array) {
	iv, err := _I.Get(1515, "UnixFDList", "peek_fds")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var outArgs [1]gi.Argument
	arg_v := gi.NewPointerArgument(v.P)
	arg_length := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_length}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	var length int32
	_ = length
	length = outArgs[0].Int32()
	result = gi.Int32Array{P: ret.Pointer(), Len: int(length)}
	return
}

// g_unix_fd_list_steal_fds
// container is not nil, container is UnixFDList
// is method
// ret lenArgIdx 0
func (v UnixFDList) StealFds() (result gi.Int32Array) {
	iv, err := _I.Get(1516, "UnixFDList", "steal_fds")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var outArgs [1]gi.Argument
	arg_v := gi.NewPointerArgument(v.P)
	arg_length := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_length}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	var length int32
	_ = length
	length = outArgs[0].Int32()
	result = gi.Int32Array{P: ret.Pointer(), Len: int(length)}
	return
}

// ignore GType struct UnixFDListClass
// Struct UnixFDListPrivate
type UnixFDListPrivate struct {
	P unsafe.Pointer
}

func UnixFDListPrivateGetType() gi.GType {
	ret := _I.GetGType(296, "UnixFDListPrivate")
	return ret
}

// Object UnixFDMessage
type UnixFDMessage struct {
	SocketControlMessage
}

func WrapUnixFDMessage(p unsafe.Pointer) (r UnixFDMessage) { r.P = p; return }

type IUnixFDMessage interface{ P_UnixFDMessage() unsafe.Pointer }

func (v UnixFDMessage) P_UnixFDMessage() unsafe.Pointer { return v.P }
func UnixFDMessageGetType() gi.GType {
	ret := _I.GetGType(297, "UnixFDMessage")
	return ret
}

// g_unix_fd_message_new
// container is not nil, container is UnixFDMessage
// is constructor
func NewUnixFDMessage() (result UnixFDMessage) {
	iv, err := _I.Get(1517, "UnixFDMessage", "new")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var ret gi.Argument
	iv.Call(nil, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_unix_fd_message_new_with_fd_list
// container is not nil, container is UnixFDMessage
// is constructor
func NewUnixFDMessageWithFdList(fd_list IUnixFDList) (result UnixFDMessage) {
	iv, err := _I.Get(1518, "UnixFDMessage", "new_with_fd_list")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if fd_list != nil {
		tmp = fd_list.P_UnixFDList()
	}
	arg_fd_list := gi.NewPointerArgument(tmp)
	args := []gi.Argument{arg_fd_list}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_unix_fd_message_append_fd
// container is not nil, container is UnixFDMessage
// is method
func (v UnixFDMessage) AppendFd(fd int32) (result bool, err error) {
	iv, err := _I.Get(1519, "UnixFDMessage", "append_fd")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	arg_v := gi.NewPointerArgument(v.P)
	arg_fd := gi.NewInt32Argument(fd)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_fd, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Bool()
	return
}

// g_unix_fd_message_get_fd_list
// container is not nil, container is UnixFDMessage
// is method
func (v UnixFDMessage) GetFdList() (result UnixFDList) {
	iv, err := _I.Get(1520, "UnixFDMessage", "get_fd_list")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_unix_fd_message_steal_fds
// container is not nil, container is UnixFDMessage
// is method
// ret lenArgIdx 0
func (v UnixFDMessage) StealFds() (result gi.Int32Array) {
	iv, err := _I.Get(1521, "UnixFDMessage", "steal_fds")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var outArgs [1]gi.Argument
	arg_v := gi.NewPointerArgument(v.P)
	arg_length := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_length}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	var length int32
	_ = length
	length = outArgs[0].Int32()
	result = gi.Int32Array{P: ret.Pointer(), Len: int(length)}
	return
}

// ignore GType struct UnixFDMessageClass
// Struct UnixFDMessagePrivate
type UnixFDMessagePrivate struct {
	P unsafe.Pointer
}

func UnixFDMessagePrivateGetType() gi.GType {
	ret := _I.GetGType(298, "UnixFDMessagePrivate")
	return ret
}

// Object UnixInputStream
type UnixInputStream struct {
	FileDescriptorBasedIfc
	PollableInputStreamIfc
	InputStream
}

func WrapUnixInputStream(p unsafe.Pointer) (r UnixInputStream) { r.P = p; return }

type IUnixInputStream interface{ P_UnixInputStream() unsafe.Pointer }

func (v UnixInputStream) P_UnixInputStream() unsafe.Pointer     { return v.P }
func (v UnixInputStream) P_FileDescriptorBased() unsafe.Pointer { return v.P }
func (v UnixInputStream) P_PollableInputStream() unsafe.Pointer { return v.P }
func UnixInputStreamGetType() gi.GType {
	ret := _I.GetGType(299, "UnixInputStream")
	return ret
}

// g_unix_input_stream_new
// container is not nil, container is UnixInputStream
// is constructor
func NewUnixInputStream(fd int32, close_fd bool) (result UnixInputStream) {
	iv, err := _I.Get(1522, "UnixInputStream", "new")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_fd := gi.NewInt32Argument(fd)
	arg_close_fd := gi.NewBoolArgument(close_fd)
	args := []gi.Argument{arg_fd, arg_close_fd}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_unix_input_stream_get_close_fd
// container is not nil, container is UnixInputStream
// is method
func (v UnixInputStream) GetCloseFd() (result bool) {
	iv, err := _I.Get(1523, "UnixInputStream", "get_close_fd")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_unix_input_stream_get_fd
// container is not nil, container is UnixInputStream
// is method
func (v UnixInputStream) GetFd() (result int32) {
	iv, err := _I.Get(1524, "UnixInputStream", "get_fd")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Int32()
	return
}

// g_unix_input_stream_set_close_fd
// container is not nil, container is UnixInputStream
// is method
func (v UnixInputStream) SetCloseFd(close_fd bool) {
	iv, err := _I.Get(1525, "UnixInputStream", "set_close_fd")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_close_fd := gi.NewBoolArgument(close_fd)
	args := []gi.Argument{arg_v, arg_close_fd}
	iv.Call(args, nil, nil)
}

// ignore GType struct UnixInputStreamClass
// Struct UnixInputStreamPrivate
type UnixInputStreamPrivate struct {
	P unsafe.Pointer
}

func UnixInputStreamPrivateGetType() gi.GType {
	ret := _I.GetGType(300, "UnixInputStreamPrivate")
	return ret
}

// Struct UnixMountEntry
type UnixMountEntry struct {
	P unsafe.Pointer
}

func UnixMountEntryGetType() gi.GType {
	ret := _I.GetGType(301, "UnixMountEntry")
	return ret
}

// Object UnixMountMonitor
type UnixMountMonitor struct {
	gobject.Object
}

func WrapUnixMountMonitor(p unsafe.Pointer) (r UnixMountMonitor) { r.P = p; return }

type IUnixMountMonitor interface{ P_UnixMountMonitor() unsafe.Pointer }

func (v UnixMountMonitor) P_UnixMountMonitor() unsafe.Pointer { return v.P }
func UnixMountMonitorGetType() gi.GType {
	ret := _I.GetGType(302, "UnixMountMonitor")
	return ret
}

// g_unix_mount_monitor_new
// container is not nil, container is UnixMountMonitor
// is constructor
func NewUnixMountMonitor() (result UnixMountMonitor) {
	iv, err := _I.Get(1526, "UnixMountMonitor", "new")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var ret gi.Argument
	iv.Call(nil, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_unix_mount_monitor_set_rate_limit
// container is not nil, container is UnixMountMonitor
// is method
func (v UnixMountMonitor) SetRateLimit(limit_msec int32) {
	iv, err := _I.Get(1528, "UnixMountMonitor", "set_rate_limit")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_limit_msec := gi.NewInt32Argument(limit_msec)
	args := []gi.Argument{arg_v, arg_limit_msec}
	iv.Call(args, nil, nil)
}

// ignore GType struct UnixMountMonitorClass
// Struct UnixMountPoint
type UnixMountPoint struct {
	P unsafe.Pointer
}

func UnixMountPointGetType() gi.GType {
	ret := _I.GetGType(303, "UnixMountPoint")
	return ret
}

// g_unix_mount_point_compare
// container is not nil, container is UnixMountPoint
// is method
func (v UnixMountPoint) Compare(mount2 UnixMountPoint) (result int32) {
	iv, err := _I.Get(1529, "UnixMountPoint", "compare")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_mount2 := gi.NewPointerArgument(mount2.P)
	args := []gi.Argument{arg_v, arg_mount2}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Int32()
	return
}

// g_unix_mount_point_copy
// container is not nil, container is UnixMountPoint
// is method
func (v UnixMountPoint) Copy() (result UnixMountPoint) {
	iv, err := _I.Get(1530, "UnixMountPoint", "copy")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_unix_mount_point_free
// container is not nil, container is UnixMountPoint
// is method
func (v UnixMountPoint) Free() {
	iv, err := _I.Get(1531, "UnixMountPoint", "free")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	iv.Call(args, nil, nil)
}

// g_unix_mount_point_get_device_path
// container is not nil, container is UnixMountPoint
// is method
func (v UnixMountPoint) GetDevicePath() (result string) {
	iv, err := _I.Get(1532, "UnixMountPoint", "get_device_path")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Take()
	return
}

// g_unix_mount_point_get_fs_type
// container is not nil, container is UnixMountPoint
// is method
func (v UnixMountPoint) GetFsType() (result string) {
	iv, err := _I.Get(1533, "UnixMountPoint", "get_fs_type")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Take()
	return
}

// g_unix_mount_point_get_mount_path
// container is not nil, container is UnixMountPoint
// is method
func (v UnixMountPoint) GetMountPath() (result string) {
	iv, err := _I.Get(1534, "UnixMountPoint", "get_mount_path")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Take()
	return
}

// g_unix_mount_point_get_options
// container is not nil, container is UnixMountPoint
// is method
func (v UnixMountPoint) GetOptions() (result string) {
	iv, err := _I.Get(1535, "UnixMountPoint", "get_options")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Take()
	return
}

// g_unix_mount_point_guess_can_eject
// container is not nil, container is UnixMountPoint
// is method
func (v UnixMountPoint) GuessCanEject() (result bool) {
	iv, err := _I.Get(1536, "UnixMountPoint", "guess_can_eject")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_unix_mount_point_guess_icon
// container is not nil, container is UnixMountPoint
// is method
func (v UnixMountPoint) GuessIcon() (result Icon) {
	iv, err := _I.Get(1537, "UnixMountPoint", "guess_icon")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_unix_mount_point_guess_name
// container is not nil, container is UnixMountPoint
// is method
func (v UnixMountPoint) GuessName() (result string) {
	iv, err := _I.Get(1538, "UnixMountPoint", "guess_name")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Take()
	return
}

// g_unix_mount_point_guess_symbolic_icon
// container is not nil, container is UnixMountPoint
// is method
func (v UnixMountPoint) GuessSymbolicIcon() (result Icon) {
	iv, err := _I.Get(1539, "UnixMountPoint", "guess_symbolic_icon")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_unix_mount_point_is_loopback
// container is not nil, container is UnixMountPoint
// is method
func (v UnixMountPoint) IsLoopback() (result bool) {
	iv, err := _I.Get(1540, "UnixMountPoint", "is_loopback")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_unix_mount_point_is_readonly
// container is not nil, container is UnixMountPoint
// is method
func (v UnixMountPoint) IsReadonly() (result bool) {
	iv, err := _I.Get(1541, "UnixMountPoint", "is_readonly")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_unix_mount_point_is_user_mountable
// container is not nil, container is UnixMountPoint
// is method
func (v UnixMountPoint) IsUserMountable() (result bool) {
	iv, err := _I.Get(1542, "UnixMountPoint", "is_user_mountable")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// Object UnixOutputStream
type UnixOutputStream struct {
	FileDescriptorBasedIfc
	PollableOutputStreamIfc
	OutputStream
}

func WrapUnixOutputStream(p unsafe.Pointer) (r UnixOutputStream) { r.P = p; return }

type IUnixOutputStream interface{ P_UnixOutputStream() unsafe.Pointer }

func (v UnixOutputStream) P_UnixOutputStream() unsafe.Pointer     { return v.P }
func (v UnixOutputStream) P_FileDescriptorBased() unsafe.Pointer  { return v.P }
func (v UnixOutputStream) P_PollableOutputStream() unsafe.Pointer { return v.P }
func UnixOutputStreamGetType() gi.GType {
	ret := _I.GetGType(304, "UnixOutputStream")
	return ret
}

// g_unix_output_stream_new
// container is not nil, container is UnixOutputStream
// is constructor
func NewUnixOutputStream(fd int32, close_fd bool) (result UnixOutputStream) {
	iv, err := _I.Get(1543, "UnixOutputStream", "new")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_fd := gi.NewInt32Argument(fd)
	arg_close_fd := gi.NewBoolArgument(close_fd)
	args := []gi.Argument{arg_fd, arg_close_fd}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_unix_output_stream_get_close_fd
// container is not nil, container is UnixOutputStream
// is method
func (v UnixOutputStream) GetCloseFd() (result bool) {
	iv, err := _I.Get(1544, "UnixOutputStream", "get_close_fd")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_unix_output_stream_get_fd
// container is not nil, container is UnixOutputStream
// is method
func (v UnixOutputStream) GetFd() (result int32) {
	iv, err := _I.Get(1545, "UnixOutputStream", "get_fd")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Int32()
	return
}

// g_unix_output_stream_set_close_fd
// container is not nil, container is UnixOutputStream
// is method
func (v UnixOutputStream) SetCloseFd(close_fd bool) {
	iv, err := _I.Get(1546, "UnixOutputStream", "set_close_fd")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_close_fd := gi.NewBoolArgument(close_fd)
	args := []gi.Argument{arg_v, arg_close_fd}
	iv.Call(args, nil, nil)
}

// ignore GType struct UnixOutputStreamClass
// Struct UnixOutputStreamPrivate
type UnixOutputStreamPrivate struct {
	P unsafe.Pointer
}

func UnixOutputStreamPrivateGetType() gi.GType {
	ret := _I.GetGType(305, "UnixOutputStreamPrivate")
	return ret
}

// Object UnixSocketAddress
type UnixSocketAddress struct {
	SocketConnectableIfc
	SocketAddress
}

func WrapUnixSocketAddress(p unsafe.Pointer) (r UnixSocketAddress) { r.P = p; return }

type IUnixSocketAddress interface{ P_UnixSocketAddress() unsafe.Pointer }

func (v UnixSocketAddress) P_UnixSocketAddress() unsafe.Pointer { return v.P }
func (v UnixSocketAddress) P_SocketConnectable() unsafe.Pointer { return v.P }
func UnixSocketAddressGetType() gi.GType {
	ret := _I.GetGType(306, "UnixSocketAddress")
	return ret
}

// g_unix_socket_address_new
// container is not nil, container is UnixSocketAddress
// is constructor
func NewUnixSocketAddress(path string) (result UnixSocketAddress) {
	iv, err := _I.Get(1547, "UnixSocketAddress", "new")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_path := gi.CString(path)
	arg_path := gi.NewStringArgument(c_path)
	args := []gi.Argument{arg_path}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_path)
	result.P = ret.Pointer()
	return
}

// g_unix_socket_address_new_abstract
// container is not nil, container is UnixSocketAddress
// is constructor
// arg 0 path lenArgIdx 1
func NewUnixSocketAddressAbstract(path gi.Int8Array, path_len int32) (result UnixSocketAddress) {
	iv, err := _I.Get(1548, "UnixSocketAddress", "new_abstract")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_path := gi.NewPointerArgument(path.P)
	arg_path_len := gi.NewInt32Argument(path_len)
	args := []gi.Argument{arg_path, arg_path_len}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_unix_socket_address_new_with_type
// container is not nil, container is UnixSocketAddress
// is constructor
// arg 0 path lenArgIdx 1
func NewUnixSocketAddressWithType(path gi.Int8Array, path_len int32, type1 UnixSocketAddressTypeEnum) (result UnixSocketAddress) {
	iv, err := _I.Get(1549, "UnixSocketAddress", "new_with_type")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_path := gi.NewPointerArgument(path.P)
	arg_path_len := gi.NewInt32Argument(path_len)
	arg_type1 := gi.NewIntArgument(int(type1))
	args := []gi.Argument{arg_path, arg_path_len, arg_type1}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_unix_socket_address_get_address_type
// container is not nil, container is UnixSocketAddress
// is method
func (v UnixSocketAddress) GetAddressType() (result UnixSocketAddressTypeEnum) {
	iv, err := _I.Get(1551, "UnixSocketAddress", "get_address_type")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = UnixSocketAddressTypeEnum(ret.Int())
	return
}

// g_unix_socket_address_get_is_abstract
// container is not nil, container is UnixSocketAddress
// is method
func (v UnixSocketAddress) GetIsAbstract() (result bool) {
	iv, err := _I.Get(1552, "UnixSocketAddress", "get_is_abstract")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_unix_socket_address_get_path
// container is not nil, container is UnixSocketAddress
// is method
func (v UnixSocketAddress) GetPath() (result string) {
	iv, err := _I.Get(1553, "UnixSocketAddress", "get_path")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Take()
	return
}

// g_unix_socket_address_get_path_len
// container is not nil, container is UnixSocketAddress
// is method
func (v UnixSocketAddress) GetPathLen() (result uint64) {
	iv, err := _I.Get(1554, "UnixSocketAddress", "get_path_len")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Uint64()
	return
}

// ignore GType struct UnixSocketAddressClass
// Struct UnixSocketAddressPrivate
type UnixSocketAddressPrivate struct {
	P unsafe.Pointer
}

func UnixSocketAddressPrivateGetType() gi.GType {
	ret := _I.GetGType(307, "UnixSocketAddressPrivate")
	return ret
}

// Enum UnixSocketAddressType
type UnixSocketAddressTypeEnum int

const (
	UnixSocketAddressTypeInvalid        UnixSocketAddressTypeEnum = 0
	UnixSocketAddressTypeAnonymous      UnixSocketAddressTypeEnum = 1
	UnixSocketAddressTypePath           UnixSocketAddressTypeEnum = 2
	UnixSocketAddressTypeAbstract       UnixSocketAddressTypeEnum = 3
	UnixSocketAddressTypeAbstractPadded UnixSocketAddressTypeEnum = 4
)

func UnixSocketAddressTypeGetType() gi.GType {
	ret := _I.GetGType(308, "UnixSocketAddressType")
	return ret
}

// Object Vfs
type Vfs struct {
	gobject.Object
}

func WrapVfs(p unsafe.Pointer) (r Vfs) { r.P = p; return }

type IVfs interface{ P_Vfs() unsafe.Pointer }

func (v Vfs) P_Vfs() unsafe.Pointer { return v.P }
func VfsGetType() gi.GType {
	ret := _I.GetGType(309, "Vfs")
	return ret
}

// g_vfs_get_file_for_path
// container is not nil, container is Vfs
// is method
func (v Vfs) GetFileForPath(path string) (result File) {
	iv, err := _I.Get(1557, "Vfs", "get_file_for_path")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_path := gi.CString(path)
	arg_v := gi.NewPointerArgument(v.P)
	arg_path := gi.NewStringArgument(c_path)
	args := []gi.Argument{arg_v, arg_path}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_path)
	result.P = ret.Pointer()
	return
}

// g_vfs_get_file_for_uri
// container is not nil, container is Vfs
// is method
func (v Vfs) GetFileForUri(uri string) (result File) {
	iv, err := _I.Get(1558, "Vfs", "get_file_for_uri")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_uri := gi.CString(uri)
	arg_v := gi.NewPointerArgument(v.P)
	arg_uri := gi.NewStringArgument(c_uri)
	args := []gi.Argument{arg_v, arg_uri}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_uri)
	result.P = ret.Pointer()
	return
}

// g_vfs_get_supported_uri_schemes
// container is not nil, container is Vfs
// is method
func (v Vfs) GetSupportedUriSchemes() (result gi.CStrArray) {
	iv, err := _I.Get(1559, "Vfs", "get_supported_uri_schemes")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = gi.CStrArray{P: ret.Pointer(), Len: -1}
	result.SetLenZT()
	return
}

// g_vfs_is_active
// container is not nil, container is Vfs
// is method
func (v Vfs) IsActive() (result bool) {
	iv, err := _I.Get(1560, "Vfs", "is_active")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_vfs_parse_name
// container is not nil, container is Vfs
// is method
func (v Vfs) ParseName(parse_name string) (result File) {
	iv, err := _I.Get(1561, "Vfs", "parse_name")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_parse_name := gi.CString(parse_name)
	arg_v := gi.NewPointerArgument(v.P)
	arg_parse_name := gi.NewStringArgument(c_parse_name)
	args := []gi.Argument{arg_v, arg_parse_name}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_parse_name)
	result.P = ret.Pointer()
	return
}

// g_vfs_register_uri_scheme
// container is not nil, container is Vfs
// is method
func (v Vfs) RegisterUriScheme(scheme string, uri_func int /*TODO_TYPE isPtr: false, tag: interface*/, uri_data unsafe.Pointer, uri_destroy int /*TODO_TYPE isPtr: false, tag: interface*/, parse_name_func int /*TODO_TYPE isPtr: false, tag: interface*/, parse_name_data unsafe.Pointer, parse_name_destroy int /*TODO_TYPE isPtr: false, tag: interface*/) (result bool) {
	iv, err := _I.Get(1562, "Vfs", "register_uri_scheme")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_scheme := gi.CString(scheme)
	arg_v := gi.NewPointerArgument(v.P)
	arg_scheme := gi.NewStringArgument(c_scheme)
	arg_uri_func := gi.NewIntArgument(uri_func) /*TODO*/
	arg_uri_data := gi.NewPointerArgument(uri_data)
	arg_uri_destroy := gi.NewIntArgument(uri_destroy)         /*TODO*/
	arg_parse_name_func := gi.NewIntArgument(parse_name_func) /*TODO*/
	arg_parse_name_data := gi.NewPointerArgument(parse_name_data)
	arg_parse_name_destroy := gi.NewIntArgument(parse_name_destroy) /*TODO*/
	args := []gi.Argument{arg_v, arg_scheme, arg_uri_func, arg_uri_data, arg_uri_destroy, arg_parse_name_func, arg_parse_name_data, arg_parse_name_destroy}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_scheme)
	result = ret.Bool()
	return
}

// g_vfs_unregister_uri_scheme
// container is not nil, container is Vfs
// is method
func (v Vfs) UnregisterUriScheme(scheme string) (result bool) {
	iv, err := _I.Get(1563, "Vfs", "unregister_uri_scheme")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_scheme := gi.CString(scheme)
	arg_v := gi.NewPointerArgument(v.P)
	arg_scheme := gi.NewStringArgument(c_scheme)
	args := []gi.Argument{arg_v, arg_scheme}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_scheme)
	result = ret.Bool()
	return
}

// ignore GType struct VfsClass
type VfsFileLookupFuncStruct struct {
	F_vfs        Vfs
	F_identifier string
}

//export myVfsFileLookupFunc
func myVfsFileLookupFunc(vfs *C.GVfs, identifier *C.gchar, user_data C.gpointer) {
	fn := gi.GetFunc(uint(uintptr(user_data)))
	args := VfsFileLookupFuncStruct{
		F_vfs:        WrapVfs(unsafe.Pointer(vfs)),
		F_identifier: gi.GoString(unsafe.Pointer(identifier)),
	}
	fn(args)
}

// Interface Volume
type Volume struct {
	VolumeIfc
	P unsafe.Pointer
}
type VolumeIfc struct{}
type IVolume interface{ P_Volume() unsafe.Pointer }

func (v Volume) P_Volume() unsafe.Pointer { return v.P }
func VolumeGetType() gi.GType {
	ret := _I.GetGType(310, "Volume")
	return ret
}

// g_volume_can_eject
// container is not nil, container is Volume
// is method
func (v *VolumeIfc) CanEject() (result bool) {
	iv, err := _I.Get(1564, "Volume", "can_eject")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_volume_can_mount
// container is not nil, container is Volume
// is method
func (v *VolumeIfc) CanMount() (result bool) {
	iv, err := _I.Get(1565, "Volume", "can_mount")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_volume_eject
// container is not nil, container is Volume
// is method
func (v *VolumeIfc) Eject(flags MountUnmountFlags, cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(1566, "Volume", "eject")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_flags := gi.NewIntArgument(int(flags))
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_v, arg_flags, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
}

// g_volume_eject_finish
// container is not nil, container is Volume
// is method
func (v *VolumeIfc) EjectFinish(result IAsyncResult) (result1 bool, err error) {
	iv, err := _I.Get(1567, "Volume", "eject_finish")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if result != nil {
		tmp = result.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_result := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_result, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result1 = ret.Bool()
	return
}

// g_volume_eject_with_operation
// container is not nil, container is Volume
// is method
func (v *VolumeIfc) EjectWithOperation(flags MountUnmountFlags, mount_operation IMountOperation, cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(1568, "Volume", "eject_with_operation")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if mount_operation != nil {
		tmp = mount_operation.P_MountOperation()
	}
	var tmp1 unsafe.Pointer
	if cancellable != nil {
		tmp1 = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_flags := gi.NewIntArgument(int(flags))
	arg_mount_operation := gi.NewPointerArgument(tmp)
	arg_cancellable := gi.NewPointerArgument(tmp1)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_v, arg_flags, arg_mount_operation, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
}

// g_volume_eject_with_operation_finish
// container is not nil, container is Volume
// is method
func (v *VolumeIfc) EjectWithOperationFinish(result IAsyncResult) (result1 bool, err error) {
	iv, err := _I.Get(1569, "Volume", "eject_with_operation_finish")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if result != nil {
		tmp = result.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_result := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_result, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result1 = ret.Bool()
	return
}

// g_volume_enumerate_identifiers
// container is not nil, container is Volume
// is method
func (v *VolumeIfc) EnumerateIdentifiers() (result gi.CStrArray) {
	iv, err := _I.Get(1570, "Volume", "enumerate_identifiers")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = gi.CStrArray{P: ret.Pointer(), Len: -1}
	result.SetLenZT()
	return
}

// g_volume_get_activation_root
// container is not nil, container is Volume
// is method
func (v *VolumeIfc) GetActivationRoot() (result File) {
	iv, err := _I.Get(1571, "Volume", "get_activation_root")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_volume_get_drive
// container is not nil, container is Volume
// is method
func (v *VolumeIfc) GetDrive() (result Drive) {
	iv, err := _I.Get(1572, "Volume", "get_drive")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_volume_get_icon
// container is not nil, container is Volume
// is method
func (v *VolumeIfc) GetIcon() (result Icon) {
	iv, err := _I.Get(1573, "Volume", "get_icon")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_volume_get_identifier
// container is not nil, container is Volume
// is method
func (v *VolumeIfc) GetIdentifier(kind string) (result string) {
	iv, err := _I.Get(1574, "Volume", "get_identifier")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_kind := gi.CString(kind)
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_kind := gi.NewStringArgument(c_kind)
	args := []gi.Argument{arg_v, arg_kind}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_kind)
	result = ret.String().Take()
	return
}

// g_volume_get_mount
// container is not nil, container is Volume
// is method
func (v *VolumeIfc) GetMount() (result Mount) {
	iv, err := _I.Get(1575, "Volume", "get_mount")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_volume_get_name
// container is not nil, container is Volume
// is method
func (v *VolumeIfc) GetName() (result string) {
	iv, err := _I.Get(1576, "Volume", "get_name")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Take()
	return
}

// g_volume_get_sort_key
// container is not nil, container is Volume
// is method
func (v *VolumeIfc) GetSortKey() (result string) {
	iv, err := _I.Get(1577, "Volume", "get_sort_key")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Take()
	return
}

// g_volume_get_symbolic_icon
// container is not nil, container is Volume
// is method
func (v *VolumeIfc) GetSymbolicIcon() (result Icon) {
	iv, err := _I.Get(1578, "Volume", "get_symbolic_icon")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_volume_get_uuid
// container is not nil, container is Volume
// is method
func (v *VolumeIfc) GetUuid() (result string) {
	iv, err := _I.Get(1579, "Volume", "get_uuid")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Take()
	return
}

// g_volume_mount
// container is not nil, container is Volume
// is method
func (v *VolumeIfc) MountF(flags MountMountFlags, mount_operation IMountOperation, cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(1580, "Volume", "mount")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if mount_operation != nil {
		tmp = mount_operation.P_MountOperation()
	}
	var tmp1 unsafe.Pointer
	if cancellable != nil {
		tmp1 = cancellable.P_Cancellable()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_flags := gi.NewIntArgument(int(flags))
	arg_mount_operation := gi.NewPointerArgument(tmp)
	arg_cancellable := gi.NewPointerArgument(tmp1)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_v, arg_flags, arg_mount_operation, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
}

// g_volume_mount_finish
// container is not nil, container is Volume
// is method
func (v *VolumeIfc) MountFinish(result IAsyncResult) (result1 bool, err error) {
	iv, err := _I.Get(1581, "Volume", "mount_finish")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if result != nil {
		tmp = result.P_AsyncResult()
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	arg_result := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_v, arg_result, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result1 = ret.Bool()
	return
}

// g_volume_should_automount
// container is not nil, container is Volume
// is method
func (v *VolumeIfc) ShouldAutomount() (result bool) {
	iv, err := _I.Get(1582, "Volume", "should_automount")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(*(*unsafe.Pointer)(unsafe.Pointer(v)))
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// ignore GType struct VolumeIface
// Object VolumeMonitor
type VolumeMonitor struct {
	gobject.Object
}

func WrapVolumeMonitor(p unsafe.Pointer) (r VolumeMonitor) { r.P = p; return }

type IVolumeMonitor interface{ P_VolumeMonitor() unsafe.Pointer }

func (v VolumeMonitor) P_VolumeMonitor() unsafe.Pointer { return v.P }
func VolumeMonitorGetType() gi.GType {
	ret := _I.GetGType(311, "VolumeMonitor")
	return ret
}

// g_volume_monitor_adopt_orphan_mount
// container is not nil, container is VolumeMonitor
// is method
// arg0Type tag: interface, isPtr: true
func VolumeMonitorAdoptOrphanMount1(mount IMount) (result Volume) {
	iv, err := _I.Get(1583, "VolumeMonitor", "adopt_orphan_mount")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if mount != nil {
		tmp = mount.P_Mount()
	}
	arg_mount := gi.NewPointerArgument(tmp)
	args := []gi.Argument{arg_mount}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_volume_monitor_get_connected_drives
// container is not nil, container is VolumeMonitor
// is method
func (v VolumeMonitor) GetConnectedDrives() (result glib.List) {
	iv, err := _I.Get(1585, "VolumeMonitor", "get_connected_drives")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_volume_monitor_get_mount_for_uuid
// container is not nil, container is VolumeMonitor
// is method
func (v VolumeMonitor) GetMountForUuid(uuid string) (result Mount) {
	iv, err := _I.Get(1586, "VolumeMonitor", "get_mount_for_uuid")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_uuid := gi.CString(uuid)
	arg_v := gi.NewPointerArgument(v.P)
	arg_uuid := gi.NewStringArgument(c_uuid)
	args := []gi.Argument{arg_v, arg_uuid}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_uuid)
	result.P = ret.Pointer()
	return
}

// g_volume_monitor_get_mounts
// container is not nil, container is VolumeMonitor
// is method
func (v VolumeMonitor) GetMounts() (result glib.List) {
	iv, err := _I.Get(1587, "VolumeMonitor", "get_mounts")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_volume_monitor_get_volume_for_uuid
// container is not nil, container is VolumeMonitor
// is method
func (v VolumeMonitor) GetVolumeForUuid(uuid string) (result Volume) {
	iv, err := _I.Get(1588, "VolumeMonitor", "get_volume_for_uuid")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_uuid := gi.CString(uuid)
	arg_v := gi.NewPointerArgument(v.P)
	arg_uuid := gi.NewStringArgument(c_uuid)
	args := []gi.Argument{arg_v, arg_uuid}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_uuid)
	result.P = ret.Pointer()
	return
}

// g_volume_monitor_get_volumes
// container is not nil, container is VolumeMonitor
// is method
func (v VolumeMonitor) GetVolumes() (result glib.List) {
	iv, err := _I.Get(1589, "VolumeMonitor", "get_volumes")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// ignore GType struct VolumeMonitorClass
// Object ZlibCompressor
type ZlibCompressor struct {
	ConverterIfc
	gobject.Object
}

func WrapZlibCompressor(p unsafe.Pointer) (r ZlibCompressor) { r.P = p; return }

type IZlibCompressor interface{ P_ZlibCompressor() unsafe.Pointer }

func (v ZlibCompressor) P_ZlibCompressor() unsafe.Pointer { return v.P }
func (v ZlibCompressor) P_Converter() unsafe.Pointer      { return v.P }
func ZlibCompressorGetType() gi.GType {
	ret := _I.GetGType(312, "ZlibCompressor")
	return ret
}

// g_zlib_compressor_new
// container is not nil, container is ZlibCompressor
// is constructor
func NewZlibCompressor(format ZlibCompressorFormatEnum, level int32) (result ZlibCompressor) {
	iv, err := _I.Get(1590, "ZlibCompressor", "new")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_format := gi.NewIntArgument(int(format))
	arg_level := gi.NewInt32Argument(level)
	args := []gi.Argument{arg_format, arg_level}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_zlib_compressor_get_file_info
// container is not nil, container is ZlibCompressor
// is method
func (v ZlibCompressor) GetFileInfo() (result FileInfo) {
	iv, err := _I.Get(1591, "ZlibCompressor", "get_file_info")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_zlib_compressor_set_file_info
// container is not nil, container is ZlibCompressor
// is method
func (v ZlibCompressor) SetFileInfo(file_info IFileInfo) {
	iv, err := _I.Get(1592, "ZlibCompressor", "set_file_info")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if file_info != nil {
		tmp = file_info.P_FileInfo()
	}
	arg_v := gi.NewPointerArgument(v.P)
	arg_file_info := gi.NewPointerArgument(tmp)
	args := []gi.Argument{arg_v, arg_file_info}
	iv.Call(args, nil, nil)
}

// ignore GType struct ZlibCompressorClass
// Enum ZlibCompressorFormat
type ZlibCompressorFormatEnum int

const (
	ZlibCompressorFormatZlib ZlibCompressorFormatEnum = 0
	ZlibCompressorFormatGzip ZlibCompressorFormatEnum = 1
	ZlibCompressorFormatRaw  ZlibCompressorFormatEnum = 2
)

func ZlibCompressorFormatGetType() gi.GType {
	ret := _I.GetGType(313, "ZlibCompressorFormat")
	return ret
}

// Object ZlibDecompressor
type ZlibDecompressor struct {
	ConverterIfc
	gobject.Object
}

func WrapZlibDecompressor(p unsafe.Pointer) (r ZlibDecompressor) { r.P = p; return }

type IZlibDecompressor interface{ P_ZlibDecompressor() unsafe.Pointer }

func (v ZlibDecompressor) P_ZlibDecompressor() unsafe.Pointer { return v.P }
func (v ZlibDecompressor) P_Converter() unsafe.Pointer        { return v.P }
func ZlibDecompressorGetType() gi.GType {
	ret := _I.GetGType(314, "ZlibDecompressor")
	return ret
}

// g_zlib_decompressor_new
// container is not nil, container is ZlibDecompressor
// is constructor
func NewZlibDecompressor(format ZlibCompressorFormatEnum) (result ZlibDecompressor) {
	iv, err := _I.Get(1593, "ZlibDecompressor", "new")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_format := gi.NewIntArgument(int(format))
	args := []gi.Argument{arg_format}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_zlib_decompressor_get_file_info
// container is not nil, container is ZlibDecompressor
// is method
func (v ZlibDecompressor) GetFileInfo() (result FileInfo) {
	iv, err := _I.Get(1594, "ZlibDecompressor", "get_file_info")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_v := gi.NewPointerArgument(v.P)
	args := []gi.Argument{arg_v}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// ignore GType struct ZlibDecompressorClass
// g_action_name_is_valid
// container is nil
func ActionNameIsValid(action_name string) (result bool) {
	iv, err := _I.Get(1595, "action_name_is_valid", "")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_action_name := gi.CString(action_name)
	arg_action_name := gi.NewStringArgument(c_action_name)
	args := []gi.Argument{arg_action_name}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_action_name)
	result = ret.Bool()
	return
}

// g_action_parse_detailed_name
// container is nil
func ActionParseDetailedName(detailed_name string) (result bool, action_name string, target_value glib.Variant, err error) {
	iv, err := _I.Get(1596, "action_parse_detailed_name", "")
	if err != nil {
		return
	}
	var outArgs [3]gi.Argument
	c_detailed_name := gi.CString(detailed_name)
	arg_detailed_name := gi.NewStringArgument(c_detailed_name)
	arg_action_name := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	arg_target_value := gi.NewPointerArgument(unsafe.Pointer(&outArgs[1]))
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[2]))
	args := []gi.Argument{arg_detailed_name, arg_action_name, arg_target_value, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	gi.Free(c_detailed_name)
	err = gi.ToError(outArgs[2].Pointer())
	action_name = outArgs[0].String().Take()
	target_value.P = outArgs[1].Pointer()
	result = ret.Bool()
	return
}

// g_action_print_detailed_name
// container is nil
func ActionPrintDetailedName(action_name string, target_value glib.Variant) (result string) {
	iv, err := _I.Get(1597, "action_print_detailed_name", "")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_action_name := gi.CString(action_name)
	arg_action_name := gi.NewStringArgument(c_action_name)
	arg_target_value := gi.NewPointerArgument(target_value.P)
	args := []gi.Argument{arg_action_name, arg_target_value}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_action_name)
	result = ret.String().Take()
	return
}

// g_app_info_create_from_commandline
// container is nil
func AppInfoCreateFromCommandline(commandline string, application_name string, flags AppInfoCreateFlags) (result AppInfo, err error) {
	iv, err := _I.Get(1598, "app_info_create_from_commandline", "")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	c_commandline := gi.CString(commandline)
	c_application_name := gi.CString(application_name)
	arg_commandline := gi.NewStringArgument(c_commandline)
	arg_application_name := gi.NewStringArgument(c_application_name)
	arg_flags := gi.NewIntArgument(int(flags))
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_commandline, arg_application_name, arg_flags, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	gi.Free(c_commandline)
	gi.Free(c_application_name)
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// g_app_info_get_all
// container is nil
func AppInfoGetAll() (result glib.List) {
	iv, err := _I.Get(1599, "app_info_get_all", "")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var ret gi.Argument
	iv.Call(nil, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_app_info_get_all_for_type
// container is nil
func AppInfoGetAllForType(content_type string) (result glib.List) {
	iv, err := _I.Get(1600, "app_info_get_all_for_type", "")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_content_type := gi.CString(content_type)
	arg_content_type := gi.NewStringArgument(c_content_type)
	args := []gi.Argument{arg_content_type}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_content_type)
	result.P = ret.Pointer()
	return
}

// g_app_info_get_default_for_type
// container is nil
func AppInfoGetDefaultForType(content_type string, must_support_uris bool) (result AppInfo) {
	iv, err := _I.Get(1601, "app_info_get_default_for_type", "")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_content_type := gi.CString(content_type)
	arg_content_type := gi.NewStringArgument(c_content_type)
	arg_must_support_uris := gi.NewBoolArgument(must_support_uris)
	args := []gi.Argument{arg_content_type, arg_must_support_uris}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_content_type)
	result.P = ret.Pointer()
	return
}

// g_app_info_get_default_for_uri_scheme
// container is nil
func AppInfoGetDefaultForUriScheme(uri_scheme string) (result AppInfo) {
	iv, err := _I.Get(1602, "app_info_get_default_for_uri_scheme", "")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_uri_scheme := gi.CString(uri_scheme)
	arg_uri_scheme := gi.NewStringArgument(c_uri_scheme)
	args := []gi.Argument{arg_uri_scheme}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_uri_scheme)
	result.P = ret.Pointer()
	return
}

// g_app_info_get_fallback_for_type
// container is nil
func AppInfoGetFallbackForType(content_type string) (result glib.List) {
	iv, err := _I.Get(1603, "app_info_get_fallback_for_type", "")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_content_type := gi.CString(content_type)
	arg_content_type := gi.NewStringArgument(c_content_type)
	args := []gi.Argument{arg_content_type}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_content_type)
	result.P = ret.Pointer()
	return
}

// g_app_info_get_recommended_for_type
// container is nil
func AppInfoGetRecommendedForType(content_type string) (result glib.List) {
	iv, err := _I.Get(1604, "app_info_get_recommended_for_type", "")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_content_type := gi.CString(content_type)
	arg_content_type := gi.NewStringArgument(c_content_type)
	args := []gi.Argument{arg_content_type}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_content_type)
	result.P = ret.Pointer()
	return
}

// g_app_info_launch_default_for_uri
// container is nil
func AppInfoLaunchDefaultForUri(uri string, context IAppLaunchContext) (result bool, err error) {
	iv, err := _I.Get(1605, "app_info_launch_default_for_uri", "")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	c_uri := gi.CString(uri)
	var tmp unsafe.Pointer
	if context != nil {
		tmp = context.P_AppLaunchContext()
	}
	arg_uri := gi.NewStringArgument(c_uri)
	arg_context := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_uri, arg_context, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	gi.Free(c_uri)
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Bool()
	return
}

// g_app_info_launch_default_for_uri_async
// container is nil
func AppInfoLaunchDefaultForUriAsync(uri string, context IAppLaunchContext, cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(1606, "app_info_launch_default_for_uri_async", "")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_uri := gi.CString(uri)
	var tmp unsafe.Pointer
	if context != nil {
		tmp = context.P_AppLaunchContext()
	}
	var tmp1 unsafe.Pointer
	if cancellable != nil {
		tmp1 = cancellable.P_Cancellable()
	}
	arg_uri := gi.NewStringArgument(c_uri)
	arg_context := gi.NewPointerArgument(tmp)
	arg_cancellable := gi.NewPointerArgument(tmp1)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_uri, arg_context, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
	gi.Free(c_uri)
}

// g_app_info_launch_default_for_uri_finish
// container is nil
func AppInfoLaunchDefaultForUriFinish(result IAsyncResult) (result1 bool, err error) {
	iv, err := _I.Get(1607, "app_info_launch_default_for_uri_finish", "")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if result != nil {
		tmp = result.P_AsyncResult()
	}
	arg_result := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_result, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result1 = ret.Bool()
	return
}

// g_app_info_reset_type_associations
// container is nil
func AppInfoResetTypeAssociations(content_type string) {
	iv, err := _I.Get(1608, "app_info_reset_type_associations", "")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_content_type := gi.CString(content_type)
	arg_content_type := gi.NewStringArgument(c_content_type)
	args := []gi.Argument{arg_content_type}
	iv.Call(args, nil, nil)
	gi.Free(c_content_type)
}

// g_async_initable_newv_async
// container is nil
func AsyncInitableNewvAsync(object_type gi.GType, n_parameters uint32, parameters gobject.Parameter, io_priority int32, cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(1609, "async_initable_newv_async", "")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_object_type := gi.NewUintArgument(uint(object_type))
	arg_n_parameters := gi.NewUint32Argument(n_parameters)
	arg_parameters := gi.NewPointerArgument(parameters.P)
	arg_io_priority := gi.NewInt32Argument(io_priority)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_object_type, arg_n_parameters, arg_parameters, arg_io_priority, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
}

// g_bus_get
// container is nil
func BusGet(bus_type BusTypeEnum, cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(1610, "bus_get", "")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_bus_type := gi.NewIntArgument(int(bus_type))
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_bus_type, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
}

// g_bus_get_finish
// container is nil
func BusGetFinish(res IAsyncResult) (result DBusConnection, err error) {
	iv, err := _I.Get(1611, "bus_get_finish", "")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if res != nil {
		tmp = res.P_AsyncResult()
	}
	arg_res := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_res, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// g_bus_get_sync
// container is nil
func BusGetSync(bus_type BusTypeEnum, cancellable ICancellable) (result DBusConnection, err error) {
	iv, err := _I.Get(1612, "bus_get_sync", "")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_bus_type := gi.NewIntArgument(int(bus_type))
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_bus_type, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// g_bus_own_name_on_connection_with_closures
// container is nil
func BusOwnNameOnConnection(connection IDBusConnection, name string, flags BusNameOwnerFlags, name_acquired_closure gobject.Closure, name_lost_closure gobject.Closure) (result uint32) {
	iv, err := _I.Get(1613, "bus_own_name_on_connection", "")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if connection != nil {
		tmp = connection.P_DBusConnection()
	}
	c_name := gi.CString(name)
	arg_connection := gi.NewPointerArgument(tmp)
	arg_name := gi.NewStringArgument(c_name)
	arg_flags := gi.NewIntArgument(int(flags))
	arg_name_acquired_closure := gi.NewPointerArgument(name_acquired_closure.P)
	arg_name_lost_closure := gi.NewPointerArgument(name_lost_closure.P)
	args := []gi.Argument{arg_connection, arg_name, arg_flags, arg_name_acquired_closure, arg_name_lost_closure}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_name)
	result = ret.Uint32()
	return
}

// g_bus_own_name_with_closures
// container is nil
func BusOwnName(bus_type BusTypeEnum, name string, flags BusNameOwnerFlags, bus_acquired_closure gobject.Closure, name_acquired_closure gobject.Closure, name_lost_closure gobject.Closure) (result uint32) {
	iv, err := _I.Get(1614, "bus_own_name", "")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_name := gi.CString(name)
	arg_bus_type := gi.NewIntArgument(int(bus_type))
	arg_name := gi.NewStringArgument(c_name)
	arg_flags := gi.NewIntArgument(int(flags))
	arg_bus_acquired_closure := gi.NewPointerArgument(bus_acquired_closure.P)
	arg_name_acquired_closure := gi.NewPointerArgument(name_acquired_closure.P)
	arg_name_lost_closure := gi.NewPointerArgument(name_lost_closure.P)
	args := []gi.Argument{arg_bus_type, arg_name, arg_flags, arg_bus_acquired_closure, arg_name_acquired_closure, arg_name_lost_closure}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_name)
	result = ret.Uint32()
	return
}

// g_bus_unown_name
// container is nil
func BusUnownName(owner_id uint32) {
	iv, err := _I.Get(1615, "bus_unown_name", "")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_owner_id := gi.NewUint32Argument(owner_id)
	args := []gi.Argument{arg_owner_id}
	iv.Call(args, nil, nil)
}

// g_bus_unwatch_name
// container is nil
func BusUnwatchName(watcher_id uint32) {
	iv, err := _I.Get(1616, "bus_unwatch_name", "")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_watcher_id := gi.NewUint32Argument(watcher_id)
	args := []gi.Argument{arg_watcher_id}
	iv.Call(args, nil, nil)
}

// g_bus_watch_name_on_connection_with_closures
// container is nil
func BusWatchNameOnConnection(connection IDBusConnection, name string, flags BusNameWatcherFlags, name_appeared_closure gobject.Closure, name_vanished_closure gobject.Closure) (result uint32) {
	iv, err := _I.Get(1617, "bus_watch_name_on_connection", "")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if connection != nil {
		tmp = connection.P_DBusConnection()
	}
	c_name := gi.CString(name)
	arg_connection := gi.NewPointerArgument(tmp)
	arg_name := gi.NewStringArgument(c_name)
	arg_flags := gi.NewIntArgument(int(flags))
	arg_name_appeared_closure := gi.NewPointerArgument(name_appeared_closure.P)
	arg_name_vanished_closure := gi.NewPointerArgument(name_vanished_closure.P)
	args := []gi.Argument{arg_connection, arg_name, arg_flags, arg_name_appeared_closure, arg_name_vanished_closure}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_name)
	result = ret.Uint32()
	return
}

// g_bus_watch_name_with_closures
// container is nil
func BusWatchName(bus_type BusTypeEnum, name string, flags BusNameWatcherFlags, name_appeared_closure gobject.Closure, name_vanished_closure gobject.Closure) (result uint32) {
	iv, err := _I.Get(1618, "bus_watch_name", "")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_name := gi.CString(name)
	arg_bus_type := gi.NewIntArgument(int(bus_type))
	arg_name := gi.NewStringArgument(c_name)
	arg_flags := gi.NewIntArgument(int(flags))
	arg_name_appeared_closure := gi.NewPointerArgument(name_appeared_closure.P)
	arg_name_vanished_closure := gi.NewPointerArgument(name_vanished_closure.P)
	args := []gi.Argument{arg_bus_type, arg_name, arg_flags, arg_name_appeared_closure, arg_name_vanished_closure}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_name)
	result = ret.Uint32()
	return
}

// g_content_type_can_be_executable
// container is nil
func ContentTypeCanBeExecutable(type1 string) (result bool) {
	iv, err := _I.Get(1619, "content_type_can_be_executable", "")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_type1 := gi.CString(type1)
	arg_type1 := gi.NewStringArgument(c_type1)
	args := []gi.Argument{arg_type1}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_type1)
	result = ret.Bool()
	return
}

// g_content_type_equals
// container is nil
func ContentTypeEquals(type1 string, type2 string) (result bool) {
	iv, err := _I.Get(1620, "content_type_equals", "")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_type1 := gi.CString(type1)
	c_type2 := gi.CString(type2)
	arg_type1 := gi.NewStringArgument(c_type1)
	arg_type2 := gi.NewStringArgument(c_type2)
	args := []gi.Argument{arg_type1, arg_type2}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_type1)
	gi.Free(c_type2)
	result = ret.Bool()
	return
}

// g_content_type_from_mime_type
// container is nil
func ContentTypeFromMimeType(mime_type string) (result string) {
	iv, err := _I.Get(1621, "content_type_from_mime_type", "")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_mime_type := gi.CString(mime_type)
	arg_mime_type := gi.NewStringArgument(c_mime_type)
	args := []gi.Argument{arg_mime_type}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_mime_type)
	result = ret.String().Take()
	return
}

// g_content_type_get_description
// container is nil
func ContentTypeGetDescription(type1 string) (result string) {
	iv, err := _I.Get(1622, "content_type_get_description", "")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_type1 := gi.CString(type1)
	arg_type1 := gi.NewStringArgument(c_type1)
	args := []gi.Argument{arg_type1}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_type1)
	result = ret.String().Take()
	return
}

// g_content_type_get_generic_icon_name
// container is nil
func ContentTypeGetGenericIconName(type1 string) (result string) {
	iv, err := _I.Get(1623, "content_type_get_generic_icon_name", "")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_type1 := gi.CString(type1)
	arg_type1 := gi.NewStringArgument(c_type1)
	args := []gi.Argument{arg_type1}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_type1)
	result = ret.String().Take()
	return
}

// g_content_type_get_icon
// container is nil
func ContentTypeGetIcon(type1 string) (result Icon) {
	iv, err := _I.Get(1624, "content_type_get_icon", "")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_type1 := gi.CString(type1)
	arg_type1 := gi.NewStringArgument(c_type1)
	args := []gi.Argument{arg_type1}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_type1)
	result.P = ret.Pointer()
	return
}

// g_content_type_get_mime_type
// container is nil
func ContentTypeGetMimeType(type1 string) (result string) {
	iv, err := _I.Get(1625, "content_type_get_mime_type", "")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_type1 := gi.CString(type1)
	arg_type1 := gi.NewStringArgument(c_type1)
	args := []gi.Argument{arg_type1}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_type1)
	result = ret.String().Take()
	return
}

// g_content_type_get_symbolic_icon
// container is nil
func ContentTypeGetSymbolicIcon(type1 string) (result Icon) {
	iv, err := _I.Get(1626, "content_type_get_symbolic_icon", "")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_type1 := gi.CString(type1)
	arg_type1 := gi.NewStringArgument(c_type1)
	args := []gi.Argument{arg_type1}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_type1)
	result.P = ret.Pointer()
	return
}

// g_content_type_guess
// container is nil
// arg 1 data lenArgIdx 2
func ContentTypeGuess(filename string, data gi.Uint8Array, data_size uint64) (result string, result_uncertain bool) {
	iv, err := _I.Get(1627, "content_type_guess", "")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var outArgs [1]gi.Argument
	c_filename := gi.CString(filename)
	arg_filename := gi.NewStringArgument(c_filename)
	arg_data := gi.NewPointerArgument(data.P)
	arg_data_size := gi.NewUint64Argument(data_size)
	arg_result_uncertain := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_filename, arg_data, arg_data_size, arg_result_uncertain}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	gi.Free(c_filename)
	result_uncertain = outArgs[0].Bool()
	result = ret.String().Take()
	return
}

// g_content_type_guess_for_tree
// container is nil
func ContentTypeGuessForTree(root IFile) (result gi.CStrArray) {
	iv, err := _I.Get(1628, "content_type_guess_for_tree", "")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if root != nil {
		tmp = root.P_File()
	}
	arg_root := gi.NewPointerArgument(tmp)
	args := []gi.Argument{arg_root}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = gi.CStrArray{P: ret.Pointer(), Len: -1}
	result.SetLenZT()
	return
}

// g_content_type_is_a
// container is nil
func ContentTypeIsA(type1 string, supertype string) (result bool) {
	iv, err := _I.Get(1629, "content_type_is_a", "")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_type1 := gi.CString(type1)
	c_supertype := gi.CString(supertype)
	arg_type1 := gi.NewStringArgument(c_type1)
	arg_supertype := gi.NewStringArgument(c_supertype)
	args := []gi.Argument{arg_type1, arg_supertype}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_type1)
	gi.Free(c_supertype)
	result = ret.Bool()
	return
}

// g_content_type_is_mime_type
// container is nil
func ContentTypeIsMimeType(type1 string, mime_type string) (result bool) {
	iv, err := _I.Get(1630, "content_type_is_mime_type", "")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_type1 := gi.CString(type1)
	c_mime_type := gi.CString(mime_type)
	arg_type1 := gi.NewStringArgument(c_type1)
	arg_mime_type := gi.NewStringArgument(c_mime_type)
	args := []gi.Argument{arg_type1, arg_mime_type}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_type1)
	gi.Free(c_mime_type)
	result = ret.Bool()
	return
}

// g_content_type_is_unknown
// container is nil
func ContentTypeIsUnknown(type1 string) (result bool) {
	iv, err := _I.Get(1631, "content_type_is_unknown", "")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_type1 := gi.CString(type1)
	arg_type1 := gi.NewStringArgument(c_type1)
	args := []gi.Argument{arg_type1}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_type1)
	result = ret.Bool()
	return
}

// g_content_types_get_registered
// container is nil
func ContentTypesGetRegistered() (result glib.List) {
	iv, err := _I.Get(1632, "content_types_get_registered", "")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var ret gi.Argument
	iv.Call(nil, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_dbus_address_escape_value
// container is nil
func DbusAddressEscapeValue(string string) (result string) {
	iv, err := _I.Get(1633, "dbus_address_escape_value", "")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_string := gi.CString(string)
	arg_string := gi.NewStringArgument(c_string)
	args := []gi.Argument{arg_string}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_string)
	result = ret.String().Take()
	return
}

// g_dbus_address_get_for_bus_sync
// container is nil
func DbusAddressGetForBusSync(bus_type BusTypeEnum, cancellable ICancellable) (result string, err error) {
	iv, err := _I.Get(1634, "dbus_address_get_for_bus_sync", "")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_bus_type := gi.NewIntArgument(int(bus_type))
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_bus_type, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.String().Take()
	return
}

// g_dbus_address_get_stream
// container is nil
func DbusAddressGetStream(address string, cancellable ICancellable, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer) {
	iv, err := _I.Get(1635, "dbus_address_get_stream", "")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_address := gi.CString(address)
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_address := gi.NewStringArgument(c_address)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	args := []gi.Argument{arg_address, arg_cancellable, arg_callback, arg_user_data}
	iv.Call(args, nil, nil)
	gi.Free(c_address)
}

// g_dbus_address_get_stream_finish
// container is nil
func DbusAddressGetStreamFinish(res IAsyncResult) (result IOStream, out_guid string, err error) {
	iv, err := _I.Get(1636, "dbus_address_get_stream_finish", "")
	if err != nil {
		return
	}
	var outArgs [2]gi.Argument
	var tmp unsafe.Pointer
	if res != nil {
		tmp = res.P_AsyncResult()
	}
	arg_res := gi.NewPointerArgument(tmp)
	arg_out_guid := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[1]))
	args := []gi.Argument{arg_res, arg_out_guid, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[1].Pointer())
	out_guid = outArgs[0].String().Take()
	result.P = ret.Pointer()
	return
}

// g_dbus_address_get_stream_sync
// container is nil
func DbusAddressGetStreamSync(address string, cancellable ICancellable) (result IOStream, out_guid string, err error) {
	iv, err := _I.Get(1637, "dbus_address_get_stream_sync", "")
	if err != nil {
		return
	}
	var outArgs [2]gi.Argument
	c_address := gi.CString(address)
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_address := gi.NewStringArgument(c_address)
	arg_out_guid := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[1]))
	args := []gi.Argument{arg_address, arg_out_guid, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	gi.Free(c_address)
	err = gi.ToError(outArgs[1].Pointer())
	out_guid = outArgs[0].String().Take()
	result.P = ret.Pointer()
	return
}

// g_dbus_annotation_info_lookup
// container is nil
func DbusAnnotationInfoLookup(annotations gi.PointerArray, name string) (result string) {
	iv, err := _I.Get(1638, "dbus_annotation_info_lookup", "")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_name := gi.CString(name)
	arg_annotations := gi.NewPointerArgument(annotations.P)
	arg_name := gi.NewStringArgument(c_name)
	args := []gi.Argument{arg_annotations, arg_name}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_name)
	result = ret.String().Take()
	return
}

// g_dbus_error_encode_gerror
// container is nil
func DbusErrorEncodeGerror(error glib.Error) (result string) {
	iv, err := _I.Get(1639, "dbus_error_encode_gerror", "")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_error := gi.NewPointerArgument(error.P)
	args := []gi.Argument{arg_error}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Take()
	return
}

// g_dbus_error_get_remote_error
// container is nil
func DbusErrorGetRemoteError(error glib.Error) (result string) {
	iv, err := _I.Get(1640, "dbus_error_get_remote_error", "")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_error := gi.NewPointerArgument(error.P)
	args := []gi.Argument{arg_error}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Take()
	return
}

// g_dbus_error_is_remote_error
// container is nil
func DbusErrorIsRemoteError(error glib.Error) (result bool) {
	iv, err := _I.Get(1641, "dbus_error_is_remote_error", "")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_error := gi.NewPointerArgument(error.P)
	args := []gi.Argument{arg_error}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_dbus_error_new_for_dbus_error
// container is nil
func DbusErrorNewForDbusError(dbus_error_name string, dbus_error_message string) (result glib.Error) {
	iv, err := _I.Get(1642, "dbus_error_new_for_dbus_error", "")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_dbus_error_name := gi.CString(dbus_error_name)
	c_dbus_error_message := gi.CString(dbus_error_message)
	arg_dbus_error_name := gi.NewStringArgument(c_dbus_error_name)
	arg_dbus_error_message := gi.NewStringArgument(c_dbus_error_message)
	args := []gi.Argument{arg_dbus_error_name, arg_dbus_error_message}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_dbus_error_name)
	gi.Free(c_dbus_error_message)
	result.P = ret.Pointer()
	return
}

// g_dbus_error_quark
// container is nil
func DbusErrorQuark() (result uint32) {
	iv, err := _I.Get(1643, "dbus_error_quark", "")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var ret gi.Argument
	iv.Call(nil, &ret, nil)
	result = ret.Uint32()
	return
}

// g_dbus_error_register_error
// container is nil
func DbusErrorRegisterError(error_domain uint32, error_code int32, dbus_error_name string) (result bool) {
	iv, err := _I.Get(1644, "dbus_error_register_error", "")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_dbus_error_name := gi.CString(dbus_error_name)
	arg_error_domain := gi.NewUint32Argument(error_domain)
	arg_error_code := gi.NewInt32Argument(error_code)
	arg_dbus_error_name := gi.NewStringArgument(c_dbus_error_name)
	args := []gi.Argument{arg_error_domain, arg_error_code, arg_dbus_error_name}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_dbus_error_name)
	result = ret.Bool()
	return
}

// g_dbus_error_register_error_domain
// container is nil
// arg 2 entries lenArgIdx 3
func DbusErrorRegisterErrorDomain(error_domain_quark_name string, quark_volatile uint64, entries unsafe.Pointer, num_entries uint32) {
	iv, err := _I.Get(1645, "dbus_error_register_error_domain", "")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_error_domain_quark_name := gi.CString(error_domain_quark_name)
	arg_error_domain_quark_name := gi.NewStringArgument(c_error_domain_quark_name)
	arg_quark_volatile := gi.NewUint64Argument(quark_volatile)
	arg_entries := gi.NewPointerArgument(entries)
	arg_num_entries := gi.NewUint32Argument(num_entries)
	args := []gi.Argument{arg_error_domain_quark_name, arg_quark_volatile, arg_entries, arg_num_entries}
	iv.Call(args, nil, nil)
	gi.Free(c_error_domain_quark_name)
}

// g_dbus_error_strip_remote_error
// container is nil
func DbusErrorStripRemoteError(error glib.Error) (result bool) {
	iv, err := _I.Get(1646, "dbus_error_strip_remote_error", "")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_error := gi.NewPointerArgument(error.P)
	args := []gi.Argument{arg_error}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_dbus_error_unregister_error
// container is nil
func DbusErrorUnregisterError(error_domain uint32, error_code int32, dbus_error_name string) (result bool) {
	iv, err := _I.Get(1647, "dbus_error_unregister_error", "")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_dbus_error_name := gi.CString(dbus_error_name)
	arg_error_domain := gi.NewUint32Argument(error_domain)
	arg_error_code := gi.NewInt32Argument(error_code)
	arg_dbus_error_name := gi.NewStringArgument(c_dbus_error_name)
	args := []gi.Argument{arg_error_domain, arg_error_code, arg_dbus_error_name}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_dbus_error_name)
	result = ret.Bool()
	return
}

// g_dbus_generate_guid
// container is nil
func DbusGenerateGuid() (result string) {
	iv, err := _I.Get(1648, "dbus_generate_guid", "")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var ret gi.Argument
	iv.Call(nil, &ret, nil)
	result = ret.String().Take()
	return
}

// g_dbus_gvalue_to_gvariant
// container is nil
func DbusGvalueToGvariant(gvalue gobject.Value, type1 glib.VariantType) (result glib.Variant) {
	iv, err := _I.Get(1649, "dbus_gvalue_to_gvariant", "")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_gvalue := gi.NewPointerArgument(gvalue.P)
	arg_type1 := gi.NewPointerArgument(type1.P)
	args := []gi.Argument{arg_gvalue, arg_type1}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_dbus_gvariant_to_gvalue
// container is nil
func DbusGvariantToGvalue(value glib.Variant, out_gvalue gobject.Value) {
	iv, err := _I.Get(1650, "dbus_gvariant_to_gvalue", "")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_value := gi.NewPointerArgument(value.P)
	arg_out_gvalue := gi.NewPointerArgument(out_gvalue.P)
	args := []gi.Argument{arg_value, arg_out_gvalue}
	iv.Call(args, nil, nil)
}

// g_dbus_is_address
// container is nil
func DbusIsAddress(string string) (result bool) {
	iv, err := _I.Get(1651, "dbus_is_address", "")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_string := gi.CString(string)
	arg_string := gi.NewStringArgument(c_string)
	args := []gi.Argument{arg_string}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_string)
	result = ret.Bool()
	return
}

// g_dbus_is_guid
// container is nil
func DbusIsGuid(string string) (result bool) {
	iv, err := _I.Get(1652, "dbus_is_guid", "")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_string := gi.CString(string)
	arg_string := gi.NewStringArgument(c_string)
	args := []gi.Argument{arg_string}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_string)
	result = ret.Bool()
	return
}

// g_dbus_is_interface_name
// container is nil
func DbusIsInterfaceName(string string) (result bool) {
	iv, err := _I.Get(1653, "dbus_is_interface_name", "")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_string := gi.CString(string)
	arg_string := gi.NewStringArgument(c_string)
	args := []gi.Argument{arg_string}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_string)
	result = ret.Bool()
	return
}

// g_dbus_is_member_name
// container is nil
func DbusIsMemberName(string string) (result bool) {
	iv, err := _I.Get(1654, "dbus_is_member_name", "")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_string := gi.CString(string)
	arg_string := gi.NewStringArgument(c_string)
	args := []gi.Argument{arg_string}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_string)
	result = ret.Bool()
	return
}

// g_dbus_is_name
// container is nil
func DbusIsName(string string) (result bool) {
	iv, err := _I.Get(1655, "dbus_is_name", "")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_string := gi.CString(string)
	arg_string := gi.NewStringArgument(c_string)
	args := []gi.Argument{arg_string}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_string)
	result = ret.Bool()
	return
}

// g_dbus_is_supported_address
// container is nil
func DbusIsSupportedAddress(string string) (result bool, err error) {
	iv, err := _I.Get(1656, "dbus_is_supported_address", "")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	c_string := gi.CString(string)
	arg_string := gi.NewStringArgument(c_string)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_string, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	gi.Free(c_string)
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Bool()
	return
}

// g_dbus_is_unique_name
// container is nil
func DbusIsUniqueName(string string) (result bool) {
	iv, err := _I.Get(1657, "dbus_is_unique_name", "")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_string := gi.CString(string)
	arg_string := gi.NewStringArgument(c_string)
	args := []gi.Argument{arg_string}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_string)
	result = ret.Bool()
	return
}

// g_dtls_client_connection_new
// container is nil
func DtlsClientConnectionNew(base_socket IDatagramBased, server_identity ISocketConnectable) (result DtlsClientConnection, err error) {
	iv, err := _I.Get(1658, "dtls_client_connection_new", "")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if base_socket != nil {
		tmp = base_socket.P_DatagramBased()
	}
	var tmp1 unsafe.Pointer
	if server_identity != nil {
		tmp1 = server_identity.P_SocketConnectable()
	}
	arg_base_socket := gi.NewPointerArgument(tmp)
	arg_server_identity := gi.NewPointerArgument(tmp1)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_base_socket, arg_server_identity, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// g_dtls_server_connection_new
// container is nil
func DtlsServerConnectionNew(base_socket IDatagramBased, certificate ITlsCertificate) (result DtlsServerConnection, err error) {
	iv, err := _I.Get(1659, "dtls_server_connection_new", "")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if base_socket != nil {
		tmp = base_socket.P_DatagramBased()
	}
	var tmp1 unsafe.Pointer
	if certificate != nil {
		tmp1 = certificate.P_TlsCertificate()
	}
	arg_base_socket := gi.NewPointerArgument(tmp)
	arg_certificate := gi.NewPointerArgument(tmp1)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_base_socket, arg_certificate, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// g_file_new_for_commandline_arg
// container is nil
func FileNewForCommandlineArg(arg string) (result File) {
	iv, err := _I.Get(1660, "file_new_for_commandline_arg", "")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_arg := gi.CString(arg)
	arg_arg := gi.NewStringArgument(c_arg)
	args := []gi.Argument{arg_arg}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_arg)
	result.P = ret.Pointer()
	return
}

// g_file_new_for_commandline_arg_and_cwd
// container is nil
func FileNewForCommandlineArgAndCwd(arg string, cwd string) (result File) {
	iv, err := _I.Get(1661, "file_new_for_commandline_arg_and_cwd", "")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_arg := gi.CString(arg)
	c_cwd := gi.CString(cwd)
	arg_arg := gi.NewStringArgument(c_arg)
	arg_cwd := gi.NewStringArgument(c_cwd)
	args := []gi.Argument{arg_arg, arg_cwd}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_arg)
	gi.Free(c_cwd)
	result.P = ret.Pointer()
	return
}

// g_file_new_for_path
// container is nil
func FileNewForPath(path string) (result File) {
	iv, err := _I.Get(1662, "file_new_for_path", "")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_path := gi.CString(path)
	arg_path := gi.NewStringArgument(c_path)
	args := []gi.Argument{arg_path}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_path)
	result.P = ret.Pointer()
	return
}

// g_file_new_for_uri
// container is nil
func FileNewForUri(uri string) (result File) {
	iv, err := _I.Get(1663, "file_new_for_uri", "")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_uri := gi.CString(uri)
	arg_uri := gi.NewStringArgument(c_uri)
	args := []gi.Argument{arg_uri}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_uri)
	result.P = ret.Pointer()
	return
}

// g_file_new_tmp
// container is nil
func FileNewTmp(tmpl string) (result File, iostream FileIOStream, err error) {
	iv, err := _I.Get(1664, "file_new_tmp", "")
	if err != nil {
		return
	}
	var outArgs [2]gi.Argument
	c_tmpl := gi.CString(tmpl)
	arg_tmpl := gi.NewStringArgument(c_tmpl)
	arg_iostream := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[1]))
	args := []gi.Argument{arg_tmpl, arg_iostream, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	gi.Free(c_tmpl)
	err = gi.ToError(outArgs[1].Pointer())
	iostream.P = outArgs[0].Pointer()
	result.P = ret.Pointer()
	return
}

// g_file_parse_name
// container is nil
func FileParseName(parse_name string) (result File) {
	iv, err := _I.Get(1665, "file_parse_name", "")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_parse_name := gi.CString(parse_name)
	arg_parse_name := gi.NewStringArgument(c_parse_name)
	args := []gi.Argument{arg_parse_name}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_parse_name)
	result.P = ret.Pointer()
	return
}

// g_icon_deserialize
// container is nil
func IconDeserialize(value glib.Variant) (result Icon) {
	iv, err := _I.Get(1666, "icon_deserialize", "")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_value := gi.NewPointerArgument(value.P)
	args := []gi.Argument{arg_value}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_icon_hash
// container is nil
func IconHash(icon unsafe.Pointer) (result uint32) {
	iv, err := _I.Get(1667, "icon_hash", "")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_icon := gi.NewPointerArgument(icon)
	args := []gi.Argument{arg_icon}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Uint32()
	return
}

// g_icon_new_for_string
// container is nil
func IconNewForString(str string) (result Icon, err error) {
	iv, err := _I.Get(1668, "icon_new_for_string", "")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	c_str := gi.CString(str)
	arg_str := gi.NewStringArgument(c_str)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_str, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	gi.Free(c_str)
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// g_initable_newv
// container is nil
// arg 2 parameters lenArgIdx 1
func InitableNewv(object_type gi.GType, n_parameters uint32, parameters unsafe.Pointer, cancellable ICancellable) (result gobject.Object, err error) {
	iv, err := _I.Get(1669, "initable_newv", "")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_object_type := gi.NewUintArgument(uint(object_type))
	arg_n_parameters := gi.NewUint32Argument(n_parameters)
	arg_parameters := gi.NewPointerArgument(parameters)
	arg_cancellable := gi.NewPointerArgument(tmp)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_object_type, arg_n_parameters, arg_parameters, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// g_io_error_from_errno
// container is nil
func IoErrorFromErrno(err_no int32) (result IOErrorEnumEnum) {
	iv, err := _I.Get(1670, "io_error_from_errno", "")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_err_no := gi.NewInt32Argument(err_no)
	args := []gi.Argument{arg_err_no}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = IOErrorEnumEnum(ret.Int())
	return
}

// g_io_error_quark
// container is nil
func IoErrorQuark() (result uint32) {
	iv, err := _I.Get(1671, "io_error_quark", "")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var ret gi.Argument
	iv.Call(nil, &ret, nil)
	result = ret.Uint32()
	return
}

// g_io_extension_point_implement
// container is nil
func IoExtensionPointImplement(extension_point_name string, type1 gi.GType, extension_name string, priority int32) (result IOExtension) {
	iv, err := _I.Get(1672, "io_extension_point_implement", "")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_extension_point_name := gi.CString(extension_point_name)
	c_extension_name := gi.CString(extension_name)
	arg_extension_point_name := gi.NewStringArgument(c_extension_point_name)
	arg_type1 := gi.NewUintArgument(uint(type1))
	arg_extension_name := gi.NewStringArgument(c_extension_name)
	arg_priority := gi.NewInt32Argument(priority)
	args := []gi.Argument{arg_extension_point_name, arg_type1, arg_extension_name, arg_priority}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_extension_point_name)
	gi.Free(c_extension_name)
	result.P = ret.Pointer()
	return
}

// g_io_extension_point_lookup
// container is nil
func IoExtensionPointLookup(name string) (result IOExtensionPoint) {
	iv, err := _I.Get(1673, "io_extension_point_lookup", "")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_name := gi.CString(name)
	arg_name := gi.NewStringArgument(c_name)
	args := []gi.Argument{arg_name}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_name)
	result.P = ret.Pointer()
	return
}

// g_io_extension_point_register
// container is nil
func IoExtensionPointRegister(name string) (result IOExtensionPoint) {
	iv, err := _I.Get(1674, "io_extension_point_register", "")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_name := gi.CString(name)
	arg_name := gi.NewStringArgument(c_name)
	args := []gi.Argument{arg_name}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_name)
	result.P = ret.Pointer()
	return
}

// g_io_modules_load_all_in_directory
// container is nil
func IoModulesLoadAllInDirectory(dirname string) (result glib.List) {
	iv, err := _I.Get(1675, "io_modules_load_all_in_directory", "")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_dirname := gi.CString(dirname)
	arg_dirname := gi.NewStringArgument(c_dirname)
	args := []gi.Argument{arg_dirname}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_dirname)
	result.P = ret.Pointer()
	return
}

// g_io_modules_load_all_in_directory_with_scope
// container is nil
func IoModulesLoadAllInDirectoryWithScope(dirname string, scope IOModuleScope) (result glib.List) {
	iv, err := _I.Get(1676, "io_modules_load_all_in_directory_with_scope", "")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_dirname := gi.CString(dirname)
	arg_dirname := gi.NewStringArgument(c_dirname)
	arg_scope := gi.NewPointerArgument(scope.P)
	args := []gi.Argument{arg_dirname, arg_scope}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_dirname)
	result.P = ret.Pointer()
	return
}

// g_io_modules_scan_all_in_directory
// container is nil
func IoModulesScanAllInDirectory(dirname string) {
	iv, err := _I.Get(1677, "io_modules_scan_all_in_directory", "")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_dirname := gi.CString(dirname)
	arg_dirname := gi.NewStringArgument(c_dirname)
	args := []gi.Argument{arg_dirname}
	iv.Call(args, nil, nil)
	gi.Free(c_dirname)
}

// g_io_modules_scan_all_in_directory_with_scope
// container is nil
func IoModulesScanAllInDirectoryWithScope(dirname string, scope IOModuleScope) {
	iv, err := _I.Get(1678, "io_modules_scan_all_in_directory_with_scope", "")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_dirname := gi.CString(dirname)
	arg_dirname := gi.NewStringArgument(c_dirname)
	arg_scope := gi.NewPointerArgument(scope.P)
	args := []gi.Argument{arg_dirname, arg_scope}
	iv.Call(args, nil, nil)
	gi.Free(c_dirname)
}

// g_io_scheduler_cancel_all_jobs
// container is nil
func IoSchedulerCancelAllJobs() {
	iv, err := _I.Get(1679, "io_scheduler_cancel_all_jobs", "")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	iv.Call(nil, nil, nil)
}

// g_io_scheduler_push_job
// container is nil
func IoSchedulerPushJob(job_func int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer, notify int /*TODO_TYPE isPtr: false, tag: interface*/, io_priority int32, cancellable ICancellable) {
	iv, err := _I.Get(1680, "io_scheduler_push_job", "")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if cancellable != nil {
		tmp = cancellable.P_Cancellable()
	}
	arg_job_func := gi.NewIntArgument(job_func) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	arg_notify := gi.NewIntArgument(notify) /*TODO*/
	arg_io_priority := gi.NewInt32Argument(io_priority)
	arg_cancellable := gi.NewPointerArgument(tmp)
	args := []gi.Argument{arg_job_func, arg_user_data, arg_notify, arg_io_priority, arg_cancellable}
	iv.Call(args, nil, nil)
}

// g_keyfile_settings_backend_new
// container is nil
func KeyfileSettingsBackendNew(filename string, root_path string, root_group string) (result SettingsBackend) {
	iv, err := _I.Get(1681, "keyfile_settings_backend_new", "")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_filename := gi.CString(filename)
	c_root_path := gi.CString(root_path)
	c_root_group := gi.CString(root_group)
	arg_filename := gi.NewStringArgument(c_filename)
	arg_root_path := gi.NewStringArgument(c_root_path)
	arg_root_group := gi.NewStringArgument(c_root_group)
	args := []gi.Argument{arg_filename, arg_root_path, arg_root_group}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_filename)
	gi.Free(c_root_path)
	gi.Free(c_root_group)
	result.P = ret.Pointer()
	return
}

// g_memory_settings_backend_new
// container is nil
func MemorySettingsBackendNew() (result SettingsBackend) {
	iv, err := _I.Get(1682, "memory_settings_backend_new", "")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var ret gi.Argument
	iv.Call(nil, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_network_monitor_get_default
// container is nil
func NetworkMonitorGetDefault() (result NetworkMonitor) {
	iv, err := _I.Get(1683, "network_monitor_get_default", "")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var ret gi.Argument
	iv.Call(nil, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_networking_init
// container is nil
func NetworkingInit() {
	iv, err := _I.Get(1684, "networking_init", "")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	iv.Call(nil, nil, nil)
}

// g_null_settings_backend_new
// container is nil
func NullSettingsBackendNew() (result SettingsBackend) {
	iv, err := _I.Get(1685, "null_settings_backend_new", "")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var ret gi.Argument
	iv.Call(nil, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_pollable_source_new
// container is nil
func PollableSourceNew(pollable_stream gobject.IObject) (result glib.Source) {
	iv, err := _I.Get(1686, "pollable_source_new", "")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if pollable_stream != nil {
		tmp = pollable_stream.P_Object()
	}
	arg_pollable_stream := gi.NewPointerArgument(tmp)
	args := []gi.Argument{arg_pollable_stream}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_pollable_source_new_full
// container is nil
func PollableSourceNewFull(pollable_stream gobject.IObject, child_source glib.Source, cancellable ICancellable) (result glib.Source) {
	iv, err := _I.Get(1687, "pollable_source_new_full", "")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if pollable_stream != nil {
		tmp = pollable_stream.P_Object()
	}
	var tmp1 unsafe.Pointer
	if cancellable != nil {
		tmp1 = cancellable.P_Cancellable()
	}
	arg_pollable_stream := gi.NewPointerArgument(tmp)
	arg_child_source := gi.NewPointerArgument(child_source.P)
	arg_cancellable := gi.NewPointerArgument(tmp1)
	args := []gi.Argument{arg_pollable_stream, arg_child_source, arg_cancellable}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_pollable_stream_read
// container is nil
// arg 1 buffer lenArgIdx 2
func PollableStreamRead(stream IInputStream, buffer gi.Uint8Array, count uint64, blocking bool, cancellable ICancellable) (result int64, err error) {
	iv, err := _I.Get(1688, "pollable_stream_read", "")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if stream != nil {
		tmp = stream.P_InputStream()
	}
	var tmp1 unsafe.Pointer
	if cancellable != nil {
		tmp1 = cancellable.P_Cancellable()
	}
	arg_stream := gi.NewPointerArgument(tmp)
	arg_buffer := gi.NewPointerArgument(buffer.P)
	arg_count := gi.NewUint64Argument(count)
	arg_blocking := gi.NewBoolArgument(blocking)
	arg_cancellable := gi.NewPointerArgument(tmp1)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_stream, arg_buffer, arg_count, arg_blocking, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Int64()
	return
}

// g_pollable_stream_write
// container is nil
// arg 1 buffer lenArgIdx 2
func PollableStreamWrite(stream IOutputStream, buffer gi.Uint8Array, count uint64, blocking bool, cancellable ICancellable) (result int64, err error) {
	iv, err := _I.Get(1689, "pollable_stream_write", "")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if stream != nil {
		tmp = stream.P_OutputStream()
	}
	var tmp1 unsafe.Pointer
	if cancellable != nil {
		tmp1 = cancellable.P_Cancellable()
	}
	arg_stream := gi.NewPointerArgument(tmp)
	arg_buffer := gi.NewPointerArgument(buffer.P)
	arg_count := gi.NewUint64Argument(count)
	arg_blocking := gi.NewBoolArgument(blocking)
	arg_cancellable := gi.NewPointerArgument(tmp1)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_stream, arg_buffer, arg_count, arg_blocking, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result = ret.Int64()
	return
}

// g_pollable_stream_write_all
// container is nil
// arg 1 buffer lenArgIdx 2
func PollableStreamWriteAll(stream IOutputStream, buffer gi.Uint8Array, count uint64, blocking bool, cancellable ICancellable) (result bool, bytes_written uint64, err error) {
	iv, err := _I.Get(1690, "pollable_stream_write_all", "")
	if err != nil {
		return
	}
	var outArgs [2]gi.Argument
	var tmp unsafe.Pointer
	if stream != nil {
		tmp = stream.P_OutputStream()
	}
	var tmp1 unsafe.Pointer
	if cancellable != nil {
		tmp1 = cancellable.P_Cancellable()
	}
	arg_stream := gi.NewPointerArgument(tmp)
	arg_buffer := gi.NewPointerArgument(buffer.P)
	arg_count := gi.NewUint64Argument(count)
	arg_blocking := gi.NewBoolArgument(blocking)
	arg_bytes_written := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	arg_cancellable := gi.NewPointerArgument(tmp1)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[1]))
	args := []gi.Argument{arg_stream, arg_buffer, arg_count, arg_blocking, arg_bytes_written, arg_cancellable, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[1].Pointer())
	bytes_written = outArgs[0].Uint64()
	result = ret.Bool()
	return
}

// g_proxy_get_default_for_protocol
// container is nil
func ProxyGetDefaultForProtocol(protocol string) (result Proxy) {
	iv, err := _I.Get(1691, "proxy_get_default_for_protocol", "")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_protocol := gi.CString(protocol)
	arg_protocol := gi.NewStringArgument(c_protocol)
	args := []gi.Argument{arg_protocol}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_protocol)
	result.P = ret.Pointer()
	return
}

// g_proxy_resolver_get_default
// container is nil
func ProxyResolverGetDefault() (result ProxyResolver) {
	iv, err := _I.Get(1692, "proxy_resolver_get_default", "")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var ret gi.Argument
	iv.Call(nil, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_resolver_error_quark
// container is nil
func ResolverErrorQuark() (result uint32) {
	iv, err := _I.Get(1693, "resolver_error_quark", "")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var ret gi.Argument
	iv.Call(nil, &ret, nil)
	result = ret.Uint32()
	return
}

// g_resource_error_quark
// container is nil
func ResourceErrorQuark() (result uint32) {
	iv, err := _I.Get(1694, "resource_error_quark", "")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var ret gi.Argument
	iv.Call(nil, &ret, nil)
	result = ret.Uint32()
	return
}

// g_resource_load
// container is nil
func ResourceLoad(filename string) (result Resource, err error) {
	iv, err := _I.Get(1695, "resource_load", "")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	c_filename := gi.CString(filename)
	arg_filename := gi.NewStringArgument(c_filename)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_filename, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	gi.Free(c_filename)
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// g_resources_enumerate_children
// container is nil
func ResourcesEnumerateChildren(path string, lookup_flags ResourceLookupFlags) (result gi.CStrArray, err error) {
	iv, err := _I.Get(1696, "resources_enumerate_children", "")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	c_path := gi.CString(path)
	arg_path := gi.NewStringArgument(c_path)
	arg_lookup_flags := gi.NewIntArgument(int(lookup_flags))
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_path, arg_lookup_flags, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	gi.Free(c_path)
	err = gi.ToError(outArgs[0].Pointer())
	result = gi.CStrArray{P: ret.Pointer(), Len: -1}
	result.SetLenZT()
	return
}

// g_resources_get_info
// container is nil
func ResourcesGetInfo(path string, lookup_flags ResourceLookupFlags) (result bool, size uint64, flags uint32, err error) {
	iv, err := _I.Get(1697, "resources_get_info", "")
	if err != nil {
		return
	}
	var outArgs [3]gi.Argument
	c_path := gi.CString(path)
	arg_path := gi.NewStringArgument(c_path)
	arg_lookup_flags := gi.NewIntArgument(int(lookup_flags))
	arg_size := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	arg_flags := gi.NewPointerArgument(unsafe.Pointer(&outArgs[1]))
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[2]))
	args := []gi.Argument{arg_path, arg_lookup_flags, arg_size, arg_flags, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	gi.Free(c_path)
	err = gi.ToError(outArgs[2].Pointer())
	size = outArgs[0].Uint64()
	flags = outArgs[1].Uint32()
	result = ret.Bool()
	return
}

// g_resources_lookup_data
// container is nil
func ResourcesLookupData(path string, lookup_flags ResourceLookupFlags) (result glib.Bytes, err error) {
	iv, err := _I.Get(1698, "resources_lookup_data", "")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	c_path := gi.CString(path)
	arg_path := gi.NewStringArgument(c_path)
	arg_lookup_flags := gi.NewIntArgument(int(lookup_flags))
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_path, arg_lookup_flags, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	gi.Free(c_path)
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// g_resources_open_stream
// container is nil
func ResourcesOpenStream(path string, lookup_flags ResourceLookupFlags) (result InputStream, err error) {
	iv, err := _I.Get(1699, "resources_open_stream", "")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	c_path := gi.CString(path)
	arg_path := gi.NewStringArgument(c_path)
	arg_lookup_flags := gi.NewIntArgument(int(lookup_flags))
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_path, arg_lookup_flags, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	gi.Free(c_path)
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// g_resources_register
// container is nil
func ResourcesRegister(resource Resource) {
	iv, err := _I.Get(1700, "resources_register", "")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_resource := gi.NewPointerArgument(resource.P)
	args := []gi.Argument{arg_resource}
	iv.Call(args, nil, nil)
}

// g_resources_unregister
// container is nil
func ResourcesUnregister(resource Resource) {
	iv, err := _I.Get(1701, "resources_unregister", "")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_resource := gi.NewPointerArgument(resource.P)
	args := []gi.Argument{arg_resource}
	iv.Call(args, nil, nil)
}

// g_settings_schema_source_get_default
// container is nil
func SettingsSchemaSourceGetDefault() (result SettingsSchemaSource) {
	iv, err := _I.Get(1702, "settings_schema_source_get_default", "")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var ret gi.Argument
	iv.Call(nil, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_simple_async_report_gerror_in_idle
// container is nil
func SimpleAsyncReportGerrorInIdle(object gobject.IObject, callback int /*TODO_TYPE isPtr: false, tag: interface*/, user_data unsafe.Pointer, error glib.Error) {
	iv, err := _I.Get(1703, "simple_async_report_gerror_in_idle", "")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var tmp unsafe.Pointer
	if object != nil {
		tmp = object.P_Object()
	}
	arg_object := gi.NewPointerArgument(tmp)
	arg_callback := gi.NewIntArgument(callback) /*TODO*/
	arg_user_data := gi.NewPointerArgument(user_data)
	arg_error := gi.NewPointerArgument(error.P)
	args := []gi.Argument{arg_object, arg_callback, arg_user_data, arg_error}
	iv.Call(args, nil, nil)
}

// g_tls_backend_get_default
// container is nil
func TlsBackendGetDefault() (result TlsBackend) {
	iv, err := _I.Get(1704, "tls_backend_get_default", "")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var ret gi.Argument
	iv.Call(nil, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_tls_client_connection_new
// container is nil
func TlsClientConnectionNew(base_io_stream IIOStream, server_identity ISocketConnectable) (result TlsClientConnection, err error) {
	iv, err := _I.Get(1705, "tls_client_connection_new", "")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if base_io_stream != nil {
		tmp = base_io_stream.P_IOStream()
	}
	var tmp1 unsafe.Pointer
	if server_identity != nil {
		tmp1 = server_identity.P_SocketConnectable()
	}
	arg_base_io_stream := gi.NewPointerArgument(tmp)
	arg_server_identity := gi.NewPointerArgument(tmp1)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_base_io_stream, arg_server_identity, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// g_tls_error_quark
// container is nil
func TlsErrorQuark() (result uint32) {
	iv, err := _I.Get(1706, "tls_error_quark", "")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var ret gi.Argument
	iv.Call(nil, &ret, nil)
	result = ret.Uint32()
	return
}

// g_tls_file_database_new
// container is nil
func TlsFileDatabaseNew(anchors string) (result TlsFileDatabase, err error) {
	iv, err := _I.Get(1707, "tls_file_database_new", "")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	c_anchors := gi.CString(anchors)
	arg_anchors := gi.NewStringArgument(c_anchors)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_anchors, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	gi.Free(c_anchors)
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// g_tls_server_connection_new
// container is nil
func TlsServerConnectionNew(base_io_stream IIOStream, certificate ITlsCertificate) (result TlsServerConnection, err error) {
	iv, err := _I.Get(1708, "tls_server_connection_new", "")
	if err != nil {
		return
	}
	var outArgs [1]gi.Argument
	var tmp unsafe.Pointer
	if base_io_stream != nil {
		tmp = base_io_stream.P_IOStream()
	}
	var tmp1 unsafe.Pointer
	if certificate != nil {
		tmp1 = certificate.P_TlsCertificate()
	}
	arg_base_io_stream := gi.NewPointerArgument(tmp)
	arg_certificate := gi.NewPointerArgument(tmp1)
	arg_err := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_base_io_stream, arg_certificate, arg_err}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	err = gi.ToError(outArgs[0].Pointer())
	result.P = ret.Pointer()
	return
}

// g_unix_is_mount_path_system_internal
// container is nil
func UnixIsMountPathSystemInternal(mount_path string) (result bool) {
	iv, err := _I.Get(1709, "unix_is_mount_path_system_internal", "")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_mount_path := gi.CString(mount_path)
	arg_mount_path := gi.NewStringArgument(c_mount_path)
	args := []gi.Argument{arg_mount_path}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_mount_path)
	result = ret.Bool()
	return
}

// g_unix_is_system_device_path
// container is nil
func UnixIsSystemDevicePath(device_path string) (result bool) {
	iv, err := _I.Get(1710, "unix_is_system_device_path", "")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_device_path := gi.CString(device_path)
	arg_device_path := gi.NewStringArgument(c_device_path)
	args := []gi.Argument{arg_device_path}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_device_path)
	result = ret.Bool()
	return
}

// g_unix_is_system_fs_type
// container is nil
func UnixIsSystemFsType(fs_type string) (result bool) {
	iv, err := _I.Get(1711, "unix_is_system_fs_type", "")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	c_fs_type := gi.CString(fs_type)
	arg_fs_type := gi.NewStringArgument(c_fs_type)
	args := []gi.Argument{arg_fs_type}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	gi.Free(c_fs_type)
	result = ret.Bool()
	return
}

// g_unix_mount_at
// container is nil
func UnixMountAt(mount_path string) (result UnixMountEntry, time_read uint64) {
	iv, err := _I.Get(1712, "unix_mount_at", "")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var outArgs [1]gi.Argument
	c_mount_path := gi.CString(mount_path)
	arg_mount_path := gi.NewStringArgument(c_mount_path)
	arg_time_read := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_mount_path, arg_time_read}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	gi.Free(c_mount_path)
	time_read = outArgs[0].Uint64()
	result.P = ret.Pointer()
	return
}

// g_unix_mount_compare
// container is nil
func UnixMountCompare(mount1 UnixMountEntry, mount2 UnixMountEntry) (result int32) {
	iv, err := _I.Get(1713, "unix_mount_compare", "")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_mount1 := gi.NewPointerArgument(mount1.P)
	arg_mount2 := gi.NewPointerArgument(mount2.P)
	args := []gi.Argument{arg_mount1, arg_mount2}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Int32()
	return
}

// g_unix_mount_copy
// container is nil
func UnixMountCopy(mount_entry UnixMountEntry) (result UnixMountEntry) {
	iv, err := _I.Get(1714, "unix_mount_copy", "")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_mount_entry := gi.NewPointerArgument(mount_entry.P)
	args := []gi.Argument{arg_mount_entry}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_unix_mount_for
// container is nil
func UnixMountFor(file_path string) (result UnixMountEntry, time_read uint64) {
	iv, err := _I.Get(1715, "unix_mount_for", "")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var outArgs [1]gi.Argument
	c_file_path := gi.CString(file_path)
	arg_file_path := gi.NewStringArgument(c_file_path)
	arg_time_read := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_file_path, arg_time_read}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	gi.Free(c_file_path)
	time_read = outArgs[0].Uint64()
	result.P = ret.Pointer()
	return
}

// g_unix_mount_free
// container is nil
func UnixMountFree(mount_entry UnixMountEntry) {
	iv, err := _I.Get(1716, "unix_mount_free", "")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_mount_entry := gi.NewPointerArgument(mount_entry.P)
	args := []gi.Argument{arg_mount_entry}
	iv.Call(args, nil, nil)
}

// g_unix_mount_get_device_path
// container is nil
func UnixMountGetDevicePath(mount_entry UnixMountEntry) (result string) {
	iv, err := _I.Get(1717, "unix_mount_get_device_path", "")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_mount_entry := gi.NewPointerArgument(mount_entry.P)
	args := []gi.Argument{arg_mount_entry}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Take()
	return
}

// g_unix_mount_get_fs_type
// container is nil
func UnixMountGetFsType(mount_entry UnixMountEntry) (result string) {
	iv, err := _I.Get(1718, "unix_mount_get_fs_type", "")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_mount_entry := gi.NewPointerArgument(mount_entry.P)
	args := []gi.Argument{arg_mount_entry}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Take()
	return
}

// g_unix_mount_get_mount_path
// container is nil
func UnixMountGetMountPath(mount_entry UnixMountEntry) (result string) {
	iv, err := _I.Get(1719, "unix_mount_get_mount_path", "")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_mount_entry := gi.NewPointerArgument(mount_entry.P)
	args := []gi.Argument{arg_mount_entry}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Take()
	return
}

// g_unix_mount_get_options
// container is nil
func UnixMountGetOptions(mount_entry UnixMountEntry) (result string) {
	iv, err := _I.Get(1720, "unix_mount_get_options", "")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_mount_entry := gi.NewPointerArgument(mount_entry.P)
	args := []gi.Argument{arg_mount_entry}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Take()
	return
}

// g_unix_mount_guess_can_eject
// container is nil
func UnixMountGuessCanEject(mount_entry UnixMountEntry) (result bool) {
	iv, err := _I.Get(1721, "unix_mount_guess_can_eject", "")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_mount_entry := gi.NewPointerArgument(mount_entry.P)
	args := []gi.Argument{arg_mount_entry}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_unix_mount_guess_icon
// container is nil
func UnixMountGuessIcon(mount_entry UnixMountEntry) (result Icon) {
	iv, err := _I.Get(1722, "unix_mount_guess_icon", "")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_mount_entry := gi.NewPointerArgument(mount_entry.P)
	args := []gi.Argument{arg_mount_entry}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_unix_mount_guess_name
// container is nil
func UnixMountGuessName(mount_entry UnixMountEntry) (result string) {
	iv, err := _I.Get(1723, "unix_mount_guess_name", "")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_mount_entry := gi.NewPointerArgument(mount_entry.P)
	args := []gi.Argument{arg_mount_entry}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.String().Take()
	return
}

// g_unix_mount_guess_should_display
// container is nil
func UnixMountGuessShouldDisplay(mount_entry UnixMountEntry) (result bool) {
	iv, err := _I.Get(1724, "unix_mount_guess_should_display", "")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_mount_entry := gi.NewPointerArgument(mount_entry.P)
	args := []gi.Argument{arg_mount_entry}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_unix_mount_guess_symbolic_icon
// container is nil
func UnixMountGuessSymbolicIcon(mount_entry UnixMountEntry) (result Icon) {
	iv, err := _I.Get(1725, "unix_mount_guess_symbolic_icon", "")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_mount_entry := gi.NewPointerArgument(mount_entry.P)
	args := []gi.Argument{arg_mount_entry}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result.P = ret.Pointer()
	return
}

// g_unix_mount_is_readonly
// container is nil
func UnixMountIsReadonly(mount_entry UnixMountEntry) (result bool) {
	iv, err := _I.Get(1726, "unix_mount_is_readonly", "")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_mount_entry := gi.NewPointerArgument(mount_entry.P)
	args := []gi.Argument{arg_mount_entry}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_unix_mount_is_system_internal
// container is nil
func UnixMountIsSystemInternal(mount_entry UnixMountEntry) (result bool) {
	iv, err := _I.Get(1727, "unix_mount_is_system_internal", "")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_mount_entry := gi.NewPointerArgument(mount_entry.P)
	args := []gi.Argument{arg_mount_entry}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_unix_mount_points_changed_since
// container is nil
func UnixMountPointsChangedSince(time uint64) (result bool) {
	iv, err := _I.Get(1728, "unix_mount_points_changed_since", "")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_time := gi.NewUint64Argument(time)
	args := []gi.Argument{arg_time}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_unix_mount_points_get
// container is nil
func UnixMountPointsGet() (result glib.List, time_read uint64) {
	iv, err := _I.Get(1729, "unix_mount_points_get", "")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var outArgs [1]gi.Argument
	arg_time_read := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_time_read}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	time_read = outArgs[0].Uint64()
	result.P = ret.Pointer()
	return
}

// g_unix_mounts_changed_since
// container is nil
func UnixMountsChangedSince(time uint64) (result bool) {
	iv, err := _I.Get(1730, "unix_mounts_changed_since", "")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	arg_time := gi.NewUint64Argument(time)
	args := []gi.Argument{arg_time}
	var ret gi.Argument
	iv.Call(args, &ret, nil)
	result = ret.Bool()
	return
}

// g_unix_mounts_get
// container is nil
func UnixMountsGet() (result glib.List, time_read uint64) {
	iv, err := _I.Get(1731, "unix_mounts_get", "")
	if err != nil {
		log.Println("WARN:", err)
		return
	}
	var outArgs [1]gi.Argument
	arg_time_read := gi.NewPointerArgument(unsafe.Pointer(&outArgs[0]))
	args := []gi.Argument{arg_time_read}
	var ret gi.Argument
	iv.Call(args, &ret, &outArgs[0])
	time_read = outArgs[0].Uint64()
	result.P = ret.Pointer()
	return
}

// constants
const (
	DESKTOP_APP_INFO_LOOKUP_EXTENSION_POINT_NAME      = "gio-desktop-app-info-lookup"
	DRIVE_IDENTIFIER_KIND_UNIX_DEVICE                 = "unix-device"
	FILE_ATTRIBUTE_ACCESS_CAN_DELETE                  = "access::can-delete"
	FILE_ATTRIBUTE_ACCESS_CAN_EXECUTE                 = "access::can-execute"
	FILE_ATTRIBUTE_ACCESS_CAN_READ                    = "access::can-read"
	FILE_ATTRIBUTE_ACCESS_CAN_RENAME                  = "access::can-rename"
	FILE_ATTRIBUTE_ACCESS_CAN_TRASH                   = "access::can-trash"
	FILE_ATTRIBUTE_ACCESS_CAN_WRITE                   = "access::can-write"
	FILE_ATTRIBUTE_DOS_IS_ARCHIVE                     = "dos::is-archive"
	FILE_ATTRIBUTE_DOS_IS_SYSTEM                      = "dos::is-system"
	FILE_ATTRIBUTE_ETAG_VALUE                         = "etag::value"
	FILE_ATTRIBUTE_FILESYSTEM_FREE                    = "filesystem::free"
	FILE_ATTRIBUTE_FILESYSTEM_READONLY                = "filesystem::readonly"
	FILE_ATTRIBUTE_FILESYSTEM_REMOTE                  = "filesystem::remote"
	FILE_ATTRIBUTE_FILESYSTEM_SIZE                    = "filesystem::size"
	FILE_ATTRIBUTE_FILESYSTEM_TYPE                    = "filesystem::type"
	FILE_ATTRIBUTE_FILESYSTEM_USED                    = "filesystem::used"
	FILE_ATTRIBUTE_FILESYSTEM_USE_PREVIEW             = "filesystem::use-preview"
	FILE_ATTRIBUTE_GVFS_BACKEND                       = "gvfs::backend"
	FILE_ATTRIBUTE_ID_FILE                            = "id::file"
	FILE_ATTRIBUTE_ID_FILESYSTEM                      = "id::filesystem"
	FILE_ATTRIBUTE_MOUNTABLE_CAN_EJECT                = "mountable::can-eject"
	FILE_ATTRIBUTE_MOUNTABLE_CAN_MOUNT                = "mountable::can-mount"
	FILE_ATTRIBUTE_MOUNTABLE_CAN_POLL                 = "mountable::can-poll"
	FILE_ATTRIBUTE_MOUNTABLE_CAN_START                = "mountable::can-start"
	FILE_ATTRIBUTE_MOUNTABLE_CAN_START_DEGRADED       = "mountable::can-start-degraded"
	FILE_ATTRIBUTE_MOUNTABLE_CAN_STOP                 = "mountable::can-stop"
	FILE_ATTRIBUTE_MOUNTABLE_CAN_UNMOUNT              = "mountable::can-unmount"
	FILE_ATTRIBUTE_MOUNTABLE_HAL_UDI                  = "mountable::hal-udi"
	FILE_ATTRIBUTE_MOUNTABLE_IS_MEDIA_CHECK_AUTOMATIC = "mountable::is-media-check-automatic"
	FILE_ATTRIBUTE_MOUNTABLE_START_STOP_TYPE          = "mountable::start-stop-type"
	FILE_ATTRIBUTE_MOUNTABLE_UNIX_DEVICE              = "mountable::unix-device"
	FILE_ATTRIBUTE_MOUNTABLE_UNIX_DEVICE_FILE         = "mountable::unix-device-file"
	FILE_ATTRIBUTE_OWNER_GROUP                        = "owner::group"
	FILE_ATTRIBUTE_OWNER_USER                         = "owner::user"
	FILE_ATTRIBUTE_OWNER_USER_REAL                    = "owner::user-real"
	FILE_ATTRIBUTE_PREVIEW_ICON                       = "preview::icon"
	FILE_ATTRIBUTE_RECENT_MODIFIED                    = "recent::modified"
	FILE_ATTRIBUTE_SELINUX_CONTEXT                    = "selinux::context"
	FILE_ATTRIBUTE_STANDARD_ALLOCATED_SIZE            = "standard::allocated-size"
	FILE_ATTRIBUTE_STANDARD_CONTENT_TYPE              = "standard::content-type"
	FILE_ATTRIBUTE_STANDARD_COPY_NAME                 = "standard::copy-name"
	FILE_ATTRIBUTE_STANDARD_DESCRIPTION               = "standard::description"
	FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME              = "standard::display-name"
	FILE_ATTRIBUTE_STANDARD_EDIT_NAME                 = "standard::edit-name"
	FILE_ATTRIBUTE_STANDARD_FAST_CONTENT_TYPE         = "standard::fast-content-type"
	FILE_ATTRIBUTE_STANDARD_ICON                      = "standard::icon"
	FILE_ATTRIBUTE_STANDARD_IS_BACKUP                 = "standard::is-backup"
	FILE_ATTRIBUTE_STANDARD_IS_HIDDEN                 = "standard::is-hidden"
	FILE_ATTRIBUTE_STANDARD_IS_SYMLINK                = "standard::is-symlink"
	FILE_ATTRIBUTE_STANDARD_IS_VIRTUAL                = "standard::is-virtual"
	FILE_ATTRIBUTE_STANDARD_IS_VOLATILE               = "standard::is-volatile"
	FILE_ATTRIBUTE_STANDARD_NAME                      = "standard::name"
	FILE_ATTRIBUTE_STANDARD_SIZE                      = "standard::size"
	FILE_ATTRIBUTE_STANDARD_SORT_ORDER                = "standard::sort-order"
	FILE_ATTRIBUTE_STANDARD_SYMBOLIC_ICON             = "standard::symbolic-icon"
	FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET            = "standard::symlink-target"
	FILE_ATTRIBUTE_STANDARD_TARGET_URI                = "standard::target-uri"
	FILE_ATTRIBUTE_STANDARD_TYPE                      = "standard::type"
	FILE_ATTRIBUTE_THUMBNAILING_FAILED                = "thumbnail::failed"
	FILE_ATTRIBUTE_THUMBNAIL_IS_VALID                 = "thumbnail::is-valid"
	FILE_ATTRIBUTE_THUMBNAIL_PATH                     = "thumbnail::path"
	FILE_ATTRIBUTE_TIME_ACCESS                        = "time::access"
	FILE_ATTRIBUTE_TIME_ACCESS_USEC                   = "time::access-usec"
	FILE_ATTRIBUTE_TIME_CHANGED                       = "time::changed"
	FILE_ATTRIBUTE_TIME_CHANGED_USEC                  = "time::changed-usec"
	FILE_ATTRIBUTE_TIME_CREATED                       = "time::created"
	FILE_ATTRIBUTE_TIME_CREATED_USEC                  = "time::created-usec"
	FILE_ATTRIBUTE_TIME_MODIFIED                      = "time::modified"
	FILE_ATTRIBUTE_TIME_MODIFIED_USEC                 = "time::modified-usec"
	FILE_ATTRIBUTE_TRASH_DELETION_DATE                = "trash::deletion-date"
	FILE_ATTRIBUTE_TRASH_ITEM_COUNT                   = "trash::item-count"
	FILE_ATTRIBUTE_TRASH_ORIG_PATH                    = "trash::orig-path"
	FILE_ATTRIBUTE_UNIX_BLOCKS                        = "unix::blocks"
	FILE_ATTRIBUTE_UNIX_BLOCK_SIZE                    = "unix::block-size"
	FILE_ATTRIBUTE_UNIX_DEVICE                        = "unix::device"
	FILE_ATTRIBUTE_UNIX_GID                           = "unix::gid"
	FILE_ATTRIBUTE_UNIX_INODE                         = "unix::inode"
	FILE_ATTRIBUTE_UNIX_IS_MOUNTPOINT                 = "unix::is-mountpoint"
	FILE_ATTRIBUTE_UNIX_MODE                          = "unix::mode"
	FILE_ATTRIBUTE_UNIX_NLINK                         = "unix::nlink"
	FILE_ATTRIBUTE_UNIX_RDEV                          = "unix::rdev"
	FILE_ATTRIBUTE_UNIX_UID                           = "unix::uid"
	MENU_ATTRIBUTE_ACTION                             = "action"
	MENU_ATTRIBUTE_ACTION_NAMESPACE                   = "action-namespace"
	MENU_ATTRIBUTE_ICON                               = "icon"
	MENU_ATTRIBUTE_LABEL                              = "label"
	MENU_ATTRIBUTE_TARGET                             = "target"
	MENU_LINK_SECTION                                 = "section"
	MENU_LINK_SUBMENU                                 = "submenu"
	NATIVE_VOLUME_MONITOR_EXTENSION_POINT_NAME        = "gio-native-volume-monitor"
	NETWORK_MONITOR_EXTENSION_POINT_NAME              = "gio-network-monitor"
	PROXY_EXTENSION_POINT_NAME                        = "gio-proxy"
	PROXY_RESOLVER_EXTENSION_POINT_NAME               = "gio-proxy-resolver"
	SETTINGS_BACKEND_EXTENSION_POINT_NAME             = "gsettings-backend"
	TLS_BACKEND_EXTENSION_POINT_NAME                  = "gio-tls-backend"
	TLS_DATABASE_PURPOSE_AUTHENTICATE_CLIENT          = "1.3.6.1.5.5.7.3.2"
	TLS_DATABASE_PURPOSE_AUTHENTICATE_SERVER          = "1.3.6.1.5.5.7.3.1"
	VFS_EXTENSION_POINT_NAME                          = "gio-vfs"
	VOLUME_IDENTIFIER_KIND_CLASS                      = "class"
	VOLUME_IDENTIFIER_KIND_HAL_UDI                    = "hal-udi"
	VOLUME_IDENTIFIER_KIND_LABEL                      = "label"
	VOLUME_IDENTIFIER_KIND_NFS_MOUNT                  = "nfs-mount"
	VOLUME_IDENTIFIER_KIND_UNIX_DEVICE                = "unix-device"
	VOLUME_IDENTIFIER_KIND_UUID                       = "uuid"
	VOLUME_MONITOR_EXTENSION_POINT_NAME               = "gio-volume-monitor"
)
